// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package fbast

import (
	"strconv"

	flatbuffers "github.com/google/flatbuffers/go"
)

type MonoType byte

const (
	MonoTypeNONE         MonoType = 0
	MonoTypeNamedType    MonoType = 1
	MonoTypeTvarType     MonoType = 2
	MonoTypeArrayType    MonoType = 3
	MonoTypeDictType     MonoType = 4
	MonoTypeRecordType   MonoType = 5
	MonoTypeFunctionType MonoType = 6
)

var EnumNamesMonoType = map[MonoType]string{
	MonoTypeNONE:         "NONE",
	MonoTypeNamedType:    "NamedType",
	MonoTypeTvarType:     "TvarType",
	MonoTypeArrayType:    "ArrayType",
	MonoTypeDictType:     "DictType",
	MonoTypeRecordType:   "RecordType",
	MonoTypeFunctionType: "FunctionType",
}

var EnumValuesMonoType = map[string]MonoType{
	"NONE":         MonoTypeNONE,
	"NamedType":    MonoTypeNamedType,
	"TvarType":     MonoTypeTvarType,
	"ArrayType":    MonoTypeArrayType,
	"DictType":     MonoTypeDictType,
	"RecordType":   MonoTypeRecordType,
	"FunctionType": MonoTypeFunctionType,
}

func (v MonoType) String() string {
	if s, ok := EnumNamesMonoType[v]; ok {
		return s
	}
	return "MonoType(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ParameterKind int8

const (
	ParameterKindRequired ParameterKind = 0
	ParameterKindOptional ParameterKind = 1
	ParameterKindPipe     ParameterKind = 2
)

var EnumNamesParameterKind = map[ParameterKind]string{
	ParameterKindRequired: "Required",
	ParameterKindOptional: "Optional",
	ParameterKindPipe:     "Pipe",
}

var EnumValuesParameterKind = map[string]ParameterKind{
	"Required": ParameterKindRequired,
	"Optional": ParameterKindOptional,
	"Pipe":     ParameterKindPipe,
}

func (v ParameterKind) String() string {
	if s, ok := EnumNamesParameterKind[v]; ok {
		return s
	}
	return "ParameterKind(" + strconv.FormatInt(int64(v), 10) + ")"
}

type Statement byte

const (
	StatementNONE                Statement = 0
	StatementBadStatement        Statement = 1
	StatementVariableAssignment  Statement = 2
	StatementMemberAssignment    Statement = 3
	StatementExpressionStatement Statement = 4
	StatementReturnStatement     Statement = 5
	StatementOptionStatement     Statement = 6
	StatementBuiltinStatement    Statement = 7
	StatementTestStatement       Statement = 8
	StatementTestCaseStatement   Statement = 9
)

var EnumNamesStatement = map[Statement]string{
	StatementNONE:                "NONE",
	StatementBadStatement:        "BadStatement",
	StatementVariableAssignment:  "VariableAssignment",
	StatementMemberAssignment:    "MemberAssignment",
	StatementExpressionStatement: "ExpressionStatement",
	StatementReturnStatement:     "ReturnStatement",
	StatementOptionStatement:     "OptionStatement",
	StatementBuiltinStatement:    "BuiltinStatement",
	StatementTestStatement:       "TestStatement",
	StatementTestCaseStatement:   "TestCaseStatement",
}

var EnumValuesStatement = map[string]Statement{
	"NONE":                StatementNONE,
	"BadStatement":        StatementBadStatement,
	"VariableAssignment":  StatementVariableAssignment,
	"MemberAssignment":    StatementMemberAssignment,
	"ExpressionStatement": StatementExpressionStatement,
	"ReturnStatement":     StatementReturnStatement,
	"OptionStatement":     StatementOptionStatement,
	"BuiltinStatement":    StatementBuiltinStatement,
	"TestStatement":       StatementTestStatement,
	"TestCaseStatement":   StatementTestCaseStatement,
}

func (v Statement) String() string {
	if s, ok := EnumNamesStatement[v]; ok {
		return s
	}
	return "Statement(" + strconv.FormatInt(int64(v), 10) + ")"
}

type Assignment byte

const (
	AssignmentNONE               Assignment = 0
	AssignmentMemberAssignment   Assignment = 1
	AssignmentVariableAssignment Assignment = 2
)

var EnumNamesAssignment = map[Assignment]string{
	AssignmentNONE:               "NONE",
	AssignmentMemberAssignment:   "MemberAssignment",
	AssignmentVariableAssignment: "VariableAssignment",
}

var EnumValuesAssignment = map[string]Assignment{
	"NONE":               AssignmentNONE,
	"MemberAssignment":   AssignmentMemberAssignment,
	"VariableAssignment": AssignmentVariableAssignment,
}

func (v Assignment) String() string {
	if s, ok := EnumNamesAssignment[v]; ok {
		return s
	}
	return "Assignment(" + strconv.FormatInt(int64(v), 10) + ")"
}

type Expression byte

const (
	ExpressionNONE                   Expression = 0
	ExpressionStringExpression       Expression = 1
	ExpressionParenExpression        Expression = 2
	ExpressionArrayExpression        Expression = 3
	ExpressionDictExpression         Expression = 4
	ExpressionFunctionExpression     Expression = 5
	ExpressionBinaryExpression       Expression = 6
	ExpressionBooleanLiteral         Expression = 7
	ExpressionCallExpression         Expression = 8
	ExpressionConditionalExpression  Expression = 9
	ExpressionDateTimeLiteral        Expression = 10
	ExpressionDurationLiteral        Expression = 11
	ExpressionFloatLiteral           Expression = 12
	ExpressionIdentifier             Expression = 13
	ExpressionIntegerLiteral         Expression = 14
	ExpressionLogicalExpression      Expression = 15
	ExpressionMemberExpression       Expression = 16
	ExpressionIndexExpression        Expression = 17
	ExpressionObjectExpression       Expression = 18
	ExpressionPipeExpression         Expression = 19
	ExpressionPipeLiteral            Expression = 20
	ExpressionRegexpLiteral          Expression = 21
	ExpressionStringLiteral          Expression = 22
	ExpressionUnaryExpression        Expression = 23
	ExpressionUnsignedIntegerLiteral Expression = 24
	ExpressionBadExpression          Expression = 25
)

var EnumNamesExpression = map[Expression]string{
	ExpressionNONE:                   "NONE",
	ExpressionStringExpression:       "StringExpression",
	ExpressionParenExpression:        "ParenExpression",
	ExpressionArrayExpression:        "ArrayExpression",
	ExpressionDictExpression:         "DictExpression",
	ExpressionFunctionExpression:     "FunctionExpression",
	ExpressionBinaryExpression:       "BinaryExpression",
	ExpressionBooleanLiteral:         "BooleanLiteral",
	ExpressionCallExpression:         "CallExpression",
	ExpressionConditionalExpression:  "ConditionalExpression",
	ExpressionDateTimeLiteral:        "DateTimeLiteral",
	ExpressionDurationLiteral:        "DurationLiteral",
	ExpressionFloatLiteral:           "FloatLiteral",
	ExpressionIdentifier:             "Identifier",
	ExpressionIntegerLiteral:         "IntegerLiteral",
	ExpressionLogicalExpression:      "LogicalExpression",
	ExpressionMemberExpression:       "MemberExpression",
	ExpressionIndexExpression:        "IndexExpression",
	ExpressionObjectExpression:       "ObjectExpression",
	ExpressionPipeExpression:         "PipeExpression",
	ExpressionPipeLiteral:            "PipeLiteral",
	ExpressionRegexpLiteral:          "RegexpLiteral",
	ExpressionStringLiteral:          "StringLiteral",
	ExpressionUnaryExpression:        "UnaryExpression",
	ExpressionUnsignedIntegerLiteral: "UnsignedIntegerLiteral",
	ExpressionBadExpression:          "BadExpression",
}

var EnumValuesExpression = map[string]Expression{
	"NONE":                   ExpressionNONE,
	"StringExpression":       ExpressionStringExpression,
	"ParenExpression":        ExpressionParenExpression,
	"ArrayExpression":        ExpressionArrayExpression,
	"DictExpression":         ExpressionDictExpression,
	"FunctionExpression":     ExpressionFunctionExpression,
	"BinaryExpression":       ExpressionBinaryExpression,
	"BooleanLiteral":         ExpressionBooleanLiteral,
	"CallExpression":         ExpressionCallExpression,
	"ConditionalExpression":  ExpressionConditionalExpression,
	"DateTimeLiteral":        ExpressionDateTimeLiteral,
	"DurationLiteral":        ExpressionDurationLiteral,
	"FloatLiteral":           ExpressionFloatLiteral,
	"Identifier":             ExpressionIdentifier,
	"IntegerLiteral":         ExpressionIntegerLiteral,
	"LogicalExpression":      ExpressionLogicalExpression,
	"MemberExpression":       ExpressionMemberExpression,
	"IndexExpression":        ExpressionIndexExpression,
	"ObjectExpression":       ExpressionObjectExpression,
	"PipeExpression":         ExpressionPipeExpression,
	"PipeLiteral":            ExpressionPipeLiteral,
	"RegexpLiteral":          ExpressionRegexpLiteral,
	"StringLiteral":          ExpressionStringLiteral,
	"UnaryExpression":        ExpressionUnaryExpression,
	"UnsignedIntegerLiteral": ExpressionUnsignedIntegerLiteral,
	"BadExpression":          ExpressionBadExpression,
}

func (v Expression) String() string {
	if s, ok := EnumNamesExpression[v]; ok {
		return s
	}
	return "Expression(" + strconv.FormatInt(int64(v), 10) + ")"
}

type Operator int8

const (
	OperatorInvalidOperator          Operator = 0
	OperatorMultiplicationOperator   Operator = 1
	OperatorDivisionOperator         Operator = 2
	OperatorModuloOperator           Operator = 3
	OperatorPowerOperator            Operator = 4
	OperatorAdditionOperator         Operator = 5
	OperatorSubtractionOperator      Operator = 6
	OperatorLessThanEqualOperator    Operator = 7
	OperatorLessThanOperator         Operator = 8
	OperatorGreaterThanEqualOperator Operator = 9
	OperatorGreaterThanOperator      Operator = 10
	OperatorStartsWithOperator       Operator = 11
	OperatorInOperator               Operator = 12
	OperatorNotOperator              Operator = 13
	OperatorExistsOperator           Operator = 14
	OperatorNotEmptyOperator         Operator = 15
	OperatorEmptyOperator            Operator = 16
	OperatorEqualOperator            Operator = 17
	OperatorNotEqualOperator         Operator = 18
	OperatorRegexpMatchOperator      Operator = 19
	OperatorNotRegexpMatchOperator   Operator = 20
)

var EnumNamesOperator = map[Operator]string{
	OperatorInvalidOperator:          "InvalidOperator",
	OperatorMultiplicationOperator:   "MultiplicationOperator",
	OperatorDivisionOperator:         "DivisionOperator",
	OperatorModuloOperator:           "ModuloOperator",
	OperatorPowerOperator:            "PowerOperator",
	OperatorAdditionOperator:         "AdditionOperator",
	OperatorSubtractionOperator:      "SubtractionOperator",
	OperatorLessThanEqualOperator:    "LessThanEqualOperator",
	OperatorLessThanOperator:         "LessThanOperator",
	OperatorGreaterThanEqualOperator: "GreaterThanEqualOperator",
	OperatorGreaterThanOperator:      "GreaterThanOperator",
	OperatorStartsWithOperator:       "StartsWithOperator",
	OperatorInOperator:               "InOperator",
	OperatorNotOperator:              "NotOperator",
	OperatorExistsOperator:           "ExistsOperator",
	OperatorNotEmptyOperator:         "NotEmptyOperator",
	OperatorEmptyOperator:            "EmptyOperator",
	OperatorEqualOperator:            "EqualOperator",
	OperatorNotEqualOperator:         "NotEqualOperator",
	OperatorRegexpMatchOperator:      "RegexpMatchOperator",
	OperatorNotRegexpMatchOperator:   "NotRegexpMatchOperator",
}

var EnumValuesOperator = map[string]Operator{
	"InvalidOperator":          OperatorInvalidOperator,
	"MultiplicationOperator":   OperatorMultiplicationOperator,
	"DivisionOperator":         OperatorDivisionOperator,
	"ModuloOperator":           OperatorModuloOperator,
	"PowerOperator":            OperatorPowerOperator,
	"AdditionOperator":         OperatorAdditionOperator,
	"SubtractionOperator":      OperatorSubtractionOperator,
	"LessThanEqualOperator":    OperatorLessThanEqualOperator,
	"LessThanOperator":         OperatorLessThanOperator,
	"GreaterThanEqualOperator": OperatorGreaterThanEqualOperator,
	"GreaterThanOperator":      OperatorGreaterThanOperator,
	"StartsWithOperator":       OperatorStartsWithOperator,
	"InOperator":               OperatorInOperator,
	"NotOperator":              OperatorNotOperator,
	"ExistsOperator":           OperatorExistsOperator,
	"NotEmptyOperator":         OperatorNotEmptyOperator,
	"EmptyOperator":            OperatorEmptyOperator,
	"EqualOperator":            OperatorEqualOperator,
	"NotEqualOperator":         OperatorNotEqualOperator,
	"RegexpMatchOperator":      OperatorRegexpMatchOperator,
	"NotRegexpMatchOperator":   OperatorNotRegexpMatchOperator,
}

func (v Operator) String() string {
	if s, ok := EnumNamesOperator[v]; ok {
		return s
	}
	return "Operator(" + strconv.FormatInt(int64(v), 10) + ")"
}

type LogicalOperator int8

const (
	LogicalOperatorAndOperator LogicalOperator = 0
	LogicalOperatorOrOperator  LogicalOperator = 1
)

var EnumNamesLogicalOperator = map[LogicalOperator]string{
	LogicalOperatorAndOperator: "AndOperator",
	LogicalOperatorOrOperator:  "OrOperator",
}

var EnumValuesLogicalOperator = map[string]LogicalOperator{
	"AndOperator": LogicalOperatorAndOperator,
	"OrOperator":  LogicalOperatorOrOperator,
}

func (v LogicalOperator) String() string {
	if s, ok := EnumNamesLogicalOperator[v]; ok {
		return s
	}
	return "LogicalOperator(" + strconv.FormatInt(int64(v), 10) + ")"
}

type TimeUnit int8

const (
	TimeUnity  TimeUnit = 0
	TimeUnitmo TimeUnit = 1
	TimeUnitw  TimeUnit = 2
	TimeUnitd  TimeUnit = 3
	TimeUnith  TimeUnit = 4
	TimeUnitm  TimeUnit = 5
	TimeUnits  TimeUnit = 6
	TimeUnitms TimeUnit = 7
	TimeUnitus TimeUnit = 8
	TimeUnitns TimeUnit = 9
)

var EnumNamesTimeUnit = map[TimeUnit]string{
	TimeUnity:  "y",
	TimeUnitmo: "mo",
	TimeUnitw:  "w",
	TimeUnitd:  "d",
	TimeUnith:  "h",
	TimeUnitm:  "m",
	TimeUnits:  "s",
	TimeUnitms: "ms",
	TimeUnitus: "us",
	TimeUnitns: "ns",
}

var EnumValuesTimeUnit = map[string]TimeUnit{
	"y":  TimeUnity,
	"mo": TimeUnitmo,
	"w":  TimeUnitw,
	"d":  TimeUnitd,
	"h":  TimeUnith,
	"m":  TimeUnitm,
	"s":  TimeUnits,
	"ms": TimeUnitms,
	"us": TimeUnitus,
	"ns": TimeUnitns,
}

func (v TimeUnit) String() string {
	if s, ok := EnumNamesTimeUnit[v]; ok {
		return s
	}
	return "TimeUnit(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ExpressionOrBlock byte

const (
	ExpressionOrBlockNONE              ExpressionOrBlock = 0
	ExpressionOrBlockBlock             ExpressionOrBlock = 1
	ExpressionOrBlockWrappedExpression ExpressionOrBlock = 2
)

var EnumNamesExpressionOrBlock = map[ExpressionOrBlock]string{
	ExpressionOrBlockNONE:              "NONE",
	ExpressionOrBlockBlock:             "Block",
	ExpressionOrBlockWrappedExpression: "WrappedExpression",
}

var EnumValuesExpressionOrBlock = map[string]ExpressionOrBlock{
	"NONE":              ExpressionOrBlockNONE,
	"Block":             ExpressionOrBlockBlock,
	"WrappedExpression": ExpressionOrBlockWrappedExpression,
}

func (v ExpressionOrBlock) String() string {
	if s, ok := EnumNamesExpressionOrBlock[v]; ok {
		return s
	}
	return "ExpressionOrBlock(" + strconv.FormatInt(int64(v), 10) + ")"
}

type PropertyKey byte

const (
	PropertyKeyNONE          PropertyKey = 0
	PropertyKeyIdentifier    PropertyKey = 1
	PropertyKeyStringLiteral PropertyKey = 2
)

var EnumNamesPropertyKey = map[PropertyKey]string{
	PropertyKeyNONE:          "NONE",
	PropertyKeyIdentifier:    "Identifier",
	PropertyKeyStringLiteral: "StringLiteral",
}

var EnumValuesPropertyKey = map[string]PropertyKey{
	"NONE":          PropertyKeyNONE,
	"Identifier":    PropertyKeyIdentifier,
	"StringLiteral": PropertyKeyStringLiteral,
}

func (v PropertyKey) String() string {
	if s, ok := EnumNamesPropertyKey[v]; ok {
		return s
	}
	return "PropertyKey(" + strconv.FormatInt(int64(v), 10) + ")"
}

type NamedType struct {
	_tab flatbuffers.Table
}

func GetRootAsNamedType(buf []byte, offset flatbuffers.UOffsetT) *NamedType {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &NamedType{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsNamedType(buf []byte, offset flatbuffers.UOffsetT) *NamedType {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &NamedType{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *NamedType) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *NamedType) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *NamedType) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *NamedType) Id(obj *Identifier) *Identifier {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Identifier)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func NamedTypeStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func NamedTypeAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func NamedTypeAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(id), 0)
}
func NamedTypeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type TvarType struct {
	_tab flatbuffers.Table
}

func GetRootAsTvarType(buf []byte, offset flatbuffers.UOffsetT) *TvarType {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TvarType{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTvarType(buf []byte, offset flatbuffers.UOffsetT) *TvarType {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &TvarType{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *TvarType) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TvarType) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *TvarType) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *TvarType) Id(obj *Identifier) *Identifier {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Identifier)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func TvarTypeStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func TvarTypeAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func TvarTypeAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(id), 0)
}
func TvarTypeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ArrayType struct {
	_tab flatbuffers.Table
}

func GetRootAsArrayType(buf []byte, offset flatbuffers.UOffsetT) *ArrayType {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ArrayType{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsArrayType(buf []byte, offset flatbuffers.UOffsetT) *ArrayType {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ArrayType{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ArrayType) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ArrayType) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ArrayType) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ArrayType) ElementType() MonoType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return MonoType(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ArrayType) MutateElementType(n MonoType) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *ArrayType) Element(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func ArrayTypeStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func ArrayTypeAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func ArrayTypeAddElementType(builder *flatbuffers.Builder, elementType MonoType) {
	builder.PrependByteSlot(1, byte(elementType), 0)
}
func ArrayTypeAddElement(builder *flatbuffers.Builder, element flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(element), 0)
}
func ArrayTypeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type DictType struct {
	_tab flatbuffers.Table
}

func GetRootAsDictType(buf []byte, offset flatbuffers.UOffsetT) *DictType {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &DictType{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsDictType(buf []byte, offset flatbuffers.UOffsetT) *DictType {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &DictType{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *DictType) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *DictType) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *DictType) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *DictType) KeyType() MonoType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return MonoType(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *DictType) MutateKeyType(n MonoType) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *DictType) Key(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *DictType) ValType() MonoType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return MonoType(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *DictType) MutateValType(n MonoType) bool {
	return rcv._tab.MutateByteSlot(10, byte(n))
}

func (rcv *DictType) Val(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func DictTypeStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func DictTypeAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func DictTypeAddKeyType(builder *flatbuffers.Builder, keyType MonoType) {
	builder.PrependByteSlot(1, byte(keyType), 0)
}
func DictTypeAddKey(builder *flatbuffers.Builder, key flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(key), 0)
}
func DictTypeAddValType(builder *flatbuffers.Builder, valType MonoType) {
	builder.PrependByteSlot(3, byte(valType), 0)
}
func DictTypeAddVal(builder *flatbuffers.Builder, val flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(val), 0)
}
func DictTypeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type PropertyType struct {
	_tab flatbuffers.Table
}

func GetRootAsPropertyType(buf []byte, offset flatbuffers.UOffsetT) *PropertyType {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PropertyType{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsPropertyType(buf []byte, offset flatbuffers.UOffsetT) *PropertyType {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &PropertyType{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *PropertyType) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PropertyType) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *PropertyType) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PropertyType) Id(obj *Identifier) *Identifier {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Identifier)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PropertyType) MonotypeType() MonoType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return MonoType(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *PropertyType) MutateMonotypeType(n MonoType) bool {
	return rcv._tab.MutateByteSlot(8, byte(n))
}

func (rcv *PropertyType) Monotype(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func PropertyTypeStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func PropertyTypeAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func PropertyTypeAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(id), 0)
}
func PropertyTypeAddMonotypeType(builder *flatbuffers.Builder, monotypeType MonoType) {
	builder.PrependByteSlot(2, byte(monotypeType), 0)
}
func PropertyTypeAddMonotype(builder *flatbuffers.Builder, monotype flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(monotype), 0)
}
func PropertyTypeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type RecordType struct {
	_tab flatbuffers.Table
}

func GetRootAsRecordType(buf []byte, offset flatbuffers.UOffsetT) *RecordType {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &RecordType{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsRecordType(buf []byte, offset flatbuffers.UOffsetT) *RecordType {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &RecordType{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *RecordType) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *RecordType) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *RecordType) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *RecordType) Properties(obj *PropertyType, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *RecordType) PropertiesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *RecordType) Tvar(obj *Identifier) *Identifier {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Identifier)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func RecordTypeStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func RecordTypeAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func RecordTypeAddProperties(builder *flatbuffers.Builder, properties flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(properties), 0)
}
func RecordTypeStartPropertiesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func RecordTypeAddTvar(builder *flatbuffers.Builder, tvar flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(tvar), 0)
}
func RecordTypeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ParameterType struct {
	_tab flatbuffers.Table
}

func GetRootAsParameterType(buf []byte, offset flatbuffers.UOffsetT) *ParameterType {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ParameterType{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsParameterType(buf []byte, offset flatbuffers.UOffsetT) *ParameterType {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ParameterType{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ParameterType) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ParameterType) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ParameterType) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ParameterType) Id(obj *Identifier) *Identifier {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Identifier)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ParameterType) MonotypeType() MonoType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return MonoType(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ParameterType) MutateMonotypeType(n MonoType) bool {
	return rcv._tab.MutateByteSlot(8, byte(n))
}

func (rcv *ParameterType) Monotype(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *ParameterType) Kind() ParameterKind {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return ParameterKind(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ParameterType) MutateKind(n ParameterKind) bool {
	return rcv._tab.MutateInt8Slot(12, int8(n))
}

func ParameterTypeStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func ParameterTypeAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func ParameterTypeAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(id), 0)
}
func ParameterTypeAddMonotypeType(builder *flatbuffers.Builder, monotypeType MonoType) {
	builder.PrependByteSlot(2, byte(monotypeType), 0)
}
func ParameterTypeAddMonotype(builder *flatbuffers.Builder, monotype flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(monotype), 0)
}
func ParameterTypeAddKind(builder *flatbuffers.Builder, kind ParameterKind) {
	builder.PrependInt8Slot(4, int8(kind), 0)
}
func ParameterTypeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type FunctionType struct {
	_tab flatbuffers.Table
}

func GetRootAsFunctionType(buf []byte, offset flatbuffers.UOffsetT) *FunctionType {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FunctionType{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsFunctionType(buf []byte, offset flatbuffers.UOffsetT) *FunctionType {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &FunctionType{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *FunctionType) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FunctionType) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *FunctionType) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *FunctionType) Parameters(obj *ParameterType, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *FunctionType) ParametersLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *FunctionType) MonotypeType() MonoType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return MonoType(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *FunctionType) MutateMonotypeType(n MonoType) bool {
	return rcv._tab.MutateByteSlot(8, byte(n))
}

func (rcv *FunctionType) Monotype(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func FunctionTypeStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func FunctionTypeAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func FunctionTypeAddParameters(builder *flatbuffers.Builder, parameters flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(parameters), 0)
}
func FunctionTypeStartParametersVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func FunctionTypeAddMonotypeType(builder *flatbuffers.Builder, monotypeType MonoType) {
	builder.PrependByteSlot(2, byte(monotypeType), 0)
}
func FunctionTypeAddMonotype(builder *flatbuffers.Builder, monotype flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(monotype), 0)
}
func FunctionTypeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type TypeConstraint struct {
	_tab flatbuffers.Table
}

func GetRootAsTypeConstraint(buf []byte, offset flatbuffers.UOffsetT) *TypeConstraint {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TypeConstraint{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTypeConstraint(buf []byte, offset flatbuffers.UOffsetT) *TypeConstraint {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &TypeConstraint{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *TypeConstraint) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TypeConstraint) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *TypeConstraint) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *TypeConstraint) Tvar(obj *Identifier) *Identifier {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Identifier)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *TypeConstraint) Kinds(obj *Identifier, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *TypeConstraint) KindsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func TypeConstraintStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func TypeConstraintAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func TypeConstraintAddTvar(builder *flatbuffers.Builder, tvar flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(tvar), 0)
}
func TypeConstraintAddKinds(builder *flatbuffers.Builder, kinds flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(kinds), 0)
}
func TypeConstraintStartKindsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TypeConstraintEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type TypeExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsTypeExpression(buf []byte, offset flatbuffers.UOffsetT) *TypeExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TypeExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTypeExpression(buf []byte, offset flatbuffers.UOffsetT) *TypeExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &TypeExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *TypeExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TypeExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *TypeExpression) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *TypeExpression) MonotypeType() MonoType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return MonoType(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *TypeExpression) MutateMonotypeType(n MonoType) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *TypeExpression) Monotype(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *TypeExpression) Constraints(obj *TypeConstraint, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *TypeExpression) ConstraintsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func TypeExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func TypeExpressionAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func TypeExpressionAddMonotypeType(builder *flatbuffers.Builder, monotypeType MonoType) {
	builder.PrependByteSlot(1, byte(monotypeType), 0)
}
func TypeExpressionAddMonotype(builder *flatbuffers.Builder, monotype flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(monotype), 0)
}
func TypeExpressionAddConstraints(builder *flatbuffers.Builder, constraints flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(constraints), 0)
}
func TypeExpressionStartConstraintsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TypeExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type Position struct {
	_tab flatbuffers.Struct
}

func (rcv *Position) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Position) Table() flatbuffers.Table {
	return rcv._tab.Table
}

func (rcv *Position) Line() int32 {
	return rcv._tab.GetInt32(rcv._tab.Pos + flatbuffers.UOffsetT(0))
}
func (rcv *Position) MutateLine(n int32) bool {
	return rcv._tab.MutateInt32(rcv._tab.Pos+flatbuffers.UOffsetT(0), n)
}

func (rcv *Position) Column() int32 {
	return rcv._tab.GetInt32(rcv._tab.Pos + flatbuffers.UOffsetT(4))
}
func (rcv *Position) MutateColumn(n int32) bool {
	return rcv._tab.MutateInt32(rcv._tab.Pos+flatbuffers.UOffsetT(4), n)
}

func CreatePosition(builder *flatbuffers.Builder, line int32, column int32) flatbuffers.UOffsetT {
	builder.Prep(4, 8)
	builder.PrependInt32(column)
	builder.PrependInt32(line)
	return builder.Offset()
}

type SourceLocation struct {
	_tab flatbuffers.Table
}

func GetRootAsSourceLocation(buf []byte, offset flatbuffers.UOffsetT) *SourceLocation {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SourceLocation{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsSourceLocation(buf []byte, offset flatbuffers.UOffsetT) *SourceLocation {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &SourceLocation{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *SourceLocation) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SourceLocation) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SourceLocation) File() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *SourceLocation) Start(obj *Position) *Position {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(Position)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *SourceLocation) End(obj *Position) *Position {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(Position)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *SourceLocation) Source() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func SourceLocationStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func SourceLocationAddFile(builder *flatbuffers.Builder, file flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(file), 0)
}
func SourceLocationAddStart(builder *flatbuffers.Builder, start flatbuffers.UOffsetT) {
	builder.PrependStructSlot(1, flatbuffers.UOffsetT(start), 0)
}
func SourceLocationAddEnd(builder *flatbuffers.Builder, end flatbuffers.UOffsetT) {
	builder.PrependStructSlot(2, flatbuffers.UOffsetT(end), 0)
}
func SourceLocationAddSource(builder *flatbuffers.Builder, source flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(source), 0)
}
func SourceLocationEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type Comment struct {
	_tab flatbuffers.Table
}

func GetRootAsComment(buf []byte, offset flatbuffers.UOffsetT) *Comment {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Comment{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsComment(buf []byte, offset flatbuffers.UOffsetT) *Comment {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Comment{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Comment) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Comment) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Comment) Text() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func CommentStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func CommentAddText(builder *flatbuffers.Builder, text flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(text), 0)
}
func CommentEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type BaseNode struct {
	_tab flatbuffers.Table
}

func GetRootAsBaseNode(buf []byte, offset flatbuffers.UOffsetT) *BaseNode {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &BaseNode{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsBaseNode(buf []byte, offset flatbuffers.UOffsetT) *BaseNode {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &BaseNode{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *BaseNode) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *BaseNode) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *BaseNode) Loc(obj *SourceLocation) *SourceLocation {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(SourceLocation)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *BaseNode) Errors(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *BaseNode) ErrorsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *BaseNode) Comments(obj *Comment, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *BaseNode) CommentsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func BaseNodeStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func BaseNodeAddLoc(builder *flatbuffers.Builder, loc flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(loc), 0)
}
func BaseNodeAddErrors(builder *flatbuffers.Builder, errors flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(errors), 0)
}
func BaseNodeStartErrorsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func BaseNodeAddComments(builder *flatbuffers.Builder, comments flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(comments), 0)
}
func BaseNodeStartCommentsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func BaseNodeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type Package struct {
	_tab flatbuffers.Table
}

func GetRootAsPackage(buf []byte, offset flatbuffers.UOffsetT) *Package {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Package{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsPackage(buf []byte, offset flatbuffers.UOffsetT) *Package {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Package{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Package) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Package) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Package) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Package) Path() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Package) Package() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Package) Files(obj *File, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Package) FilesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func PackageStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func PackageAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func PackageAddPath(builder *flatbuffers.Builder, path flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(path), 0)
}
func PackageAddPackage(builder *flatbuffers.Builder, package_ flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(package_), 0)
}
func PackageAddFiles(builder *flatbuffers.Builder, files flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(files), 0)
}
func PackageStartFilesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func PackageEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type File struct {
	_tab flatbuffers.Table
}

func GetRootAsFile(buf []byte, offset flatbuffers.UOffsetT) *File {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &File{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsFile(buf []byte, offset flatbuffers.UOffsetT) *File {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &File{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *File) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *File) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *File) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *File) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *File) Metadata() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *File) Package(obj *PackageClause) *PackageClause {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(PackageClause)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *File) Imports(obj *ImportDeclaration, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *File) ImportsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *File) Body(obj *WrappedStatement, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *File) BodyLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func FileStart(builder *flatbuffers.Builder) {
	builder.StartObject(6)
}
func FileAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func FileAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func FileAddMetadata(builder *flatbuffers.Builder, metadata flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(metadata), 0)
}
func FileAddPackage(builder *flatbuffers.Builder, package_ flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(package_), 0)
}
func FileAddImports(builder *flatbuffers.Builder, imports flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(imports), 0)
}
func FileStartImportsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func FileAddBody(builder *flatbuffers.Builder, body flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(body), 0)
}
func FileStartBodyVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func FileEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type PackageClause struct {
	_tab flatbuffers.Table
}

func GetRootAsPackageClause(buf []byte, offset flatbuffers.UOffsetT) *PackageClause {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PackageClause{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsPackageClause(buf []byte, offset flatbuffers.UOffsetT) *PackageClause {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &PackageClause{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *PackageClause) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PackageClause) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *PackageClause) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PackageClause) Name(obj *Identifier) *Identifier {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Identifier)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func PackageClauseStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func PackageClauseAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func PackageClauseAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func PackageClauseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ImportDeclaration struct {
	_tab flatbuffers.Table
}

func GetRootAsImportDeclaration(buf []byte, offset flatbuffers.UOffsetT) *ImportDeclaration {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ImportDeclaration{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsImportDeclaration(buf []byte, offset flatbuffers.UOffsetT) *ImportDeclaration {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ImportDeclaration{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ImportDeclaration) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ImportDeclaration) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ImportDeclaration) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ImportDeclaration) As(obj *Identifier) *Identifier {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Identifier)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ImportDeclaration) Path(obj *StringLiteral) *StringLiteral {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(StringLiteral)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func ImportDeclarationStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func ImportDeclarationAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func ImportDeclarationAddAs(builder *flatbuffers.Builder, as flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(as), 0)
}
func ImportDeclarationAddPath(builder *flatbuffers.Builder, path flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(path), 0)
}
func ImportDeclarationEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type WrappedStatement struct {
	_tab flatbuffers.Table
}

func GetRootAsWrappedStatement(buf []byte, offset flatbuffers.UOffsetT) *WrappedStatement {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &WrappedStatement{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsWrappedStatement(buf []byte, offset flatbuffers.UOffsetT) *WrappedStatement {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &WrappedStatement{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *WrappedStatement) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *WrappedStatement) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *WrappedStatement) StatementType() Statement {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return Statement(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *WrappedStatement) MutateStatementType(n Statement) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *WrappedStatement) Statement(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func WrappedStatementStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func WrappedStatementAddStatementType(builder *flatbuffers.Builder, statementType Statement) {
	builder.PrependByteSlot(0, byte(statementType), 0)
}
func WrappedStatementAddStatement(builder *flatbuffers.Builder, statement flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(statement), 0)
}
func WrappedStatementEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type BadStatement struct {
	_tab flatbuffers.Table
}

func GetRootAsBadStatement(buf []byte, offset flatbuffers.UOffsetT) *BadStatement {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &BadStatement{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsBadStatement(buf []byte, offset flatbuffers.UOffsetT) *BadStatement {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &BadStatement{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *BadStatement) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *BadStatement) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *BadStatement) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *BadStatement) Text() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func BadStatementStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func BadStatementAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func BadStatementAddText(builder *flatbuffers.Builder, text flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(text), 0)
}
func BadStatementEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type VariableAssignment struct {
	_tab flatbuffers.Table
}

func GetRootAsVariableAssignment(buf []byte, offset flatbuffers.UOffsetT) *VariableAssignment {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &VariableAssignment{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsVariableAssignment(buf []byte, offset flatbuffers.UOffsetT) *VariableAssignment {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &VariableAssignment{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *VariableAssignment) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *VariableAssignment) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *VariableAssignment) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *VariableAssignment) Id(obj *Identifier) *Identifier {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Identifier)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *VariableAssignment) Init_type() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *VariableAssignment) MutateInit_type(n Expression) bool {
	return rcv._tab.MutateByteSlot(8, byte(n))
}

func (rcv *VariableAssignment) Init_(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func VariableAssignmentStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func VariableAssignmentAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func VariableAssignmentAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(id), 0)
}
func VariableAssignmentAddInit_type(builder *flatbuffers.Builder, init_type Expression) {
	builder.PrependByteSlot(2, byte(init_type), 0)
}
func VariableAssignmentAddInit_(builder *flatbuffers.Builder, init_ flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(init_), 0)
}
func VariableAssignmentEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type MemberAssignment struct {
	_tab flatbuffers.Table
}

func GetRootAsMemberAssignment(buf []byte, offset flatbuffers.UOffsetT) *MemberAssignment {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &MemberAssignment{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsMemberAssignment(buf []byte, offset flatbuffers.UOffsetT) *MemberAssignment {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &MemberAssignment{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *MemberAssignment) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *MemberAssignment) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *MemberAssignment) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *MemberAssignment) Member(obj *MemberExpression) *MemberExpression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(MemberExpression)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *MemberAssignment) Init_type() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *MemberAssignment) MutateInit_type(n Expression) bool {
	return rcv._tab.MutateByteSlot(8, byte(n))
}

func (rcv *MemberAssignment) Init_(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func MemberAssignmentStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func MemberAssignmentAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func MemberAssignmentAddMember(builder *flatbuffers.Builder, member flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(member), 0)
}
func MemberAssignmentAddInit_type(builder *flatbuffers.Builder, init_type Expression) {
	builder.PrependByteSlot(2, byte(init_type), 0)
}
func MemberAssignmentAddInit_(builder *flatbuffers.Builder, init_ flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(init_), 0)
}
func MemberAssignmentEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ExpressionStatement struct {
	_tab flatbuffers.Table
}

func GetRootAsExpressionStatement(buf []byte, offset flatbuffers.UOffsetT) *ExpressionStatement {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExpressionStatement{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsExpressionStatement(buf []byte, offset flatbuffers.UOffsetT) *ExpressionStatement {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ExpressionStatement{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ExpressionStatement) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExpressionStatement) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ExpressionStatement) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ExpressionStatement) ExpressionType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ExpressionStatement) MutateExpressionType(n Expression) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *ExpressionStatement) Expression(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func ExpressionStatementStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func ExpressionStatementAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func ExpressionStatementAddExpressionType(builder *flatbuffers.Builder, expressionType Expression) {
	builder.PrependByteSlot(1, byte(expressionType), 0)
}
func ExpressionStatementAddExpression(builder *flatbuffers.Builder, expression flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(expression), 0)
}
func ExpressionStatementEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ReturnStatement struct {
	_tab flatbuffers.Table
}

func GetRootAsReturnStatement(buf []byte, offset flatbuffers.UOffsetT) *ReturnStatement {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ReturnStatement{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsReturnStatement(buf []byte, offset flatbuffers.UOffsetT) *ReturnStatement {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ReturnStatement{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ReturnStatement) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ReturnStatement) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ReturnStatement) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ReturnStatement) ArgumentType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ReturnStatement) MutateArgumentType(n Expression) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *ReturnStatement) Argument(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func ReturnStatementStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func ReturnStatementAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func ReturnStatementAddArgumentType(builder *flatbuffers.Builder, argumentType Expression) {
	builder.PrependByteSlot(1, byte(argumentType), 0)
}
func ReturnStatementAddArgument(builder *flatbuffers.Builder, argument flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(argument), 0)
}
func ReturnStatementEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type OptionStatement struct {
	_tab flatbuffers.Table
}

func GetRootAsOptionStatement(buf []byte, offset flatbuffers.UOffsetT) *OptionStatement {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &OptionStatement{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsOptionStatement(buf []byte, offset flatbuffers.UOffsetT) *OptionStatement {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &OptionStatement{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *OptionStatement) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *OptionStatement) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *OptionStatement) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *OptionStatement) AssignmentType() Assignment {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return Assignment(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *OptionStatement) MutateAssignmentType(n Assignment) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *OptionStatement) Assignment(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func OptionStatementStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func OptionStatementAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func OptionStatementAddAssignmentType(builder *flatbuffers.Builder, assignmentType Assignment) {
	builder.PrependByteSlot(1, byte(assignmentType), 0)
}
func OptionStatementAddAssignment(builder *flatbuffers.Builder, assignment flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(assignment), 0)
}
func OptionStatementEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type BuiltinStatement struct {
	_tab flatbuffers.Table
}

func GetRootAsBuiltinStatement(buf []byte, offset flatbuffers.UOffsetT) *BuiltinStatement {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &BuiltinStatement{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsBuiltinStatement(buf []byte, offset flatbuffers.UOffsetT) *BuiltinStatement {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &BuiltinStatement{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *BuiltinStatement) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *BuiltinStatement) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *BuiltinStatement) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *BuiltinStatement) Id(obj *Identifier) *Identifier {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Identifier)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func BuiltinStatementStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func BuiltinStatementAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func BuiltinStatementAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(id), 0)
}
func BuiltinStatementEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type TestStatement struct {
	_tab flatbuffers.Table
}

func GetRootAsTestStatement(buf []byte, offset flatbuffers.UOffsetT) *TestStatement {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TestStatement{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTestStatement(buf []byte, offset flatbuffers.UOffsetT) *TestStatement {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &TestStatement{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *TestStatement) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TestStatement) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *TestStatement) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *TestStatement) AssignmentType() Assignment {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return Assignment(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *TestStatement) MutateAssignmentType(n Assignment) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *TestStatement) Assignment(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func TestStatementStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func TestStatementAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func TestStatementAddAssignmentType(builder *flatbuffers.Builder, assignmentType Assignment) {
	builder.PrependByteSlot(1, byte(assignmentType), 0)
}
func TestStatementAddAssignment(builder *flatbuffers.Builder, assignment flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(assignment), 0)
}
func TestStatementEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type TestCaseStatement struct {
	_tab flatbuffers.Table
}

func GetRootAsTestCaseStatement(buf []byte, offset flatbuffers.UOffsetT) *TestCaseStatement {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TestCaseStatement{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTestCaseStatement(buf []byte, offset flatbuffers.UOffsetT) *TestCaseStatement {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &TestCaseStatement{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *TestCaseStatement) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TestCaseStatement) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *TestCaseStatement) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *TestCaseStatement) Id(obj *Identifier) *Identifier {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Identifier)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *TestCaseStatement) Extends(obj *StringLiteral) *StringLiteral {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(StringLiteral)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *TestCaseStatement) Block(obj *Block) *Block {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Block)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func TestCaseStatementStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func TestCaseStatementAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func TestCaseStatementAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(id), 0)
}
func TestCaseStatementAddExtends(builder *flatbuffers.Builder, extends flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(extends), 0)
}
func TestCaseStatementAddBlock(builder *flatbuffers.Builder, block flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(block), 0)
}
func TestCaseStatementEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type WrappedExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsWrappedExpression(buf []byte, offset flatbuffers.UOffsetT) *WrappedExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &WrappedExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsWrappedExpression(buf []byte, offset flatbuffers.UOffsetT) *WrappedExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &WrappedExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *WrappedExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *WrappedExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *WrappedExpression) ExprType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *WrappedExpression) MutateExprType(n Expression) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *WrappedExpression) Expr(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func WrappedExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func WrappedExpressionAddExprType(builder *flatbuffers.Builder, exprType Expression) {
	builder.PrependByteSlot(0, byte(exprType), 0)
}
func WrappedExpressionAddExpr(builder *flatbuffers.Builder, expr flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(expr), 0)
}
func WrappedExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type BinaryExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsBinaryExpression(buf []byte, offset flatbuffers.UOffsetT) *BinaryExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &BinaryExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsBinaryExpression(buf []byte, offset flatbuffers.UOffsetT) *BinaryExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &BinaryExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *BinaryExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *BinaryExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *BinaryExpression) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *BinaryExpression) Operator() Operator {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return Operator(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *BinaryExpression) MutateOperator(n Operator) bool {
	return rcv._tab.MutateInt8Slot(6, int8(n))
}

func (rcv *BinaryExpression) LeftType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *BinaryExpression) MutateLeftType(n Expression) bool {
	return rcv._tab.MutateByteSlot(8, byte(n))
}

func (rcv *BinaryExpression) Left(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *BinaryExpression) RightType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *BinaryExpression) MutateRightType(n Expression) bool {
	return rcv._tab.MutateByteSlot(12, byte(n))
}

func (rcv *BinaryExpression) Right(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func BinaryExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(6)
}
func BinaryExpressionAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func BinaryExpressionAddOperator(builder *flatbuffers.Builder, operator Operator) {
	builder.PrependInt8Slot(1, int8(operator), 0)
}
func BinaryExpressionAddLeftType(builder *flatbuffers.Builder, leftType Expression) {
	builder.PrependByteSlot(2, byte(leftType), 0)
}
func BinaryExpressionAddLeft(builder *flatbuffers.Builder, left flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(left), 0)
}
func BinaryExpressionAddRightType(builder *flatbuffers.Builder, rightType Expression) {
	builder.PrependByteSlot(4, byte(rightType), 0)
}
func BinaryExpressionAddRight(builder *flatbuffers.Builder, right flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(right), 0)
}
func BinaryExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type LogicalExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsLogicalExpression(buf []byte, offset flatbuffers.UOffsetT) *LogicalExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &LogicalExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsLogicalExpression(buf []byte, offset flatbuffers.UOffsetT) *LogicalExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &LogicalExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *LogicalExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *LogicalExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *LogicalExpression) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *LogicalExpression) Operator() LogicalOperator {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return LogicalOperator(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *LogicalExpression) MutateOperator(n LogicalOperator) bool {
	return rcv._tab.MutateInt8Slot(6, int8(n))
}

func (rcv *LogicalExpression) LeftType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *LogicalExpression) MutateLeftType(n Expression) bool {
	return rcv._tab.MutateByteSlot(8, byte(n))
}

func (rcv *LogicalExpression) Left(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *LogicalExpression) RightType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *LogicalExpression) MutateRightType(n Expression) bool {
	return rcv._tab.MutateByteSlot(12, byte(n))
}

func (rcv *LogicalExpression) Right(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func LogicalExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(6)
}
func LogicalExpressionAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func LogicalExpressionAddOperator(builder *flatbuffers.Builder, operator LogicalOperator) {
	builder.PrependInt8Slot(1, int8(operator), 0)
}
func LogicalExpressionAddLeftType(builder *flatbuffers.Builder, leftType Expression) {
	builder.PrependByteSlot(2, byte(leftType), 0)
}
func LogicalExpressionAddLeft(builder *flatbuffers.Builder, left flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(left), 0)
}
func LogicalExpressionAddRightType(builder *flatbuffers.Builder, rightType Expression) {
	builder.PrependByteSlot(4, byte(rightType), 0)
}
func LogicalExpressionAddRight(builder *flatbuffers.Builder, right flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(right), 0)
}
func LogicalExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type UnaryExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsUnaryExpression(buf []byte, offset flatbuffers.UOffsetT) *UnaryExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &UnaryExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsUnaryExpression(buf []byte, offset flatbuffers.UOffsetT) *UnaryExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &UnaryExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *UnaryExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *UnaryExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *UnaryExpression) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *UnaryExpression) Operator() Operator {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return Operator(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *UnaryExpression) MutateOperator(n Operator) bool {
	return rcv._tab.MutateInt8Slot(6, int8(n))
}

func (rcv *UnaryExpression) ArgumentType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *UnaryExpression) MutateArgumentType(n Expression) bool {
	return rcv._tab.MutateByteSlot(8, byte(n))
}

func (rcv *UnaryExpression) Argument(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func UnaryExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func UnaryExpressionAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func UnaryExpressionAddOperator(builder *flatbuffers.Builder, operator Operator) {
	builder.PrependInt8Slot(1, int8(operator), 0)
}
func UnaryExpressionAddArgumentType(builder *flatbuffers.Builder, argumentType Expression) {
	builder.PrependByteSlot(2, byte(argumentType), 0)
}
func UnaryExpressionAddArgument(builder *flatbuffers.Builder, argument flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(argument), 0)
}
func UnaryExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type BooleanLiteral struct {
	_tab flatbuffers.Table
}

func GetRootAsBooleanLiteral(buf []byte, offset flatbuffers.UOffsetT) *BooleanLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &BooleanLiteral{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsBooleanLiteral(buf []byte, offset flatbuffers.UOffsetT) *BooleanLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &BooleanLiteral{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *BooleanLiteral) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *BooleanLiteral) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *BooleanLiteral) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *BooleanLiteral) Value() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *BooleanLiteral) MutateValue(n bool) bool {
	return rcv._tab.MutateBoolSlot(6, n)
}

func BooleanLiteralStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func BooleanLiteralAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func BooleanLiteralAddValue(builder *flatbuffers.Builder, value bool) {
	builder.PrependBoolSlot(1, value, false)
}
func BooleanLiteralEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type DateTimeLiteral struct {
	_tab flatbuffers.Table
}

func GetRootAsDateTimeLiteral(buf []byte, offset flatbuffers.UOffsetT) *DateTimeLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &DateTimeLiteral{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsDateTimeLiteral(buf []byte, offset flatbuffers.UOffsetT) *DateTimeLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &DateTimeLiteral{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *DateTimeLiteral) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *DateTimeLiteral) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *DateTimeLiteral) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *DateTimeLiteral) Secs() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *DateTimeLiteral) MutateSecs(n int64) bool {
	return rcv._tab.MutateInt64Slot(6, n)
}

func (rcv *DateTimeLiteral) Nsecs() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *DateTimeLiteral) MutateNsecs(n uint32) bool {
	return rcv._tab.MutateUint32Slot(8, n)
}

func (rcv *DateTimeLiteral) Offset() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *DateTimeLiteral) MutateOffset(n int32) bool {
	return rcv._tab.MutateInt32Slot(10, n)
}

func DateTimeLiteralStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func DateTimeLiteralAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func DateTimeLiteralAddSecs(builder *flatbuffers.Builder, secs int64) {
	builder.PrependInt64Slot(1, secs, 0)
}
func DateTimeLiteralAddNsecs(builder *flatbuffers.Builder, nsecs uint32) {
	builder.PrependUint32Slot(2, nsecs, 0)
}
func DateTimeLiteralAddOffset(builder *flatbuffers.Builder, offset int32) {
	builder.PrependInt32Slot(3, offset, 0)
}
func DateTimeLiteralEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type DurationLiteral struct {
	_tab flatbuffers.Table
}

func GetRootAsDurationLiteral(buf []byte, offset flatbuffers.UOffsetT) *DurationLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &DurationLiteral{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsDurationLiteral(buf []byte, offset flatbuffers.UOffsetT) *DurationLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &DurationLiteral{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *DurationLiteral) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *DurationLiteral) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *DurationLiteral) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *DurationLiteral) Values(obj *Duration, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *DurationLiteral) ValuesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func DurationLiteralStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func DurationLiteralAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func DurationLiteralAddValues(builder *flatbuffers.Builder, values flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(values), 0)
}
func DurationLiteralStartValuesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func DurationLiteralEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type Duration struct {
	_tab flatbuffers.Table
}

func GetRootAsDuration(buf []byte, offset flatbuffers.UOffsetT) *Duration {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Duration{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsDuration(buf []byte, offset flatbuffers.UOffsetT) *Duration {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Duration{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Duration) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Duration) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Duration) Magnitude() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Duration) MutateMagnitude(n int64) bool {
	return rcv._tab.MutateInt64Slot(4, n)
}

func (rcv *Duration) Unit() TimeUnit {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return TimeUnit(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Duration) MutateUnit(n TimeUnit) bool {
	return rcv._tab.MutateInt8Slot(6, int8(n))
}

func DurationStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func DurationAddMagnitude(builder *flatbuffers.Builder, magnitude int64) {
	builder.PrependInt64Slot(0, magnitude, 0)
}
func DurationAddUnit(builder *flatbuffers.Builder, unit TimeUnit) {
	builder.PrependInt8Slot(1, int8(unit), 0)
}
func DurationEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type FloatLiteral struct {
	_tab flatbuffers.Table
}

func GetRootAsFloatLiteral(buf []byte, offset flatbuffers.UOffsetT) *FloatLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FloatLiteral{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsFloatLiteral(buf []byte, offset flatbuffers.UOffsetT) *FloatLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &FloatLiteral{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *FloatLiteral) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FloatLiteral) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *FloatLiteral) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *FloatLiteral) Value() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *FloatLiteral) MutateValue(n float64) bool {
	return rcv._tab.MutateFloat64Slot(6, n)
}

func FloatLiteralStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func FloatLiteralAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func FloatLiteralAddValue(builder *flatbuffers.Builder, value float64) {
	builder.PrependFloat64Slot(1, value, 0.0)
}
func FloatLiteralEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type IntegerLiteral struct {
	_tab flatbuffers.Table
}

func GetRootAsIntegerLiteral(buf []byte, offset flatbuffers.UOffsetT) *IntegerLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &IntegerLiteral{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsIntegerLiteral(buf []byte, offset flatbuffers.UOffsetT) *IntegerLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &IntegerLiteral{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *IntegerLiteral) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *IntegerLiteral) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *IntegerLiteral) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *IntegerLiteral) Value() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *IntegerLiteral) MutateValue(n int64) bool {
	return rcv._tab.MutateInt64Slot(6, n)
}

func IntegerLiteralStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func IntegerLiteralAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func IntegerLiteralAddValue(builder *flatbuffers.Builder, value int64) {
	builder.PrependInt64Slot(1, value, 0)
}
func IntegerLiteralEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type PipeLiteral struct {
	_tab flatbuffers.Table
}

func GetRootAsPipeLiteral(buf []byte, offset flatbuffers.UOffsetT) *PipeLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PipeLiteral{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsPipeLiteral(buf []byte, offset flatbuffers.UOffsetT) *PipeLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &PipeLiteral{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *PipeLiteral) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PipeLiteral) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *PipeLiteral) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func PipeLiteralStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func PipeLiteralAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func PipeLiteralEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type RegexpLiteral struct {
	_tab flatbuffers.Table
}

func GetRootAsRegexpLiteral(buf []byte, offset flatbuffers.UOffsetT) *RegexpLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &RegexpLiteral{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsRegexpLiteral(buf []byte, offset flatbuffers.UOffsetT) *RegexpLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &RegexpLiteral{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *RegexpLiteral) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *RegexpLiteral) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *RegexpLiteral) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *RegexpLiteral) Value() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func RegexpLiteralStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func RegexpLiteralAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func RegexpLiteralAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(value), 0)
}
func RegexpLiteralEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type StringLiteral struct {
	_tab flatbuffers.Table
}

func GetRootAsStringLiteral(buf []byte, offset flatbuffers.UOffsetT) *StringLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &StringLiteral{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsStringLiteral(buf []byte, offset flatbuffers.UOffsetT) *StringLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &StringLiteral{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *StringLiteral) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *StringLiteral) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *StringLiteral) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *StringLiteral) Value() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func StringLiteralStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func StringLiteralAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func StringLiteralAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(value), 0)
}
func StringLiteralEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type UnsignedIntegerLiteral struct {
	_tab flatbuffers.Table
}

func GetRootAsUnsignedIntegerLiteral(buf []byte, offset flatbuffers.UOffsetT) *UnsignedIntegerLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &UnsignedIntegerLiteral{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsUnsignedIntegerLiteral(buf []byte, offset flatbuffers.UOffsetT) *UnsignedIntegerLiteral {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &UnsignedIntegerLiteral{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *UnsignedIntegerLiteral) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *UnsignedIntegerLiteral) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *UnsignedIntegerLiteral) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *UnsignedIntegerLiteral) Value() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *UnsignedIntegerLiteral) MutateValue(n uint64) bool {
	return rcv._tab.MutateUint64Slot(6, n)
}

func UnsignedIntegerLiteralStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func UnsignedIntegerLiteralAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func UnsignedIntegerLiteralAddValue(builder *flatbuffers.Builder, value uint64) {
	builder.PrependUint64Slot(1, value, 0)
}
func UnsignedIntegerLiteralEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type Identifier struct {
	_tab flatbuffers.Table
}

func GetRootAsIdentifier(buf []byte, offset flatbuffers.UOffsetT) *Identifier {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Identifier{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsIdentifier(buf []byte, offset flatbuffers.UOffsetT) *Identifier {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Identifier{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Identifier) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Identifier) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Identifier) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Identifier) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func IdentifierStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func IdentifierAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func IdentifierAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func IdentifierEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type StringExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsStringExpression(buf []byte, offset flatbuffers.UOffsetT) *StringExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &StringExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsStringExpression(buf []byte, offset flatbuffers.UOffsetT) *StringExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &StringExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *StringExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *StringExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *StringExpression) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *StringExpression) Parts(obj *StringExpressionPart, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *StringExpression) PartsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func StringExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func StringExpressionAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func StringExpressionAddParts(builder *flatbuffers.Builder, parts flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(parts), 0)
}
func StringExpressionStartPartsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func StringExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type StringExpressionPart struct {
	_tab flatbuffers.Table
}

func GetRootAsStringExpressionPart(buf []byte, offset flatbuffers.UOffsetT) *StringExpressionPart {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &StringExpressionPart{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsStringExpressionPart(buf []byte, offset flatbuffers.UOffsetT) *StringExpressionPart {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &StringExpressionPart{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *StringExpressionPart) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *StringExpressionPart) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *StringExpressionPart) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *StringExpressionPart) TextValue() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *StringExpressionPart) InterpolatedExpressionType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *StringExpressionPart) MutateInterpolatedExpressionType(n Expression) bool {
	return rcv._tab.MutateByteSlot(8, byte(n))
}

func (rcv *StringExpressionPart) InterpolatedExpression(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func StringExpressionPartStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func StringExpressionPartAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func StringExpressionPartAddTextValue(builder *flatbuffers.Builder, textValue flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(textValue), 0)
}
func StringExpressionPartAddInterpolatedExpressionType(builder *flatbuffers.Builder, interpolatedExpressionType Expression) {
	builder.PrependByteSlot(2, byte(interpolatedExpressionType), 0)
}
func StringExpressionPartAddInterpolatedExpression(builder *flatbuffers.Builder, interpolatedExpression flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(interpolatedExpression), 0)
}
func StringExpressionPartEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ParenExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsParenExpression(buf []byte, offset flatbuffers.UOffsetT) *ParenExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ParenExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsParenExpression(buf []byte, offset flatbuffers.UOffsetT) *ParenExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ParenExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ParenExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ParenExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ParenExpression) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ParenExpression) ExpressionType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ParenExpression) MutateExpressionType(n Expression) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *ParenExpression) Expression(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func ParenExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func ParenExpressionAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func ParenExpressionAddExpressionType(builder *flatbuffers.Builder, expressionType Expression) {
	builder.PrependByteSlot(1, byte(expressionType), 0)
}
func ParenExpressionAddExpression(builder *flatbuffers.Builder, expression flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(expression), 0)
}
func ParenExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ArrayExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsArrayExpression(buf []byte, offset flatbuffers.UOffsetT) *ArrayExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ArrayExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsArrayExpression(buf []byte, offset flatbuffers.UOffsetT) *ArrayExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ArrayExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ArrayExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ArrayExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ArrayExpression) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ArrayExpression) Elements(obj *WrappedExpression, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ArrayExpression) ElementsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func ArrayExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func ArrayExpressionAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func ArrayExpressionAddElements(builder *flatbuffers.Builder, elements flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(elements), 0)
}
func ArrayExpressionStartElementsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ArrayExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type DictExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsDictExpression(buf []byte, offset flatbuffers.UOffsetT) *DictExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &DictExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsDictExpression(buf []byte, offset flatbuffers.UOffsetT) *DictExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &DictExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *DictExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *DictExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *DictExpression) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *DictExpression) Elements(obj *DictItem, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *DictExpression) ElementsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func DictExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func DictExpressionAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func DictExpressionAddElements(builder *flatbuffers.Builder, elements flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(elements), 0)
}
func DictExpressionStartElementsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func DictExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type DictItem struct {
	_tab flatbuffers.Table
}

func GetRootAsDictItem(buf []byte, offset flatbuffers.UOffsetT) *DictItem {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &DictItem{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsDictItem(buf []byte, offset flatbuffers.UOffsetT) *DictItem {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &DictItem{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *DictItem) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *DictItem) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *DictItem) KeyType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *DictItem) MutateKeyType(n Expression) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *DictItem) Key(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *DictItem) ValType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *DictItem) MutateValType(n Expression) bool {
	return rcv._tab.MutateByteSlot(8, byte(n))
}

func (rcv *DictItem) Val(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func DictItemStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func DictItemAddKeyType(builder *flatbuffers.Builder, keyType Expression) {
	builder.PrependByteSlot(0, byte(keyType), 0)
}
func DictItemAddKey(builder *flatbuffers.Builder, key flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(key), 0)
}
func DictItemAddValType(builder *flatbuffers.Builder, valType Expression) {
	builder.PrependByteSlot(2, byte(valType), 0)
}
func DictItemAddVal(builder *flatbuffers.Builder, val flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(val), 0)
}
func DictItemEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type FunctionExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsFunctionExpression(buf []byte, offset flatbuffers.UOffsetT) *FunctionExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FunctionExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsFunctionExpression(buf []byte, offset flatbuffers.UOffsetT) *FunctionExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &FunctionExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *FunctionExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FunctionExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *FunctionExpression) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *FunctionExpression) Params(obj *Property, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *FunctionExpression) ParamsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *FunctionExpression) BodyType() ExpressionOrBlock {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return ExpressionOrBlock(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *FunctionExpression) MutateBodyType(n ExpressionOrBlock) bool {
	return rcv._tab.MutateByteSlot(8, byte(n))
}

func (rcv *FunctionExpression) Body(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func FunctionExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func FunctionExpressionAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func FunctionExpressionAddParams(builder *flatbuffers.Builder, params flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(params), 0)
}
func FunctionExpressionStartParamsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func FunctionExpressionAddBodyType(builder *flatbuffers.Builder, bodyType ExpressionOrBlock) {
	builder.PrependByteSlot(2, byte(bodyType), 0)
}
func FunctionExpressionAddBody(builder *flatbuffers.Builder, body flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(body), 0)
}
func FunctionExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type Block struct {
	_tab flatbuffers.Table
}

func GetRootAsBlock(buf []byte, offset flatbuffers.UOffsetT) *Block {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Block{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsBlock(buf []byte, offset flatbuffers.UOffsetT) *Block {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Block{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Block) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Block) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Block) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Block) Body(obj *WrappedStatement, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Block) BodyLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func BlockStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func BlockAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func BlockAddBody(builder *flatbuffers.Builder, body flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(body), 0)
}
func BlockStartBodyVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func BlockEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type CallExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsCallExpression(buf []byte, offset flatbuffers.UOffsetT) *CallExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CallExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsCallExpression(buf []byte, offset flatbuffers.UOffsetT) *CallExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CallExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *CallExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CallExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *CallExpression) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *CallExpression) CalleeType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *CallExpression) MutateCalleeType(n Expression) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *CallExpression) Callee(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *CallExpression) Arguments(obj *ObjectExpression) *ObjectExpression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ObjectExpression)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func CallExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func CallExpressionAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func CallExpressionAddCalleeType(builder *flatbuffers.Builder, calleeType Expression) {
	builder.PrependByteSlot(1, byte(calleeType), 0)
}
func CallExpressionAddCallee(builder *flatbuffers.Builder, callee flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(callee), 0)
}
func CallExpressionAddArguments(builder *flatbuffers.Builder, arguments flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(arguments), 0)
}
func CallExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ConditionalExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsConditionalExpression(buf []byte, offset flatbuffers.UOffsetT) *ConditionalExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ConditionalExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsConditionalExpression(buf []byte, offset flatbuffers.UOffsetT) *ConditionalExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ConditionalExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ConditionalExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ConditionalExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ConditionalExpression) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ConditionalExpression) TestType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ConditionalExpression) MutateTestType(n Expression) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *ConditionalExpression) Test(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *ConditionalExpression) ConsequentType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ConditionalExpression) MutateConsequentType(n Expression) bool {
	return rcv._tab.MutateByteSlot(10, byte(n))
}

func (rcv *ConditionalExpression) Consequent(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *ConditionalExpression) AlternateType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ConditionalExpression) MutateAlternateType(n Expression) bool {
	return rcv._tab.MutateByteSlot(14, byte(n))
}

func (rcv *ConditionalExpression) Alternate(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func ConditionalExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(7)
}
func ConditionalExpressionAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func ConditionalExpressionAddTestType(builder *flatbuffers.Builder, testType Expression) {
	builder.PrependByteSlot(1, byte(testType), 0)
}
func ConditionalExpressionAddTest(builder *flatbuffers.Builder, test flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(test), 0)
}
func ConditionalExpressionAddConsequentType(builder *flatbuffers.Builder, consequentType Expression) {
	builder.PrependByteSlot(3, byte(consequentType), 0)
}
func ConditionalExpressionAddConsequent(builder *flatbuffers.Builder, consequent flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(consequent), 0)
}
func ConditionalExpressionAddAlternateType(builder *flatbuffers.Builder, alternateType Expression) {
	builder.PrependByteSlot(5, byte(alternateType), 0)
}
func ConditionalExpressionAddAlternate(builder *flatbuffers.Builder, alternate flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(alternate), 0)
}
func ConditionalExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type Property struct {
	_tab flatbuffers.Table
}

func GetRootAsProperty(buf []byte, offset flatbuffers.UOffsetT) *Property {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Property{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsProperty(buf []byte, offset flatbuffers.UOffsetT) *Property {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Property{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Property) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Property) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Property) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Property) KeyType() PropertyKey {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return PropertyKey(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Property) MutateKeyType(n PropertyKey) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *Property) Key(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *Property) ValueType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Property) MutateValueType(n Expression) bool {
	return rcv._tab.MutateByteSlot(10, byte(n))
}

func (rcv *Property) Value(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func PropertyStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func PropertyAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func PropertyAddKeyType(builder *flatbuffers.Builder, keyType PropertyKey) {
	builder.PrependByteSlot(1, byte(keyType), 0)
}
func PropertyAddKey(builder *flatbuffers.Builder, key flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(key), 0)
}
func PropertyAddValueType(builder *flatbuffers.Builder, valueType Expression) {
	builder.PrependByteSlot(3, byte(valueType), 0)
}
func PropertyAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(value), 0)
}
func PropertyEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type MemberExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsMemberExpression(buf []byte, offset flatbuffers.UOffsetT) *MemberExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &MemberExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsMemberExpression(buf []byte, offset flatbuffers.UOffsetT) *MemberExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &MemberExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *MemberExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *MemberExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *MemberExpression) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *MemberExpression) ObjectType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *MemberExpression) MutateObjectType(n Expression) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *MemberExpression) Object(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *MemberExpression) PropertyType() PropertyKey {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return PropertyKey(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *MemberExpression) MutatePropertyType(n PropertyKey) bool {
	return rcv._tab.MutateByteSlot(10, byte(n))
}

func (rcv *MemberExpression) Property(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func MemberExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func MemberExpressionAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func MemberExpressionAddObjectType(builder *flatbuffers.Builder, objectType Expression) {
	builder.PrependByteSlot(1, byte(objectType), 0)
}
func MemberExpressionAddObject(builder *flatbuffers.Builder, object flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(object), 0)
}
func MemberExpressionAddPropertyType(builder *flatbuffers.Builder, propertyType PropertyKey) {
	builder.PrependByteSlot(3, byte(propertyType), 0)
}
func MemberExpressionAddProperty(builder *flatbuffers.Builder, property flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(property), 0)
}
func MemberExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type IndexExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsIndexExpression(buf []byte, offset flatbuffers.UOffsetT) *IndexExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &IndexExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsIndexExpression(buf []byte, offset flatbuffers.UOffsetT) *IndexExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &IndexExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *IndexExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *IndexExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *IndexExpression) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *IndexExpression) ArrayType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *IndexExpression) MutateArrayType(n Expression) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *IndexExpression) Array(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *IndexExpression) IndexType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *IndexExpression) MutateIndexType(n Expression) bool {
	return rcv._tab.MutateByteSlot(10, byte(n))
}

func (rcv *IndexExpression) Index(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func IndexExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func IndexExpressionAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func IndexExpressionAddArrayType(builder *flatbuffers.Builder, arrayType Expression) {
	builder.PrependByteSlot(1, byte(arrayType), 0)
}
func IndexExpressionAddArray(builder *flatbuffers.Builder, array flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(array), 0)
}
func IndexExpressionAddIndexType(builder *flatbuffers.Builder, indexType Expression) {
	builder.PrependByteSlot(3, byte(indexType), 0)
}
func IndexExpressionAddIndex(builder *flatbuffers.Builder, index flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(index), 0)
}
func IndexExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ObjectExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsObjectExpression(buf []byte, offset flatbuffers.UOffsetT) *ObjectExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ObjectExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsObjectExpression(buf []byte, offset flatbuffers.UOffsetT) *ObjectExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ObjectExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ObjectExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ObjectExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ObjectExpression) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ObjectExpression) With(obj *Identifier) *Identifier {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Identifier)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ObjectExpression) Properties(obj *Property, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ObjectExpression) PropertiesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func ObjectExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func ObjectExpressionAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func ObjectExpressionAddWith(builder *flatbuffers.Builder, with flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(with), 0)
}
func ObjectExpressionAddProperties(builder *flatbuffers.Builder, properties flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(properties), 0)
}
func ObjectExpressionStartPropertiesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ObjectExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type PipeExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsPipeExpression(buf []byte, offset flatbuffers.UOffsetT) *PipeExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PipeExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsPipeExpression(buf []byte, offset flatbuffers.UOffsetT) *PipeExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &PipeExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *PipeExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PipeExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *PipeExpression) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PipeExpression) ArgumentType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *PipeExpression) MutateArgumentType(n Expression) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *PipeExpression) Argument(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *PipeExpression) Call(obj *CallExpression) *CallExpression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(CallExpression)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func PipeExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func PipeExpressionAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func PipeExpressionAddArgumentType(builder *flatbuffers.Builder, argumentType Expression) {
	builder.PrependByteSlot(1, byte(argumentType), 0)
}
func PipeExpressionAddArgument(builder *flatbuffers.Builder, argument flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(argument), 0)
}
func PipeExpressionAddCall(builder *flatbuffers.Builder, call flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(call), 0)
}
func PipeExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type BadExpression struct {
	_tab flatbuffers.Table
}

func GetRootAsBadExpression(buf []byte, offset flatbuffers.UOffsetT) *BadExpression {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &BadExpression{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsBadExpression(buf []byte, offset flatbuffers.UOffsetT) *BadExpression {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &BadExpression{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *BadExpression) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *BadExpression) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *BadExpression) BaseNode(obj *BaseNode) *BaseNode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BaseNode)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *BadExpression) Text() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *BadExpression) ExpressionType() Expression {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return Expression(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *BadExpression) MutateExpressionType(n Expression) bool {
	return rcv._tab.MutateByteSlot(8, byte(n))
}

func (rcv *BadExpression) Expression(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func BadExpressionStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func BadExpressionAddBaseNode(builder *flatbuffers.Builder, baseNode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(baseNode), 0)
}
func BadExpressionAddText(builder *flatbuffers.Builder, text flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(text), 0)
}
func BadExpressionAddExpressionType(builder *flatbuffers.Builder, expressionType Expression) {
	builder.PrependByteSlot(2, byte(expressionType), 0)
}
func BadExpressionAddExpression(builder *flatbuffers.Builder, expression flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(expression), 0)
}
func BadExpressionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

package cmd

import (
	"fmt"
	"go/importer"
	"go/token"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/influxdata/flux/codes"
	"github.com/influxdata/flux/internal/errors"
	"github.com/spf13/cobra"
)

// generateCmd represents the generate command
var generateCmd = &cobra.Command{
	Use:   "semantic",
	Short: "Generate translation code from semantic FlatBuffers to Go semantic graph",
	RunE:  generateSemantic,
}

var (
	flagOutput            string
	flagContinueOnMissing bool
)

func init() {
	rootCmd.AddCommand(generateCmd)
	generateCmd.Flags().StringVar(&flagOutput, "output", "",
		"When present, output will be written to the specified file. Otherwise, output is piped to stdout.")
	generateCmd.Flags().BoolVar(&flagContinueOnMissing, "continue-on-missing", false,
		"When set, TODO comments will be put in generated code for missing types, instead of terminating with an error.")
}

const (
	semPath    = "github.com/influxdata/flux/semantic"
	fbsemPath  = "github.com/influxdata/flux/semantic/internal/fbsemantic"
	errorsPath = "github.com/influxdata/flux/internal/errors"
	codesPath  = "github.com/influxdata/flux/codes"
)

func generateSemantic(cmd *cobra.Command, args []string) error {
	if flagOutput != "" {
		// If there are errors in the generated file because its currently under development,
		// replace it with something that won't trip up the call to Import() below.
		if err := ioutil.WriteFile(flagOutput, []byte("package semantic\n"), 0644); err != nil {
			return err
		}
	}
	pkg, err := importer.ForCompiler(&token.FileSet{}, "source", nil).Import("github.com/influxdata/flux/semantic")
	if err != nil {
		log.Fatal(err)
	}

	f := jen.NewFilePath(semPath)
	f.Commentf("DO NOT EDIT.  This file was generated by the fbgen command.")
	f.Line()

	scope := pkg.Scope()
	for _, n := range scope.Names() {
		o := scope.Lookup(n)
		if skipObject(o) {
			continue
		}

		st, ok := o.Type().Underlying().(*types.Struct)
		if !ok {
			continue
		}
		cs := make([]jen.Code, st.NumFields())
		cs = append(cs, jen.Var().Err().Error())
		cs = append(cs,
			jen.If(jen.Id("fb").Op("==").Nil()).Block(
				jen.Return(jen.Nil()),
			),
		)
		for i := 0; i < st.NumFields(); i++ {
			c, err := doField(o, st.Field(i))
			if err != nil {
				return err
			}
			if c != nil {
				cs = append(cs, c...)
			}
		}
		cs = append(cs, jen.Return(jen.Nil()))

		f.Func().Params(jen.Id("rcv").Op("*").Id(o.Name())).
			Id("FromBuf").
			Params(jen.Id("fb").Op("*").Qual(fbsemPath, o.Name())).
			Error().
			Block(cs...)
		f.Line()
	}

	if flagOutput != "" {
		bs := []byte(fmt.Sprintf("%#v", f))
		if err := ioutil.WriteFile(flagOutput, bs, 0644); err != nil {
			return errors.Wrap(err, codes.Internal, "could not write output")
		}
		_, _ = fmt.Fprintf(os.Stderr, "Generated file %v\n", flagOutput)
	} else {
		fmt.Printf("%#v", f)
	}
	return nil
}

func handleMissingf(cs []jen.Code, format string, a ...interface{}) ([]jen.Code, error) {
	if flagContinueOnMissing {
		cs = append(cs,
			jen.Commentf("TODO: "+format, a...),
		)
		return cs, nil
	}
	return nil, errors.Newf(codes.Internal, format, a...)
}

func doField(o types.Object, field *types.Var) ([]jen.Code, error) {
	codes := make([]jen.Code, 0, 1)
	switch t := field.Type().(type) {
	case *types.Named:
		cs, err := doNamed(o, field)
		if err != nil {
			return nil, err
		}
		codes = append(codes, cs...)
	case *types.Basic:
		cs, err := doBasic(o, field)
		if err != nil {
			return nil, err
		}
		codes = append(codes, cs...)
	case *types.Pointer:
		cs, err := doPointer(o, field)
		if err != nil {
			return nil, err
		}
		codes = append(codes, cs...)
	case *types.Slice:
		cs, err := doSlice(o, field)
		if err != nil {
			return nil, err
		}
		codes = append(codes, cs...)
	default:
		var err error
		if codes, err = handleMissingf(codes, "unknown type kind: %#v", t); err != nil {
			return nil, err
		}
	}
	return codes, nil
}

func doNamed(o types.Object, field *types.Var) ([]jen.Code, error) {
	fieldForError := o.Name() + "." + field.Name()
	t := field.Type().(*types.Named)
	var codes []jen.Code
	switch fieldType := t.Obj().Name(); fieldType {
	case "loc":
		codes = append(codes,
			jen.If(
				jen.Id("fbLoc").Op(":=").Id("fb").Dot("Loc").Params(jen.Nil()),
				jen.Id("fbLoc").Op("!=").Nil(),
			).Block(
				ifErrorPropagate(
					jen.Id("rcv").Dot("loc").Dot("FromBuf").Params(jen.Id("fbLoc")),
					o.Name()+"."+field.Name(),
				),
			),
		)
	case "Expression", "PropertyKey", "Assignment":
		helperFn := "from" + fieldType + "Table"
		fbField := toFBName(o.Name(), field.Name())
		codes = append(codes,
			ifErrorPropagate(
				jen.Id(helperFn).Params(
					jen.Id("fb").Dot(fbField),
					jen.Id("fb").Dot(fbConcat(fbField, "Type")).Params(),
				),
				fieldForError,
				jen.Id("rcv").Dot(field.Name()),
			),
		)
	case "OperatorKind":
		codes = append(codes,
			ifErrorPropagate(
				jen.Id("fromFBOperator").Params(jen.Id("fb").Dot(field.Name()).Params()),
				fieldForError,
				jen.Id("rcv").Dot(field.Name()),
			),
		)
	case "LogicalOperatorKind":
		codes = append(codes,
			ifErrorPropagate(
				jen.Id("fromFBLogicalOperator").Params(jen.Id("fb").Dot(field.Name()).Params()),
				fieldForError,
				jen.Id("rcv").Dot(field.Name()),
			),
		)
	case "Time":
		fbVar := jen.Id("fb" + field.Name())
		codes = append(codes,
			jen.If(
				fbVar.Clone().Op(":=").Id("fb").Dot(field.Name()).Params(jen.Nil()),
				fbVar.Clone().Op("!=").Nil(),
			).Block(
				jen.Id("rcv").Dot(field.Name()).Op("=").Id("fromFBTime").Params(fbVar),
			),
		)
	case "Node":
		codes = append(codes,
			ifErrorPropagate(
				jen.Id("fromFBBlock").Params(jen.Id("fb")),
				fieldForError,
				jen.Id("rcv").Dot(field.Name()),
			),
		)
	default:
		var err error
		if codes, err = handleMissingf(codes, "unknown named type: %q", fieldType); err != nil {
			return nil, err
		}
	}
	return codes, nil
}

var (
	fbNames = map[[2]string]string{
		{"NativeVariableAssignment", "Init"}: "Init_",
		{"MemberAssignment", "Init"}:         "Init_",
		{"BuiltinStatement", "ID"}:           "Id",
		{"DurationLiteral", "Values"}:        "Value",
	}
)

func toFBName(structName, fieldName string) string {
	key := [2]string{structName, fieldName}
	if fbn, ok := fbNames[key]; ok {
		return fbn
	}
	return fieldName
}

func fbConcat(s1, s2 string) string {
	if s2 == "" {
		return s1
	}
	if strings.HasSuffix(s1, "_") {
		h := strings.ToLower(s2[0:1])
		s2 = h + s2[1:]

	}
	return s1 + s2
}

func doBasic(o types.Object, field *types.Var) ([]jen.Code, error) {
	var codes []jen.Code
	t := field.Type().(*types.Basic)
	switch n := t.Name(); n {
	case "string":
		codes = append(codes,
			jen.Id("rcv").Dot(field.Name()).Op("=").String().Params(jen.Id("fb").Dot(field.Name()).Params()),
		)
	case "float64", "bool", "int64", "uint64":
		codes = append(codes,
			jen.Id("rcv").Dot(field.Name()).Op("=").Id("fb").Dot(field.Name()).Params(),
		)
	default:
		var err error
		if codes, err = handleMissingf(codes, "unknown basic type: "+n); err != nil {
			return nil, err
		}
	}
	return codes, nil
}

func doSlice(o types.Object, field *types.Var) ([]jen.Code, error) {
	fieldForError := o.Name() + "." + field.Name()
	var codes []jen.Code
	sl := field.Type().(*types.Slice)
	switch t := sl.Elem().(type) {
	case *types.Pointer:
		switch t := t.Elem().(type) {
		case *types.Named:
			switch n := t.Obj().Name(); n {
			case "File", "ImportDeclaration", "FunctionParameter", "Property":
				codes = append(codes, genLoop(o, n, field)...)
			default:
				var err error
				if codes, err = handleMissingf(codes, "unknown slice of ptr to named type: %v", n); err != nil {
					return nil, err
				}
			}
		default:
			var err error
			if codes, err = handleMissingf(codes, "unknown slice elem ptr type: %#v", t); err != nil {
				return nil, err
			}
		}
	case *types.Named:
		switch n := t.Obj().Name(); n {
		case "Statement", "Expression":
			codes = append(codes, genLoop(o, n, field)...)
		case "Duration", "StringExpressionPart":
			helperFn := "fromFB" + n + "Vector"
			codes = append(codes,
				ifErrorPropagate(
					jen.Id(helperFn).Params(jen.Id("fb")),
					fieldForError,
					jen.Id("rcv").Dot(field.Name()),
				),
			)
		default:
			var err error
			if codes, err = handleMissingf(codes, "unknown slice of named type: %v", n); err != nil {
				return nil, err
			}
		}
	default:
		var err error
		if codes, err = handleMissingf(codes, "unknown slice elem type: %#v", t); err != nil {
			return nil, err
		}
	}
	return codes, nil
}

func genLoop(o types.Object, astElemTypeName string, field *types.Var) []jen.Code {
	var codes []jen.Code

	fbFieldName := toFBName(o.Name(), field.Name())
	lenMethodCall := jen.Id("fb").Dot(fbFieldName + "Length").Params()
	elemType := field.Type().(*types.Slice).Elem()
	isInterface := types.IsInterface(elemType)
	_, isPointer := elemType.(*types.Pointer)
	elemTyp := jen.Index()
	if isPointer {
		elemTyp.Add(jen.Op("*"))
	}
	elemTyp.Add(jen.Id(astElemTypeName))

	var loopBody []jen.Code
	{
		fieldForError := o.Name() + "." + field.Name()

		var fbTypeName string
		if isInterface {
			fbTypeName = "Wrapped" + astElemTypeName
		} else {
			fbTypeName = astElemTypeName
		}
		fbElemType := jen.Id("fbsemantic").Dot(fbTypeName)
		fbElemVar := jen.Id("fb" + fbTypeName)

		loopBody = append(loopBody, fbElemVar.Clone().Op(":=").New(fbElemType))
		loopBody = append(loopBody,
			jen.If(jen.Op("!").Id("fb").Dot(fbFieldName).Params(fbElemVar, jen.Id("i"))).Block(
				returnErrorf("could not deserialize %v", fieldForError),
			),
		)

		if isInterface {
			loopBody = append(loopBody,
				ifErrorPropagate(
					jen.Id("from"+fbTypeName).Params(fbElemVar),
					fieldForError,
					jen.Id("rcv").Dot(field.Name()).Index(jen.Id("i")),
				),
			)
		} else {
			loopBody = append(loopBody,
				jen.Id("rcv").Dot(field.Name()).Index(jen.Id("i")).Op("=").New(jen.Id(astElemTypeName)),
				ifErrorPropagate(
					jen.Id("rcv").Dot(field.Name()).Index(jen.Id("i")).Dot("FromBuf").Params(jen.Id("fb"+astElemTypeName)),
					fieldForError,
				),
			)
		}
	}

	codes = append(codes,
		jen.If(
			lenMethodCall.Clone().Add(jen.Op(">").Lit(0)),
		).Block(
			jen.Id("rcv").Dot(field.Name()).Op("=").
				Make(elemTyp, lenMethodCall),
			jen.For(
				jen.Id("i").Op(":=").Lit(0),
				jen.Id("i").Op("<").Add(lenMethodCall),
				jen.Id("i").Op("++"),
			).Block(
				loopBody...,
			),
		),
	)
	return codes
}

func doPointer(o types.Object, field *types.Var) ([]jen.Code, error) {
	fieldForError := o.Name() + "." + field.Name()
	var cs []jen.Code
	sl := field.Type().(*types.Pointer)
	switch t := sl.Elem().(type) {
	case *types.Named:
		switch n := t.Obj().Name(); n {
		case "PackageClause", "Identifier", "ObjectExpression",
			"StringLiteral", "MemberExpression", "IdentifierExpression",
			"NativeVariableAssignment", "FunctionParameters", "FunctionBlock":
			fbVar := jen.Id("fb" + field.Name())
			fbField := toFBName(o.Name(), field.Name())
			cs = append(cs,
				jen.If(
					fbVar.Clone().Op(":=").Id("fb").Dot(fbField).Params(jen.Nil()),
					fbVar.Clone().Op("!=").Nil(),
				).Block(
					jen.Id("rcv").Dot(field.Name()).Op("=").New(jen.Id(n)),
					ifErrorPropagate(
						jen.Id("rcv").Dot(field.Name()).
							Dot("FromBuf").Params(fbVar),
						fieldForError,
					),
				),
			)
		case "Regexp":
			//if rcv.Value, err = fromFBRegexpLiteral(fb); err != nil {
			//	return errors.Wrap(err, codes.Inherit, "RegexpLiteral.Value")
			//}
			cs = append(cs,
				ifErrorPropagate(
					jen.Id("fromFBRegexpLiteral").Params(jen.Id("fb").Dot(field.Name()).Params()),
					fieldForError,
					jen.Id("rcv").Dot(field.Name()),
				),
			)
		default:
			var err error
			if cs, err = handleMissingf(cs, "unknown pointer to named type: %#v", n); err != nil {
				return nil, err
			}
		}
	default:
		var err error
		if cs, err = handleMissingf(cs, "unknown pointer elem type: %#v", t); err != nil {
			return nil, err
		}
	}
	return cs, nil
}

func ifErrorPropagate(call jen.Code, wrapMsg string, assignees ...jen.Code) jen.Code {
	assignees = append(assignees, jen.Err())
	lhs := jen.List(assignees...)
	var ret jen.Code
	if wrapMsg != "" {
		ret = jen.Return(jen.Qual(errorsPath, "Wrap")).Params(jen.Err(), jen.Qual(codesPath, "Inherit"), jen.Lit(wrapMsg))
	} else {
		ret = jen.Return(jen.Err())
	}
	return jen.If(
		lhs.Op("=").Add(call),
		jen.Err().Op("!=").Nil(),
	).Block(
		ret,
	)
}

func returnErrorf(msgf string, args ...interface{}) jen.Code {
	msg := fmt.Sprintf(msgf, args...)
	return jen.Return(jen.Qual(errorsPath, "New").Params(
		jen.Qual(codesPath, "Internal"),
		jen.Lit(msg),
	))
}

var skipNodes = map[string]struct{}{
	"Extern":                     {},
	"ExternBlock":                {},
	"ExternalVariableAssignment": {},
	"InterpolatedPart":           {},
	"TextPart":                   {},
}

func skipObject(o types.Object) bool {
	named, ok := o.Type().(*types.Named)
	if !ok {
		return true
	}
	if !isSemanticNode(named) {
		return true
	}

	_, ok = skipNodes[o.Name()]
	return ok
}

func isSemanticNode(named *types.Named) bool {
	if named.NumMethods() == 0 {
		return false
	}
	for i := 0; i < named.NumMethods(); i++ {
		m := named.Method(i)
		if m.Name() == "node" {
			return true
		}
	}
	return false
}

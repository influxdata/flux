package cmd

import (
	"io/ioutil"
	"path"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/spf13/cobra"
)

// generateCmd represents the generate command
var generateCmd = &cobra.Command{
	Use:   "generate",
	Short: "Generate Go source from Flux source",
	Long: `This utility generates a Go source file that imports the Flux packages.
Only Flux packages that contain Go code will be imported.`,
	RunE: generate,
}

var (
	pkgName,
	rootDir,
	importFile string
)

func init() {
	rootCmd.AddCommand(generateCmd)
	generateCmd.Flags().StringVar(&pkgName, "go-pkg", "", "The fully qualified Go package name of the root package.")
	generateCmd.Flags().StringVar(&rootDir, "root-dir", ".", "The root level directory for all packages.")
	generateCmd.Flags().StringVar(&importFile, "import-file", "builtin_gen.go", "Location relative to root-dir to place a file to import all generated packages.")
}

func generate(cmd *cobra.Command, args []string) error {
	var goPackages []string
	err := walkDirs(rootDir, func(dir string) error {
		if ok, err := needsImport(dir); err != nil {
			return err
		} else if ok {
			goPath := path.Join(pkgName, dir)
			goPackages = append(goPackages, goPath)
		}
		return nil
	})
	if err != nil {
		return err
	}

	// Write the import file
	f := jen.NewFile(path.Base(pkgName))
	f.HeaderComment(`// DO NOT EDIT: This file is autogenerated via the builtin command.
//
// The imports in this file ensures that all the init functions runs and registers
// the builtins for the flux runtime
`)
	f.Anon(goPackages...)
	return f.Save(filepath.Join(rootDir, importFile))
}

func walkDirs(path string, f func(dir string) error) error {
	files, err := ioutil.ReadDir(path)
	if err != nil {
		return err
	}
	if err := f(path); err != nil {
		return err
	}

	for _, file := range files {
		if file.IsDir() {
			if err := walkDirs(filepath.Join(path, file.Name()), f); err != nil {
				return err
			}
		}
	}
	return nil
}

func needsImport(dir string) (bool, error) {
	var hasGo, hasFlux bool
	files, err := ioutil.ReadDir(dir)
	if err != nil {
		return false, err
	}
	for _, f := range files {
		if filepath.Ext(f.Name()) == ".go" &&
			!strings.HasSuffix(path.Base(f.Name()), "_test.go") {
			hasGo = true
		}
		if filepath.Ext(f.Name()) == ".flux" {
			hasFlux = true
		}
	}
	return hasGo && hasFlux && !isInternal(dir), nil
}
func isInternal(p string) bool {
	parts := strings.Split(p, "/")
	// The toplevel `internal` package is allowed
	// so start after that path element.
	for _, part := range parts[1:] {
		if part == "internal" {
			return true
		}
	}
	return false
}

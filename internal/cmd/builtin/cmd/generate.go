package cmd

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/influxdata/flux/ast"
	"github.com/influxdata/flux/codes"
	"github.com/influxdata/flux/internal/errors"
	"github.com/influxdata/flux/internal/token"
	"github.com/influxdata/flux/parser"
	"github.com/spf13/cobra"
)

// generateCmd represents the generate command
var generateCmd = &cobra.Command{
	Use:   "generate",
	Short: "Generate Go source from Flux source",
	Long: `This utility creates Go sources files from Flux source files.
The process is to parse directories recursively and within each directory
write out a single file with the Flux AST representation of the directory source.
`,
	RunE: generate,
}

var (
	pkgName,
	rootDir,
	outDir,
	importFile,
	ignoreFile string
)

func init() {
	rootCmd.AddCommand(generateCmd)
	generateCmd.Flags().StringVar(&pkgName, "go-pkg", "", "The fully qualified Go package name of the root package.")
	generateCmd.Flags().StringVar(&rootDir, "root-dir", ".", "The root level directory for all packages.")
	generateCmd.Flags().StringVar(&outDir, "out-dir", ".", "The directory to write compiled packages.")
	generateCmd.Flags().StringVar(&importFile, "import-file", "builtin_gen.go", "Location relative to root-dir to place a file to import all generated packages.")
	generateCmd.Flags().StringVar(&ignoreFile, "ignoreFile-file", ".fluxignore", "Location relative to root-dir of file containing packages to ignore one per line.")
}

func generate(cmd *cobra.Command, args []string) error {
	ignored, err := readIgnoreFile(ignoreFile)
	if err != nil {
		return err
	}
	var goPackages []string
	err = walkDirs(rootDir, func(dir string) error {
		// Determine the absolute flux package path
		fluxPath, err := filepath.Rel(rootDir, dir)
		if err != nil {
			return err
		}
		if contains(fluxPath, ignored) {
			return nil
		}

		fset := new(token.FileSet)
		pkgs, err := parser.ParseDir(fset, dir)
		if err != nil {
			return err
		}

		// Annotate the packages with the absolute flux package path.
		for _, pkg := range pkgs {
			pkg.Path = fluxPath
		}

		var fluxPkg *ast.Package
		switch len(pkgs) {
		case 0:
			return nil
		case 1, 2:
			for k, v := range pkgs {
				if !strings.HasSuffix(k, "_test") {
					fluxPkg = v
				}
			}
		default:
			keys := make([]string, 0, len(pkgs))
			for k := range pkgs {
				keys = append(keys, k)
			}
			return fmt.Errorf("found more than 2 flux packages in directory %s; packages %v", dir, keys)
		}

		if fluxPkg != nil {
			if ast.Check(fluxPkg) > 0 {
				return errors.Wrapf(ast.GetError(fluxPkg), codes.Inherit, "failed to parse package %q", fluxPkg.Package)
			}
			// Assign import path
			fluxPkg.Path = fluxPath
			// Track go import path
			goPath := path.Join(pkgName, dir)
			if goPath != pkgName {
				goPackages = append(goPackages, goPath)
			}
			// Write the ast file
			if err := generateFluxASTFile(dir, fluxPkg); err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return err
	}

	// Write the import file
	f := jen.NewFile(path.Base(pkgName))
	f.HeaderComment(`// DO NOT EDIT: This file is autogenerated via the builtin command.
//
// The imports in this file ensures that all the init functions runs and registers
// the builtins for the flux runtime
`)
	f.Anon(goPackages...)
	return f.Save(filepath.Join(rootDir, importFile))
}

func generateFluxASTFile(dir string, pkg *ast.Package) error {
	file := jen.NewFile(pkg.Package)
	file.HeaderComment(`// DO NOT EDIT: This file is autogenerated via the builtin command.
//
// This file is empty, but its existence ensures that each Flux package has a
// corresponding Go package. This simplifies importing Go packages with or without
// builtin values.
`)
	return file.Save(filepath.Join(dir, "flux_gen.go"))
}

func readIgnoreFile(fn string) ([]string, error) {
	f, err := os.Open(fn)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil
		}
		return nil, err
	}
	defer f.Close()
	scanner := bufio.NewScanner(f)
	var ignored []string
	for scanner.Scan() {
		ignored = append(ignored, strings.TrimSpace(scanner.Text()))
	}
	return ignored, scanner.Err()
}

func contains(s string, list []string) bool {
	for _, l := range list {
		if s == l {
			return true
		}
	}
	return false
}

func walkDirs(path string, f func(dir string) error) error {
	files, err := ioutil.ReadDir(path)
	if err != nil {
		return err
	}
	if err := f(path); err != nil {
		return err
	}

	for _, file := range files {
		if file.IsDir() {
			if err := walkDirs(filepath.Join(path, file.Name()), f); err != nil {
				return err
			}
		}
	}
	return nil
}

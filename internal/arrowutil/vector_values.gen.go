// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: vector_values.gen.go.tmpl

package arrowutil

import (
	"fmt"
	"regexp"

	"github.com/influxdata/flux"
	"github.com/influxdata/flux/array"
	"github.com/influxdata/flux/memory"
	"github.com/influxdata/flux/semantic"
	"github.com/influxdata/flux/values"
)

func NewVectorValue(arr array.Interface, typ flux.ColType) values.Vector {
	switch elemType := flux.SemanticType(typ); elemType {

	case semantic.BasicInt:
		return NewIntVectorValue(arr.(*array.Int))

	case semantic.BasicUint:
		return NewUintVectorValue(arr.(*array.Uint))

	case semantic.BasicFloat:
		return NewFloatVectorValue(arr.(*array.Float))

	case semantic.BasicBool:
		return NewBooleanVectorValue(arr.(*array.Boolean))

	case semantic.BasicString:
		return NewStringVectorValue(arr.(*array.String))

	default:
		panic(fmt.Errorf("unsupported column data type: %s", typ))
	}
}

// A convenience method for unit testing
func NewVectorFromElements(es ...interface{}) values.Vector {
	var typ flux.ColType
	switch es[0].(type) {

	case int64:
		typ = flux.TInt

	case uint64:
		typ = flux.TUInt

	case float64:
		typ = flux.TFloat

	case bool:
		typ = flux.TBool

	case string:
		typ = flux.TString

	default:
		panic(fmt.Errorf("unsupported data type"))
	}

	vs := make([]values.Value, len(es))
	for i, e := range es {
		vs[i] = values.New(e)
	}
	return newVectorFromSlice(vs, typ)
}

func newVectorFromSlice(values []values.Value, typ flux.ColType) values.Vector {
	switch elemType := flux.SemanticType(typ); elemType {

	case semantic.BasicInt:
		mem := memory.DefaultAllocator
		b := array.NewIntBuilder(mem)
		for _, v := range values {
			b.Append(v.Int())
		}
		arr := b.NewIntArray()
		return NewIntVectorValue(arr)

	case semantic.BasicUint:
		mem := memory.DefaultAllocator
		b := array.NewUintBuilder(mem)
		for _, v := range values {
			b.Append(v.UInt())
		}
		arr := b.NewUintArray()
		return NewUintVectorValue(arr)

	case semantic.BasicFloat:
		mem := memory.DefaultAllocator
		b := array.NewFloatBuilder(mem)
		for _, v := range values {
			b.Append(v.Float())
		}
		arr := b.NewFloatArray()
		return NewFloatVectorValue(arr)

	case semantic.BasicBool:
		mem := memory.DefaultAllocator
		b := array.NewBooleanBuilder(mem)
		for _, v := range values {
			b.Append(v.Bool())
		}
		arr := b.NewBooleanArray()
		return NewBooleanVectorValue(arr)

	case semantic.BasicString:
		mem := memory.DefaultAllocator
		b := array.NewStringBuilder(mem)
		for _, v := range values {
			b.Append(v.Str())
		}
		arr := b.NewStringArray()
		return NewStringVectorValue(arr)

	default:
		panic(fmt.Errorf("unsupported column data type: %s", typ))
	}
}

var _ values.Value = IntVectorValue{}
var _ values.Vector = IntVectorValue{}

type IntVectorValue struct {
	arr *array.Int
	typ semantic.MonoType
	et  semantic.MonoType
}

func NewIntVectorValue(arr *array.Int) values.Vector {
	return IntVectorValue{
		arr: arr,
		typ: semantic.NewVectorType(semantic.BasicInt),
		et:  semantic.BasicInt,
	}
}

func (v IntVectorValue) ElementType() semantic.MonoType { return v.et }

func (v IntVectorValue) Type() semantic.MonoType { return v.typ }
func (v IntVectorValue) IsNull() bool            { return false }
func (v IntVectorValue) Str() string             { panic(values.UnexpectedKind(semantic.Vector, semantic.String)) }
func (v IntVectorValue) Bytes() []byte           { panic(values.UnexpectedKind(semantic.Vector, semantic.Bytes)) }
func (v IntVectorValue) Int() int64              { panic(values.UnexpectedKind(semantic.Vector, semantic.Int)) }
func (v IntVectorValue) UInt() uint64            { panic(values.UnexpectedKind(semantic.Vector, semantic.UInt)) }
func (v IntVectorValue) Float() float64 {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Float))
}
func (v IntVectorValue) Bool() bool { panic(values.UnexpectedKind(semantic.Vector, semantic.Bool)) }
func (v IntVectorValue) Time() values.Time {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Time))
}
func (v IntVectorValue) Duration() values.Duration {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Duration))
}
func (v IntVectorValue) Regexp() *regexp.Regexp {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Regexp))
}
func (v IntVectorValue) Array() values.Array {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Array))
}
func (v IntVectorValue) Object() values.Object {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Object))
}
func (v IntVectorValue) Function() values.Function {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Function))
}
func (v IntVectorValue) Dict() values.Dictionary {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Dictionary))
}

func (v IntVectorValue) Equal(other values.Value) bool {
	otherv, ok := other.(IntVectorValue)
	if !ok {
		return false
	}
	if otherv.Type().Nature() != semantic.Vector {
		return false
	} else if v.Len() != otherv.Len() {
		return false
	}

	for i, n := 0, v.arr.Len(); i < n; i++ {
		if !v.Get(i).Equal(otherv.Get(i)) {
			return false
		}
	}
	return true
}
func (v IntVectorValue) Get(i int) values.Value {
	if v.arr.IsNull(i) {
		return values.Null
	}
	return values.New(v.arr.Value(i))
}

func (v IntVectorValue) Set(i int, value values.Value) { panic("cannot set value on immutable vector") }
func (v IntVectorValue) Append(value values.Value)     { panic("cannot append to immutable vector") }

func (v IntVectorValue) Len() int { return v.arr.Len() }
func (v IntVectorValue) Range(f func(i int, v values.Value)) {
	for i, n := 0, v.arr.Len(); i < n; i++ {
		f(i, v.Get(i))
	}
}

func (v IntVectorValue) Sort(f func(i values.Value, j values.Value) bool) {
	panic("cannot sort immutable vector")
}

var _ values.Value = UintVectorValue{}
var _ values.Vector = UintVectorValue{}

type UintVectorValue struct {
	arr *array.Uint
	typ semantic.MonoType
	et  semantic.MonoType
}

func NewUintVectorValue(arr *array.Uint) values.Vector {
	return UintVectorValue{
		arr: arr,
		typ: semantic.NewVectorType(semantic.BasicUint),
		et:  semantic.BasicUint,
	}
}

func (v UintVectorValue) ElementType() semantic.MonoType { return v.et }

func (v UintVectorValue) Type() semantic.MonoType { return v.typ }
func (v UintVectorValue) IsNull() bool            { return false }
func (v UintVectorValue) Str() string             { panic(values.UnexpectedKind(semantic.Vector, semantic.String)) }
func (v UintVectorValue) Bytes() []byte {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Bytes))
}
func (v UintVectorValue) Int() int64   { panic(values.UnexpectedKind(semantic.Vector, semantic.Int)) }
func (v UintVectorValue) UInt() uint64 { panic(values.UnexpectedKind(semantic.Vector, semantic.UInt)) }
func (v UintVectorValue) Float() float64 {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Float))
}
func (v UintVectorValue) Bool() bool { panic(values.UnexpectedKind(semantic.Vector, semantic.Bool)) }
func (v UintVectorValue) Time() values.Time {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Time))
}
func (v UintVectorValue) Duration() values.Duration {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Duration))
}
func (v UintVectorValue) Regexp() *regexp.Regexp {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Regexp))
}
func (v UintVectorValue) Array() values.Array {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Array))
}
func (v UintVectorValue) Object() values.Object {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Object))
}
func (v UintVectorValue) Function() values.Function {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Function))
}
func (v UintVectorValue) Dict() values.Dictionary {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Dictionary))
}

func (v UintVectorValue) Equal(other values.Value) bool {
	otherv, ok := other.(UintVectorValue)
	if !ok {
		return false
	}
	if otherv.Type().Nature() != semantic.Vector {
		return false
	} else if v.Len() != otherv.Len() {
		return false
	}

	for i, n := 0, v.arr.Len(); i < n; i++ {
		if !v.Get(i).Equal(otherv.Get(i)) {
			return false
		}
	}
	return true
}
func (v UintVectorValue) Get(i int) values.Value {
	if v.arr.IsNull(i) {
		return values.Null
	}
	return values.New(v.arr.Value(i))
}

func (v UintVectorValue) Set(i int, value values.Value) {
	panic("cannot set value on immutable vector")
}
func (v UintVectorValue) Append(value values.Value) { panic("cannot append to immutable vector") }

func (v UintVectorValue) Len() int { return v.arr.Len() }
func (v UintVectorValue) Range(f func(i int, v values.Value)) {
	for i, n := 0, v.arr.Len(); i < n; i++ {
		f(i, v.Get(i))
	}
}

func (v UintVectorValue) Sort(f func(i values.Value, j values.Value) bool) {
	panic("cannot sort immutable vector")
}

var _ values.Value = FloatVectorValue{}
var _ values.Vector = FloatVectorValue{}

type FloatVectorValue struct {
	arr *array.Float
	typ semantic.MonoType
	et  semantic.MonoType
}

func NewFloatVectorValue(arr *array.Float) values.Vector {
	return FloatVectorValue{
		arr: arr,
		typ: semantic.NewVectorType(semantic.BasicFloat),
		et:  semantic.BasicFloat,
	}
}

func (v FloatVectorValue) ElementType() semantic.MonoType { return v.et }

func (v FloatVectorValue) Type() semantic.MonoType { return v.typ }
func (v FloatVectorValue) IsNull() bool            { return false }
func (v FloatVectorValue) Str() string {
	panic(values.UnexpectedKind(semantic.Vector, semantic.String))
}
func (v FloatVectorValue) Bytes() []byte {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Bytes))
}
func (v FloatVectorValue) Int() int64   { panic(values.UnexpectedKind(semantic.Vector, semantic.Int)) }
func (v FloatVectorValue) UInt() uint64 { panic(values.UnexpectedKind(semantic.Vector, semantic.UInt)) }
func (v FloatVectorValue) Float() float64 {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Float))
}
func (v FloatVectorValue) Bool() bool { panic(values.UnexpectedKind(semantic.Vector, semantic.Bool)) }
func (v FloatVectorValue) Time() values.Time {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Time))
}
func (v FloatVectorValue) Duration() values.Duration {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Duration))
}
func (v FloatVectorValue) Regexp() *regexp.Regexp {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Regexp))
}
func (v FloatVectorValue) Array() values.Array {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Array))
}
func (v FloatVectorValue) Object() values.Object {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Object))
}
func (v FloatVectorValue) Function() values.Function {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Function))
}
func (v FloatVectorValue) Dict() values.Dictionary {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Dictionary))
}

func (v FloatVectorValue) Equal(other values.Value) bool {
	otherv, ok := other.(FloatVectorValue)
	if !ok {
		return false
	}
	if otherv.Type().Nature() != semantic.Vector {
		return false
	} else if v.Len() != otherv.Len() {
		return false
	}

	for i, n := 0, v.arr.Len(); i < n; i++ {
		if !v.Get(i).Equal(otherv.Get(i)) {
			return false
		}
	}
	return true
}
func (v FloatVectorValue) Get(i int) values.Value {
	if v.arr.IsNull(i) {
		return values.Null
	}
	return values.New(v.arr.Value(i))
}

func (v FloatVectorValue) Set(i int, value values.Value) {
	panic("cannot set value on immutable vector")
}
func (v FloatVectorValue) Append(value values.Value) { panic("cannot append to immutable vector") }

func (v FloatVectorValue) Len() int { return v.arr.Len() }
func (v FloatVectorValue) Range(f func(i int, v values.Value)) {
	for i, n := 0, v.arr.Len(); i < n; i++ {
		f(i, v.Get(i))
	}
}

func (v FloatVectorValue) Sort(f func(i values.Value, j values.Value) bool) {
	panic("cannot sort immutable vector")
}

var _ values.Value = BooleanVectorValue{}
var _ values.Vector = BooleanVectorValue{}

type BooleanVectorValue struct {
	arr *array.Boolean
	typ semantic.MonoType
	et  semantic.MonoType
}

func NewBooleanVectorValue(arr *array.Boolean) values.Vector {
	return BooleanVectorValue{
		arr: arr,
		typ: semantic.NewVectorType(semantic.BasicBool),
		et:  semantic.BasicBool,
	}
}

func (v BooleanVectorValue) ElementType() semantic.MonoType { return v.et }

func (v BooleanVectorValue) Type() semantic.MonoType { return v.typ }
func (v BooleanVectorValue) IsNull() bool            { return false }
func (v BooleanVectorValue) Str() string {
	panic(values.UnexpectedKind(semantic.Vector, semantic.String))
}
func (v BooleanVectorValue) Bytes() []byte {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Bytes))
}
func (v BooleanVectorValue) Int() int64 { panic(values.UnexpectedKind(semantic.Vector, semantic.Int)) }
func (v BooleanVectorValue) UInt() uint64 {
	panic(values.UnexpectedKind(semantic.Vector, semantic.UInt))
}
func (v BooleanVectorValue) Float() float64 {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Float))
}
func (v BooleanVectorValue) Bool() bool { panic(values.UnexpectedKind(semantic.Vector, semantic.Bool)) }
func (v BooleanVectorValue) Time() values.Time {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Time))
}
func (v BooleanVectorValue) Duration() values.Duration {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Duration))
}
func (v BooleanVectorValue) Regexp() *regexp.Regexp {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Regexp))
}
func (v BooleanVectorValue) Array() values.Array {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Array))
}
func (v BooleanVectorValue) Object() values.Object {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Object))
}
func (v BooleanVectorValue) Function() values.Function {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Function))
}
func (v BooleanVectorValue) Dict() values.Dictionary {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Dictionary))
}

func (v BooleanVectorValue) Equal(other values.Value) bool {
	otherv, ok := other.(BooleanVectorValue)
	if !ok {
		return false
	}
	if otherv.Type().Nature() != semantic.Vector {
		return false
	} else if v.Len() != otherv.Len() {
		return false
	}

	for i, n := 0, v.arr.Len(); i < n; i++ {
		if !v.Get(i).Equal(otherv.Get(i)) {
			return false
		}
	}
	return true
}
func (v BooleanVectorValue) Get(i int) values.Value {
	if v.arr.IsNull(i) {
		return values.Null
	}
	return values.New(v.arr.Value(i))
}

func (v BooleanVectorValue) Set(i int, value values.Value) {
	panic("cannot set value on immutable vector")
}
func (v BooleanVectorValue) Append(value values.Value) { panic("cannot append to immutable vector") }

func (v BooleanVectorValue) Len() int { return v.arr.Len() }
func (v BooleanVectorValue) Range(f func(i int, v values.Value)) {
	for i, n := 0, v.arr.Len(); i < n; i++ {
		f(i, v.Get(i))
	}
}

func (v BooleanVectorValue) Sort(f func(i values.Value, j values.Value) bool) {
	panic("cannot sort immutable vector")
}

var _ values.Value = StringVectorValue{}
var _ values.Vector = StringVectorValue{}

type StringVectorValue struct {
	arr *array.String
	typ semantic.MonoType
	et  semantic.MonoType
}

func NewStringVectorValue(arr *array.String) values.Vector {
	return StringVectorValue{
		arr: arr,
		typ: semantic.NewVectorType(semantic.BasicString),
		et:  semantic.BasicString,
	}
}

func (v StringVectorValue) ElementType() semantic.MonoType { return v.et }

func (v StringVectorValue) Type() semantic.MonoType { return v.typ }
func (v StringVectorValue) IsNull() bool            { return false }
func (v StringVectorValue) Str() string {
	panic(values.UnexpectedKind(semantic.Vector, semantic.String))
}
func (v StringVectorValue) Bytes() []byte {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Bytes))
}
func (v StringVectorValue) Int() int64 { panic(values.UnexpectedKind(semantic.Vector, semantic.Int)) }
func (v StringVectorValue) UInt() uint64 {
	panic(values.UnexpectedKind(semantic.Vector, semantic.UInt))
}
func (v StringVectorValue) Float() float64 {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Float))
}
func (v StringVectorValue) Bool() bool { panic(values.UnexpectedKind(semantic.Vector, semantic.Bool)) }
func (v StringVectorValue) Time() values.Time {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Time))
}
func (v StringVectorValue) Duration() values.Duration {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Duration))
}
func (v StringVectorValue) Regexp() *regexp.Regexp {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Regexp))
}
func (v StringVectorValue) Array() values.Array {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Array))
}
func (v StringVectorValue) Object() values.Object {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Object))
}
func (v StringVectorValue) Function() values.Function {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Function))
}
func (v StringVectorValue) Dict() values.Dictionary {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Dictionary))
}

func (v StringVectorValue) Equal(other values.Value) bool {
	otherv, ok := other.(StringVectorValue)
	if !ok {
		return false
	}
	if otherv.Type().Nature() != semantic.Vector {
		return false
	} else if v.Len() != otherv.Len() {
		return false
	}

	for i, n := 0, v.arr.Len(); i < n; i++ {
		if !v.Get(i).Equal(otherv.Get(i)) {
			return false
		}
	}
	return true
}
func (v StringVectorValue) Get(i int) values.Value {
	if v.arr.IsNull(i) {
		return values.Null
	}
	return values.New(v.arr.Value(i))
}

func (v StringVectorValue) Set(i int, value values.Value) {
	panic("cannot set value on immutable vector")
}
func (v StringVectorValue) Append(value values.Value) { panic("cannot append to immutable vector") }

func (v StringVectorValue) Len() int { return v.arr.Len() }
func (v StringVectorValue) Range(f func(i int, v values.Value)) {
	for i, n := 0, v.arr.Len(); i < n; i++ {
		f(i, v.Get(i))
	}
}

func (v StringVectorValue) Sort(f func(i values.Value, j values.Value) bool) {
	panic("cannot sort immutable vector")
}

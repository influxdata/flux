// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: binary.gen.go.tmpl

package array

import (
	"math"

	"github.com/apache/arrow/go/v7/arrow/memory"
	"github.com/influxdata/flux/codes"
	"github.com/influxdata/flux/internal/errors"
)

type IntArrLike interface {
	IsValid(i int) bool
	Value(i int) int64
	Len() int
}

type UintArrLike interface {
	IsValid(i int) bool
	Value(i int) uint64
	Len() int
}

type FloatArrLike interface {
	IsValid(i int) bool
	Value(i int) float64
	Len() int
}

type StringArrLike interface {
	IsValid(i int) bool
	Value(i int) string
	Len() int
}

func IntAdd(l, r IntArrLike, mem memory.Allocator) (*Int, error) {

	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Int); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := r.(*Int); ok {
		arrCount += 1
		rn = r.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func UintAdd(l, r UintArrLike, mem memory.Allocator) (*Uint, error) {

	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Uint); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := r.(*Uint); ok {
		arrCount += 1
		rn = r.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func FloatAdd(l, r FloatArrLike, mem memory.Allocator) (*Float, error) {

	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Float); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := r.(*Float); ok {
		arrCount += 1
		rn = r.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func StringAdd(l, r StringArrLike, mem memory.Allocator) (*String, error) {

	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*String); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := r.(*String); ok {
		arrCount += 1
		rn = r.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewStringBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewStringArray()
	b.Release()
	return a, nil
}

func IntSub(l, r IntArrLike, mem memory.Allocator) (*Int, error) {

	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Int); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := r.(*Int); ok {
		arrCount += 1
		rn = r.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) - r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func UintSub(l, r UintArrLike, mem memory.Allocator) (*Uint, error) {

	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Uint); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := r.(*Uint); ok {
		arrCount += 1
		rn = r.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) - r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func FloatSub(l, r FloatArrLike, mem memory.Allocator) (*Float, error) {

	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Float); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := r.(*Float); ok {
		arrCount += 1
		rn = r.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) - r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func IntMul(l, r IntArrLike, mem memory.Allocator) (*Int, error) {

	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Int); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := r.(*Int); ok {
		arrCount += 1
		rn = r.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) * r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func UintMul(l, r UintArrLike, mem memory.Allocator) (*Uint, error) {

	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Uint); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := r.(*Uint); ok {
		arrCount += 1
		rn = r.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) * r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func FloatMul(l, r FloatArrLike, mem memory.Allocator) (*Float, error) {

	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Float); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := r.(*Float); ok {
		arrCount += 1
		rn = r.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) * r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func IntDiv(l, r IntArrLike, mem memory.Allocator) (*Int, error) {

	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Int); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := r.(*Int); ok {
		arrCount += 1
		rn = r.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) / r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func UintDiv(l, r UintArrLike, mem memory.Allocator) (*Uint, error) {

	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Uint); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := r.(*Uint); ok {
		arrCount += 1
		rn = r.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) / r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func FloatDiv(l, r FloatArrLike, mem memory.Allocator) (*Float, error) {

	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Float); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := r.(*Float); ok {
		arrCount += 1
		rn = r.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) / r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func IntMod(l, r IntArrLike, mem memory.Allocator) (*Int, error) {

	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Int); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := r.(*Int); ok {
		arrCount += 1
		rn = r.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) % r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func UintMod(l, r UintArrLike, mem memory.Allocator) (*Uint, error) {

	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Uint); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := r.(*Uint); ok {
		arrCount += 1
		rn = r.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) % r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func FloatMod(l, r FloatArrLike, mem memory.Allocator) (*Float, error) {

	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Float); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := r.(*Float); ok {
		arrCount += 1
		rn = r.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(math.Mod(l.Value(i), r.Value(i)))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func IntPow(l, r IntArrLike, mem memory.Allocator) (*Float, error) {
	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Int); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := l.(*Int); ok {
		arrCount += 1
		rn = l.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(math.Pow(float64(l.Value(i)), float64(r.Value(i))))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func UintPow(l, r UintArrLike, mem memory.Allocator) (*Float, error) {
	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Uint); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := l.(*Uint); ok {
		arrCount += 1
		rn = l.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(math.Pow(float64(l.Value(i)), float64(r.Value(i))))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatPow(l, r FloatArrLike, mem memory.Allocator) (*Float, error) {
	ln := 0
	rn := 0
	arrCount := 0
	if _, ok := l.(*Float); ok {
		arrCount += 1
		ln = l.Len()
	}
	if _, ok := l.(*Float); ok {
		arrCount += 1
		rn = l.Len()
	}

	// We can only do a length comparison in the case where neither side is a const.
	// Vec Repeat has no array backing, and therefore has no size.
	if arrCount == 2 && ln != rn {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	// FIXME(onelson): need some way to hint the size for the 2 const case.
	if arrCount == 0 {
		panic("combining constants cannot be vectorized")
	}
	var n int
	if ln > rn {
		n = ln
	} else {
		n = rn
	}

	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(math.Pow(float64(l.Value(i)), float64(r.Value(i))))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

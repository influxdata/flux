// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: binary.gen.go.tmpl

package array

import (
	"math"

	"github.com/apache/arrow/go/v7/arrow/memory"
	"github.com/influxdata/flux/codes"
	"github.com/influxdata/flux/internal/errors"
)

func IntAdd(l, r *Int, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntAddLConst(l int64, r *Int, mem memory.Allocator) (*Int, error) {
	n := r.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntAddRConst(l *Int, r int64, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) + r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func UintAdd(l, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintAddLConst(l uint64, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := r.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintAddRConst(l *Uint, r uint64, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) + r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func FloatAdd(l, r *Float, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatAddLConst(l float64, r *Float, mem memory.Allocator) (*Float, error) {
	n := r.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatAddRConst(l *Float, r float64, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) + r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func StringAdd(l, r *String, mem memory.Allocator) (*String, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewStringBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewStringArray()
	b.Release()
	return a, nil
}

func StringAddLConst(l string, r *String, mem memory.Allocator) (*String, error) {
	n := r.Len()
	b := NewStringBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewStringArray()
	b.Release()
	return a, nil
}

func StringAddRConst(l *String, r string, mem memory.Allocator) (*String, error) {
	n := l.Len()
	b := NewStringBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) + r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewStringArray()
	b.Release()
	return a, nil
}

func IntSub(l, r *Int, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) - r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntSubLConst(l int64, r *Int, mem memory.Allocator) (*Int, error) {
	n := r.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l - r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntSubRConst(l *Int, r int64, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) - r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func UintSub(l, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) - r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintSubLConst(l uint64, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := r.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l - r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintSubRConst(l *Uint, r uint64, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) - r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func FloatSub(l, r *Float, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) - r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatSubLConst(l float64, r *Float, mem memory.Allocator) (*Float, error) {
	n := r.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l - r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatSubRConst(l *Float, r float64, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) - r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func IntMul(l, r *Int, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) * r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntMulLConst(l int64, r *Int, mem memory.Allocator) (*Int, error) {
	n := r.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l * r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntMulRConst(l *Int, r int64, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) * r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func UintMul(l, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) * r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintMulLConst(l uint64, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := r.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l * r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintMulRConst(l *Uint, r uint64, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) * r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func FloatMul(l, r *Float, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) * r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatMulLConst(l float64, r *Float, mem memory.Allocator) (*Float, error) {
	n := r.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l * r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatMulRConst(l *Float, r float64, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) * r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func IntDiv(l, r *Int, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) / r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntDivLConst(l int64, r *Int, mem memory.Allocator) (*Int, error) {
	n := r.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l / r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntDivRConst(l *Int, r int64, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) / r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func UintDiv(l, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) / r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintDivLConst(l uint64, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := r.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l / r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintDivRConst(l *Uint, r uint64, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) / r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func FloatDiv(l, r *Float, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) / r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatDivLConst(l float64, r *Float, mem memory.Allocator) (*Float, error) {
	n := r.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l / r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatDivRConst(l *Float, r float64, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) / r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func IntMod(l, r *Int, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) % r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntModLConst(l int64, r *Int, mem memory.Allocator) (*Int, error) {
	n := r.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l % r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntModRConst(l *Int, r int64, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) % r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func UintMod(l, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) % r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintModLConst(l uint64, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := r.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l % r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintModRConst(l *Uint, r uint64, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) % r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func FloatMod(l, r *Float, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(math.Mod(l.Value(i), r.Value(i)))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatModLConst(l float64, r *Float, mem memory.Allocator) (*Float, error) {
	n := r.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(math.Mod(l, r.Value(i)))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatModRConst(l *Float, r float64, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(math.Mod(l.Value(i), r))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func IntPow(l, r *Int, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}

	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(math.Pow(float64(l.Value(i)), float64(r.Value(i))))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func IntPowLConst(l int64, r *Int, mem memory.Allocator) (*Float, error) {
	n := r.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	lf := float64(l)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(math.Pow(lf, float64(r.Value(i))))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func IntPowRConst(l *Int, r int64, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	rf := float64(r)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(math.Pow(float64(l.Value(i)), rf))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func UintPow(l, r *Uint, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}

	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(math.Pow(float64(l.Value(i)), float64(r.Value(i))))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func UintPowLConst(l uint64, r *Uint, mem memory.Allocator) (*Float, error) {
	n := r.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	lf := float64(l)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(math.Pow(lf, float64(r.Value(i))))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func UintPowRConst(l *Uint, r uint64, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	rf := float64(r)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(math.Pow(float64(l.Value(i)), rf))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatPow(l, r *Float, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}

	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(math.Pow(float64(l.Value(i)), float64(r.Value(i))))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatPowLConst(l float64, r *Float, mem memory.Allocator) (*Float, error) {
	n := r.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	lf := float64(l)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(math.Pow(lf, float64(r.Value(i))))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatPowRConst(l *Float, r float64, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	rf := float64(r)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(math.Pow(float64(l.Value(i)), rf))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func BooleanEqual(l, r *Boolean, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) == r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func BooleanEqualLConst(l bool, r *Boolean, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l == r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func BooleanEqualRConst(l *Boolean, r bool, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) == r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntEqual(l, r *Int, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) == r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntEqualLConst(l int64, r *Int, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l == r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntEqualRConst(l *Int, r int64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) == r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintEqual(l, r *Uint, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) == r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintEqualLConst(l uint64, r *Uint, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l == r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintEqualRConst(l *Uint, r uint64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) == r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatEqual(l, r *Float, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) == r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatEqualLConst(l float64, r *Float, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l == r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatEqualRConst(l *Float, r float64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) == r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringEqual(l, r *String, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) == r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringEqualLConst(l string, r *String, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l == r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringEqualRConst(l *String, r string, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) == r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func BooleanNotEqual(l, r *Boolean, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) != r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func BooleanNotEqualLConst(l bool, r *Boolean, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l != r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func BooleanNotEqualRConst(l *Boolean, r bool, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) != r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntNotEqual(l, r *Int, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) != r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntNotEqualLConst(l int64, r *Int, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l != r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntNotEqualRConst(l *Int, r int64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) != r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintNotEqual(l, r *Uint, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) != r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintNotEqualLConst(l uint64, r *Uint, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l != r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintNotEqualRConst(l *Uint, r uint64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) != r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatNotEqual(l, r *Float, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) != r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatNotEqualLConst(l float64, r *Float, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l != r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatNotEqualRConst(l *Float, r float64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) != r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringNotEqual(l, r *String, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) != r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringNotEqualLConst(l string, r *String, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l != r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringNotEqualRConst(l *String, r string, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) != r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntLessThan(l, r *Int, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) < r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntLessThanLConst(l int64, r *Int, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l < r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntLessThanRConst(l *Int, r int64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) < r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintLessThan(l, r *Uint, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) < r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintLessThanLConst(l uint64, r *Uint, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l < r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintLessThanRConst(l *Uint, r uint64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) < r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatLessThan(l, r *Float, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) < r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatLessThanLConst(l float64, r *Float, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l < r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatLessThanRConst(l *Float, r float64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) < r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringLessThan(l, r *String, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) < r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringLessThanLConst(l string, r *String, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l < r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringLessThanRConst(l *String, r string, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) < r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntLessThanEqual(l, r *Int, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) <= r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntLessThanEqualLConst(l int64, r *Int, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l <= r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntLessThanEqualRConst(l *Int, r int64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) <= r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintLessThanEqual(l, r *Uint, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) <= r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintLessThanEqualLConst(l uint64, r *Uint, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l <= r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintLessThanEqualRConst(l *Uint, r uint64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) <= r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatLessThanEqual(l, r *Float, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) <= r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatLessThanEqualLConst(l float64, r *Float, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l <= r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatLessThanEqualRConst(l *Float, r float64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) <= r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringLessThanEqual(l, r *String, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) <= r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringLessThanEqualLConst(l string, r *String, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l <= r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringLessThanEqualRConst(l *String, r string, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) <= r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntGreaterThan(l, r *Int, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) > r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntGreaterThanLConst(l int64, r *Int, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l > r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntGreaterThanRConst(l *Int, r int64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) > r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintGreaterThan(l, r *Uint, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) > r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintGreaterThanLConst(l uint64, r *Uint, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l > r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintGreaterThanRConst(l *Uint, r uint64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) > r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatGreaterThan(l, r *Float, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) > r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatGreaterThanLConst(l float64, r *Float, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l > r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatGreaterThanRConst(l *Float, r float64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) > r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringGreaterThan(l, r *String, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) > r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringGreaterThanLConst(l string, r *String, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l > r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringGreaterThanRConst(l *String, r string, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) > r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntGreaterThanEqual(l, r *Int, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) >= r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntGreaterThanEqualLConst(l int64, r *Int, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l >= r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func IntGreaterThanEqualRConst(l *Int, r int64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) >= r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintGreaterThanEqual(l, r *Uint, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) >= r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintGreaterThanEqualLConst(l uint64, r *Uint, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l >= r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintGreaterThanEqualRConst(l *Uint, r uint64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) >= r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatGreaterThanEqual(l, r *Float, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) >= r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatGreaterThanEqualLConst(l float64, r *Float, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l >= r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatGreaterThanEqualRConst(l *Float, r float64, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) >= r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringGreaterThanEqual(l, r *String, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(l.Value(i) >= r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringGreaterThanEqualLConst(l string, r *String, mem memory.Allocator) (*Boolean, error) {
	n := r.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(l >= r.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringGreaterThanEqualRConst(l *String, r string, mem memory.Allocator) (*Boolean, error) {
	n := l.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(l.Value(i) >= r)
		} else {
			b.AppendNull()
		}
	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

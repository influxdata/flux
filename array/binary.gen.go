// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: binary.gen.go.tmpl

package array

import (
	"math"

	"github.com/apache/arrow/go/v7/arrow/memory"
	"github.com/influxdata/flux/codes"
	"github.com/influxdata/flux/internal/errors"
)

func IntAdd(l, r *Int, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntAddLConst(l int64, r *Int, mem memory.Allocator) (*Int, error) {
	n := r.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntAddRConst(l *Int, r int64, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) + r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func UintAdd(l, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintAddLConst(l uint64, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := r.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintAddRConst(l *Uint, r uint64, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) + r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func FloatAdd(l, r *Float, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatAddLConst(l float64, r *Float, mem memory.Allocator) (*Float, error) {
	n := r.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatAddRConst(l *Float, r float64, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) + r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func StringAdd(l, r *String, mem memory.Allocator) (*String, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewStringBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewStringArray()
	b.Release()
	return a, nil
}

func StringAddLConst(l string, r *String, mem memory.Allocator) (*String, error) {
	n := r.Len()
	b := NewStringBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l + r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewStringArray()
	b.Release()
	return a, nil
}

func StringAddRConst(l *String, r string, mem memory.Allocator) (*String, error) {
	n := l.Len()
	b := NewStringBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) + r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewStringArray()
	b.Release()
	return a, nil
}

func IntSub(l, r *Int, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) - r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntSubLConst(l int64, r *Int, mem memory.Allocator) (*Int, error) {
	n := r.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l - r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntSubRConst(l *Int, r int64, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) - r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func UintSub(l, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) - r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintSubLConst(l uint64, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := r.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l - r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintSubRConst(l *Uint, r uint64, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) - r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func FloatSub(l, r *Float, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) - r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatSubLConst(l float64, r *Float, mem memory.Allocator) (*Float, error) {
	n := r.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l - r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatSubRConst(l *Float, r float64, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) - r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func IntMul(l, r *Int, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) * r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntMulLConst(l int64, r *Int, mem memory.Allocator) (*Int, error) {
	n := r.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l * r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntMulRConst(l *Int, r int64, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) * r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func UintMul(l, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) * r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintMulLConst(l uint64, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := r.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l * r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintMulRConst(l *Uint, r uint64, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) * r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func FloatMul(l, r *Float, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) * r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatMulLConst(l float64, r *Float, mem memory.Allocator) (*Float, error) {
	n := r.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l * r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatMulRConst(l *Float, r float64, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) * r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func IntDiv(l, r *Int, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) / r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntDivLConst(l int64, r *Int, mem memory.Allocator) (*Int, error) {
	n := r.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l / r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntDivRConst(l *Int, r int64, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) / r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func UintDiv(l, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) / r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintDivLConst(l uint64, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := r.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l / r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintDivRConst(l *Uint, r uint64, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) / r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func FloatDiv(l, r *Float, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) / r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatDivLConst(l float64, r *Float, mem memory.Allocator) (*Float, error) {
	n := r.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l / r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatDivRConst(l *Float, r float64, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) / r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func IntMod(l, r *Int, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) % r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntModLConst(l int64, r *Int, mem memory.Allocator) (*Int, error) {
	n := r.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l % r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func IntModRConst(l *Int, r int64, mem memory.Allocator) (*Int, error) {
	n := l.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) % r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func UintMod(l, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(l.Value(i) % r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintModLConst(l uint64, r *Uint, mem memory.Allocator) (*Uint, error) {
	n := r.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(l % r.Value(i))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func UintModRConst(l *Uint, r uint64, mem memory.Allocator) (*Uint, error) {
	n := l.Len()
	b := NewUintBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(l.Value(i) % r)

		} else {
			b.AppendNull()
		}
	}
	a := b.NewUintArray()
	b.Release()
	return a, nil
}

func FloatMod(l, r *Float, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {

			b.Append(math.Mod(l.Value(i), r.Value(i)))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatModLConst(l float64, r *Float, mem memory.Allocator) (*Float, error) {
	n := r.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {

			b.Append(math.Mod(l, r.Value(i)))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatModRConst(l *Float, r float64, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {

			b.Append(math.Mod(l.Value(i), r))

		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func IntPow(l, r *Int, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}

	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(math.Pow(float64(l.Value(i)), float64(r.Value(i))))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func IntPowLConst(l int64, r *Int, mem memory.Allocator) (*Float, error) {
	n := r.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	lf := float64(l)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(math.Pow(lf, float64(r.Value(i))))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func IntPowRConst(l *Int, r int64, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	rf := float64(r)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(math.Pow(float64(l.Value(i)), rf))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func UintPow(l, r *Uint, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}

	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(math.Pow(float64(l.Value(i)), float64(r.Value(i))))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func UintPowLConst(l uint64, r *Uint, mem memory.Allocator) (*Float, error) {
	n := r.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	lf := float64(l)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(math.Pow(lf, float64(r.Value(i))))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func UintPowRConst(l *Uint, r uint64, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	rf := float64(r)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(math.Pow(float64(l.Value(i)), rf))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatPow(l, r *Float, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	if n != r.Len() {
		return nil, errors.Newf(codes.Invalid, "vectors must have equal length for binary operations")
	}

	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if l.IsValid(i) && r.IsValid(i) {
			b.Append(math.Pow(float64(l.Value(i)), float64(r.Value(i))))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatPowLConst(l float64, r *Float, mem memory.Allocator) (*Float, error) {
	n := r.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	lf := float64(l)
	for i := 0; i < n; i++ {
		if r.IsValid(i) {
			b.Append(math.Pow(lf, float64(r.Value(i))))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

func FloatPowRConst(l *Float, r float64, mem memory.Allocator) (*Float, error) {
	n := l.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	rf := float64(r)
	for i := 0; i < n; i++ {
		if l.IsValid(i) {
			b.Append(math.Pow(float64(l.Value(i)), rf))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: unary.gen.go.tmpl

package array

import (
	"github.com/apache/arrow/go/v7/arrow/memory"
)

//
// Arithmetic Ops
//

func IntUnarySub(v *Int, mem memory.Allocator) (*Int, error) {
	n := v.Len()
	b := NewIntBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if v.IsValid(i) {
			b.Append(-v.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewIntArray()
	b.Release()
	return a, nil
}

func FloatUnarySub(v *Float, mem memory.Allocator) (*Float, error) {
	n := v.Len()
	b := NewFloatBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {
		if v.IsValid(i) {
			b.Append(-v.Value(i))
		} else {
			b.AppendNull()
		}
	}
	a := b.NewFloatArray()
	b.Release()
	return a, nil
}

//
// Equality Ops
//

func IntExists(v *Int, mem memory.Allocator) (*Boolean, error) {
	n := v.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {

		b.Append(v.IsValid(i))

	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func UintExists(v *Uint, mem memory.Allocator) (*Boolean, error) {
	n := v.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {

		b.Append(v.IsValid(i))

	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func FloatExists(v *Float, mem memory.Allocator) (*Boolean, error) {
	n := v.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {

		b.Append(v.IsValid(i))

	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func StringExists(v *String, mem memory.Allocator) (*Boolean, error) {
	n := v.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {

		b.Append(v.IsValid(i))

	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func BooleanExists(v *Boolean, mem memory.Allocator) (*Boolean, error) {
	n := v.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {

		b.Append(v.IsValid(i))

	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

func BooleanNot(v *Boolean, mem memory.Allocator) (*Boolean, error) {
	n := v.Len()
	b := NewBooleanBuilder(mem)
	b.Resize(n)
	for i := 0; i < n; i++ {

		if v.IsValid(i) {
			b.Append(!v.Value(i))
		} else {
			b.AppendNull()
		}

	}
	a := b.NewBooleanArray()
	b.Release()
	return a, nil
}

package collections

import (
	"context"
	"encoding/json"

	"github.com/influxdata/flux/codes"
	"github.com/influxdata/flux/compiler"
	"github.com/influxdata/flux/internal/errors"
	"github.com/influxdata/flux/interpreter"
	"github.com/influxdata/flux/runtime"
	"github.com/influxdata/flux/semantic"
	fluxjson "github.com/influxdata/flux/stdlib/json"
	"github.com/influxdata/flux/values"
)

const packagePath = "contrib/bonitoo-io/collections"

// arrayAppend appends value to array.
// A new array is returned, the original is unmodified.
func arrayAppend(args interpreter.Arguments) (values.Value, error) {
	_v, err := args.GetRequired("v")
	if err != nil {
		return nil, err
	}
	v := _v.Array()

	if v.Len() == 0 {
		_arr, err := args.GetRequired("arr")
		if err != nil {
			return nil, err
		}
		return _arr, nil
	}

	elementType, err := v.Type().ElemType()
	if err != nil {
		return nil, err
	}

	arr, err := args.GetRequiredArrayAllowEmpty("arr", elementType.Nature())
	if err != nil {
		return nil, err
	}

	m := arr.Len()
	n := v.Len()
	elements := make([]values.Value, m+n)
	arr.Range(func(i int, v values.Value) {
		elements[i] = v
	})
	v.Range(func(i int, v values.Value) {
		elements[m+i] = v
	})

	return values.NewArrayWithBacking(semantic.NewArrayType(elementType), elements), nil
}

// arrayConvert converts array into a new array using user-supplied value conversion function.
func arrayConvert(args interpreter.Arguments) (values.Value, error) {
	_fn, err := args.GetRequiredFunction("fn")
	if err != nil {
		return nil, err
	}
	fn, err := interpreter.ResolveFunction(_fn)
	if err != nil {
		return nil, err
	}

	_arr, err := args.GetRequired("arr")
	if err != nil {
		return nil, err
	}
	arr := _arr.Array()

	if arr.Len() == 0 {
		return arr, nil
	}

	elementType, err := arr.Type().ElemType()
	if err != nil {
		return nil, err
	}
	f, err := compiler.Compile(compiler.ToScope(fn.Scope), fn.Fn, semantic.NewObjectType([]semantic.PropertyType{
			{Key: []byte("v"), Value: elementType},
		},
	))
	if err != nil {
		return nil, err
	}

	var evalErr error
	elements := make([]values.Value, arr.Len())
	arr.Range(func(i int, v values.Value) {
		tValue, err := f.Eval(context.Background(), values.NewObjectWithValues(map[string]values.Value{
			"v": v,
		}))
		if err != nil {
			evalErr = err
			return
		}
		elements[i] = tValue
	})
	if evalErr != nil {
		return nil, evalErr
	}

	return values.NewArrayWithBacking(semantic.NewArrayType(elements[0].Type()), elements), nil
}

func arrayFromSE(args interpreter.Arguments) (values.Value, error) {
	s, err := args.GetRequiredString("arr")
	if err != nil {
		return nil, err
	}
	if len(s) == 0 {
		s = "[]"
	}

	var arr []interface{}
	err = json.Unmarshal([]byte(s), &arr)
	if err != nil {
		return nil, err
	}

	if len(arr) == 0 {
		return values.NewArray(semantic.NewArrayType(semantic.NewObjectType([]semantic.PropertyType{}))), nil
	}

	elements := make([]values.Value, len(arr))
	for i := 0; i < len(arr); i++ {
		value, err := toValue(arr[i])
		if err != nil {
			return nil, err
		}
		elements[i] = value
	}

	return values.NewArrayWithBacking(semantic.NewArrayType(elements[0].Type()), elements), nil
}

func arrayAppendSE(args interpreter.Arguments) (values.Value, error) {
	_v, err := args.GetRequired("v")
	if err != nil {
		return nil, err
	}
	v := _v.Array()

	if v.Len() == 0 {
		_arr, err := args.GetRequired("arr")
		if err != nil {
			return nil, err
		}
		return _arr, nil
	}

	/*elementType*/_, err = v.Type().ElemType()
	if err != nil {
		return nil, err
	}

	s, err := args.GetRequiredString("arr")
	if err != nil {
		return nil, err
	}
	if len(s) == 0 {
		s = "[]"
	}

	var arr []interface{}
	err = json.Unmarshal([]byte(s), &arr)
	if err != nil {
		return nil, err
	}

	m := len(arr)
	n := v.Len()
	elements := make([]interface{}, m+n)
	for i, v := range arr {
		elements[i] = v
	}
	v.Range(func(i int, v values.Value) {
		native, _err := fluxjson.ConvertValue(v)
		if err != nil {
			err = _err
			return
		}
		elements[m+i] = native
	})

	r, err := json.Marshal(elements)
	if err != nil {
		return nil, err
	}

	return values.NewString(string(r)), nil
}

func toValue(x interface{}) (values.Value, error) {
	value := values.New(x)
	if value == values.InvalidValue {
		switch v := x.(type) {
		case []interface{}:
			elements := make([]values.Value, len(v))
			for i, val := range v {
				fval, err := toValue(val)
				if err != nil {
					return nil, err
				}
				elements[i] = fval
			}
			value = values.NewArrayWithBacking(elements[0].Type(), elements)
		case map[string]interface{}:
			vals := make(map[string]values.Value)
			for key, val := range v {
				fval, err := toValue(val)
				if err != nil {
					return nil, err
				}
				vals[key] = fval
			}
			value = values.NewObjectWithValues(vals)
		case map[interface{}]interface{}:
			var builder *values.DictionaryBuilder
			for k, val := range v {
				fkey, err := toValue(k)
				if err != nil {
					return nil, err
				}
				fval, err := toValue(val)
				if err != nil {
					return nil, err
				}
				if builder == nil {
					b := values.NewDictBuilder(semantic.NewDictType(fkey.Type(), fval.Type()))
					builder = &b
				}
				builder.Insert(fkey, fval)
			}
			value = builder.Dict()
		default:
			return nil, errors.Newf(codes.Unknown, "unsupported type %T", x)
		}
	}
	return value, nil
}

// function is a function definition.
type function func(args interpreter.Arguments) (values.Value, error)

// makeFunction will construct a values.Function from a function definition.
func makeFunction(name string, fn function) values.Function {
	mt := runtime.MustLookupBuiltinType(packagePath, name)
	return values.NewFunction(name, mt, func(ctx context.Context, args values.Object) (values.Value, error) {
		return interpreter.DoFunctionCall(fn, args)
	}, false)
}

// registerFunction will create a function from the function definition
// and register it in this package with the given name.
func registerFunction(name string, fn function) {
	runtime.RegisterPackageValue(packagePath, name, makeFunction(name, fn))
}

func init() {
	registerFunction("append", arrayAppend)
	registerFunction("convert", arrayConvert)
	registerFunction("appendSE", arrayAppendSE)
	registerFunction("fromSE", arrayFromSE)
}

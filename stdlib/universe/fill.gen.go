// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: fill.gen.go.tmpl

package universe

import (
	"fmt"

	"github.com/apache/arrow/go/arrow"
	"github.com/apache/arrow/go/arrow/array"
	"github.com/influxdata/flux"
)

func (t *fillTransformation) fillColumn(typ flux.ColType, arr array.Interface) array.Interface {
	switch typ {
	case flux.TInt:
		return t.fillIntColumn(arr.(*array.Int64))
	case flux.TUInt:
		return t.fillUintColumn(arr.(*array.Uint64))
	case flux.TFloat:
		return t.fillFloatColumn(arr.(*array.Float64))
	case flux.TBool:
		return t.fillBooleanColumn(arr.(*array.Boolean))
	case flux.TString:
		return t.fillStringColumn(arr.(*array.Binary))
	case flux.TTime:
		return t.fillTimeColumn(arr.(*array.Int64))

	default:
		panic(fmt.Errorf("unsupported array data type: %s", arr.DataType()))
	}
}

func (t *fillTransformation) fillIntColumn(arr *array.Int64) array.Interface {
	var prevValue int64
	prevNull := false
	if t.spec.UsePrevious {
		if prevNull = arr.IsNull(0); !prevNull {
			prevValue = arr.Value(0)
		}
	} else {
		prevValue = t.spec.Value.Int()
	}
	b := array.NewInt64Builder(t.alloc)
	b.Resize(arr.Len())
	for i := 0; i < arr.Len(); i++ {
		if arr.IsNull(i) {
			if prevNull {
				b.AppendNull()
			} else {
				b.Append(prevValue)
			}
		} else {
			v := arr.Value(i)
			b.Append(v)
			if t.spec.UsePrevious {
				prevValue = v
				prevNull = false
			}
		}
	}
	return b.NewArray()
}

func (t *fillTransformation) fillUintColumn(arr *array.Uint64) array.Interface {
	var prevValue uint64
	prevNull := false
	if t.spec.UsePrevious {
		if prevNull = arr.IsNull(0); !prevNull {
			prevValue = arr.Value(0)
		}
	} else {
		prevValue = t.spec.Value.UInt()
	}
	b := array.NewUint64Builder(t.alloc)
	b.Resize(arr.Len())
	for i := 0; i < arr.Len(); i++ {
		if arr.IsNull(i) {
			if prevNull {
				b.AppendNull()
			} else {
				b.Append(prevValue)
			}
		} else {
			v := arr.Value(i)
			b.Append(v)
			if t.spec.UsePrevious {
				prevValue = v
				prevNull = false
			}
		}
	}
	return b.NewArray()
}

func (t *fillTransformation) fillFloatColumn(arr *array.Float64) array.Interface {
	var prevValue float64
	prevNull := false
	if t.spec.UsePrevious {
		if prevNull = arr.IsNull(0); !prevNull {
			prevValue = arr.Value(0)
		}
	} else {
		prevValue = t.spec.Value.Float()
	}
	b := array.NewFloat64Builder(t.alloc)
	b.Resize(arr.Len())
	for i := 0; i < arr.Len(); i++ {
		if arr.IsNull(i) {
			if prevNull {
				b.AppendNull()
			} else {
				b.Append(prevValue)
			}
		} else {
			v := arr.Value(i)
			b.Append(v)
			if t.spec.UsePrevious {
				prevValue = v
				prevNull = false
			}
		}
	}
	return b.NewArray()
}

func (t *fillTransformation) fillBooleanColumn(arr *array.Boolean) array.Interface {
	var prevValue bool
	prevNull := false
	if t.spec.UsePrevious {
		if prevNull = arr.IsNull(0); !prevNull {
			prevValue = arr.Value(0)
		}
	} else {
		prevValue = t.spec.Value.Bool()
	}
	b := array.NewBooleanBuilder(t.alloc)
	b.Resize(arr.Len())
	for i := 0; i < arr.Len(); i++ {
		if arr.IsNull(i) {
			if prevNull {
				b.AppendNull()
			} else {
				b.Append(prevValue)
			}
		} else {
			v := arr.Value(i)
			b.Append(v)
			if t.spec.UsePrevious {
				prevValue = v
				prevNull = false
			}
		}
	}
	return b.NewArray()
}

func (t *fillTransformation) fillStringColumn(arr *array.Binary) array.Interface {
	var prevValue string
	prevNull := false
	if t.spec.UsePrevious {
		if prevNull = arr.IsNull(0); !prevNull {
			prevValue = arr.ValueString(0)
		}
	} else {
		prevValue = t.spec.Value.Str()
	}
	b := array.NewBinaryBuilder(t.alloc, arrow.BinaryTypes.String)
	b.Resize(arr.Len())
	for i := 0; i < arr.Len(); i++ {
		if arr.IsNull(i) {
			if prevNull {
				b.AppendNull()
			} else {
				b.AppendString(prevValue)
			}
		} else {
			v := arr.ValueString(i)
			b.AppendString(v)
			if t.spec.UsePrevious {
				prevValue = v
				prevNull = false
			}
		}
	}
	return b.NewArray()
}

func (t *fillTransformation) fillTimeColumn(arr *array.Int64) array.Interface {
	var prevValue int64
	prevNull := false
	if t.spec.UsePrevious {
		if prevNull = arr.IsNull(0); !prevNull {
			prevValue = arr.Value(0)
		}
	} else {
		prevValue = int64(t.spec.Value.Time())
	}
	b := array.NewInt64Builder(t.alloc)
	b.Resize(arr.Len())
	for i := 0; i < arr.Len(); i++ {
		if arr.IsNull(i) {
			if prevNull {
				b.AppendNull()
			} else {
				b.Append(prevValue)
			}
		} else {
			v := arr.Value(i)
			b.Append(v)
			if t.spec.UsePrevious {
				prevValue = v
				prevNull = false
			}
		}
	}
	return b.NewArray()
}

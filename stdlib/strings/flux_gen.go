// DO NOT EDIT: This file is autogenerated via the builtin command.

package strings

import (
	ast "github.com/influxdata/flux/ast"
	runtime "github.com/influxdata/flux/runtime"
)

func init() {
	runtime.RegisterPackage(pkgAST)
}

var pkgAST = &ast.Package{
	BaseNode: ast.BaseNode{
		Comments: nil,
		Errors:   nil,
		Loc:      nil,
	},
	Files: []*ast.File{&ast.File{
		BaseNode: ast.BaseNode{
			Comments: nil,
			Errors:   nil,
			Loc: &ast.SourceLocation{
				End: ast.Position{
					Column: 18,
					Line:   780,
				},
				File:   "strings.flux",
				Source: "package strings\n\n\n// Transformation functions\n//\n// title converts a string to title case.\n//\n// ## Parameters\n//\n// - `V` is the string value to convert.\n//\n// ## Convert all values of a column to title case\n//\n// ```\n//  import \"strings\"\n//\n//  data\n//      |> map(fn: (r) => ({ r with pageTitle: strings.title(v: r.pageTitle) }))\n//\nbuiltin title : (v: string) => string\n\n//\n// toUpper converts a string to uppercase.\n//\n// ## Parameters\n//\n// - `V` is the string value to convert.\n//\n// ## Convert all values of a column to upper case\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({ r with envVars: strings.toUpper(v: r.envVars) }))\n// ```\n//\n// The difference between toTitle and toUpper\n//\n//      - The results of toUpper() and toTitle are often the same, however the difference is visible when using special characters:\n//\n//      - str = \"ǳ\"\n//\n//      - strings.toUpper(v: str) // Returns Ǳ\n//      - strings.toTitle(v: str) // Returns ǲ\n//\nbuiltin toUpper : (v: string) => string\n\n//\n// toLower converts a string to lowercase.\n//\n// ## Parameters\n//\n// - `V` is the string value to convert.\n//\n// ## Convert all values of a column to lower case\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//        r with exclamation: strings.toLower(v: r.exclamation)\n//      })\n//    )\n// ```\n//\nbuiltin toLower : (v: string) => string\n\n//\n// trim removes leading and trailing characters specified in the cutset from a string.\n//\n// ## Parameters\n//\n// - `V` is the string to remove characters from.\n// - `cutset` is the  leading and trailing characters to remove from the string.\n//\n//      Only characters that match the cutset string exactly are trimmed.\n//\n// ## Trim leading and trailing periods from all values in a column\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       variables: strings.trim(v: r.variables, cutset: \".\")\n//     })\n//   )\n//\nbuiltin trim : (v: string, cutset: string) => string\n\n//\n// trimPrefix removes a prefix from a string. Strings that do not start with the prefix are returned unchanged.\n//\n// ## Parameters\n//\n// - `V` is the string to trim\n// - `prefix` is the prefix to remove\n//\n// ## Trim leading and trailing periods from all values in a column\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       sensorID: strings.trimPrefix(v: r.sensorId, prefix: \"s12_\")\n//     })\n//   )\n// ```\n//\nbuiltin trimPrefix : (v: string, prefix: string) => string\n\n//\n// trimSpace removes leading and trailing spaces from a string.\n//\n// ## Parameters\n//\n// - `V` is the string to remove spaces from\n//\n// ## Trim leading and trailing spaces from all values in a column\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({ r with userInput: strings.trimSpace(v: r.userInput) }))\n// ```\nbuiltin trimSpace : (v: string) => string\n\n//\n// The trimSuffix removes a suffix from a string. Strings that do not end with the suffix are returned unchanged.\n//\n// ## Parameters\n//\n// - `V` is the string to trim\n// - `suffix` is the suffix to remove.\n//\n// ## Remove a suffix from all values in a column\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       sensorID: strings.trimSuffix(v: r.sensorId, suffix: \"_s12\")\n//     })\n//   )\n// ```\n//\nbuiltin trimSuffix : (v: string, suffix: string) => string\n\n//\n// trimRight removes trailing characters specified in the cutset from a string.\n//\n// ## Parameters\n//\n// - `V` is the string to to remove characters from\n// - `cutset` is the trailing characters to trim from the string.\n//\n//      Only characters that match the cutset string exactly are trimmed.\n//\n// ## Trim trailing periods from all values in a column\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       variables: strings.trimRight(v: r.variables, cutset: \".\")\n//     })\n//   )\n// ```\n//\nbuiltin trimRight : (v: string, cutset: string) => string\n\n//\n// trimLeft removes specified leading characters from a string.\n//\n// ## Parameters\n//\n// - `V` is the string to to remove characters from\n// - `cutset` is the trailing characters to trim from the string.\n//\n// ## Trim leading periods from all values in a column\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       variables: strings.trimLeft(v: r.variables, cutset: \".\")\n//     })\n//   )\n// ```\n//\nbuiltin trimLeft : (v: string, cutset: string) => string\n\n//\n// toTitle converts all characters in a string to title case.\n//\n// ## Parameters\n//\n// - `V` is the string value to convert.\n//\n// ## Convert characters in a string to title case\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({ r with pageTitle: strings.toTitle(v: r.pageTitle) }))\n// ```\n//\nbuiltin toTitle : (v: string) => string\n\n//\n// hasPrefix indicates if a string begins with a specified prefix.\n//\n// ## Parameters\n//\n// - `V` is the string value to search.\n// - `prefix` is the string prefix to search for.\n//\n// ## Filter based on the presence of a prefix in a column value\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> filter(fn:(r) => strings.hasPrefix(v: r.metric, prefix: \"int_\" ))\n// ```\n//\nbuiltin hasPrefix : (v: string, prefix: string) => bool\n\n//\n// hasSuffix indicates if a string ends with a specified suffix.\n//\n// ## Parameters\n//\n// - `V` is the string value to search.\n// - `prefix` is the string suffix to search for.\n//\n// ## Filter based on the presence of a suffix in a column value\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> filter(fn:(r) => strings.hasSuffix(v: r.metric, suffix: \"_count\" ))\n// ```\n//\nbuiltin hasSuffix : (v: string, suffix: string) => bool\n\n//\n// containsStr reports whether a string contains a specified substring.\n//\n// ## Parameters\n//\n// - `V` is the string value to search\n// - `substr` is the substring value to search for\n//\n// ## Report if a string contains a specific substring\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       _value: strings.containsStr(v: r.author, substr: \"John\")\n//     })\n//   )\n// ```\n//\nbuiltin containsStr : (v: string, substr: string) => bool\n\n//\n// containsAny reports whether a specified string contains characters from another string.\n//\n// ## Parameters\n//\n// - `V` is the string value to search\n// - `chars` is the character to search for\n//\n// ## Report if a string contains specific characters\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       _value: strings.containsAny(v: r.price, chars: \"£$¢\")\n//     })\n//   )\n// ```\n//\nbuiltin containsAny : (v: string, chars: string) => bool\n\n//\n// equalFold reports whether two UTF-8 strings are equal under Unicode case-folding.\n//\n// ## Parameters\n//\n// - `V` is the string value to compare\n// - `t` is the string value to compare against\n//\n// ## Ignore case when testing if two strings are the same\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       string1: r.string1,\n//       string2: r.string2,\n//       same: strings.equalFold(v: r.string1, t: r.string2)\n//     })\n//   )\n// ```\n//\nbuiltin equalFold : (v: string, t: string) => bool\n\n//\n// compare compares the lexicographical order of two strings.\n//\n//      Return values\n//      Comparison\tReturn value\n//      v < t\t    -1\n//      v == t\t    0\n//      v > t\t    1\n//\n// ## Parameters\n//\n// - `V` is the string value to compare\n// - `t` is the string value to compare against\n//\n// ## Compare the lexicographical order of column values\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       _value: strings.compare(v: r.tag1, t: r.tag2)\n//     })\n//   )\n// ```\n//\nbuiltin compare : (v: string, t: string) => int\n\n//\n//countStr counts the number of non-overlapping instances of a substring appears in a string.\n//\n// ## Parameters\n//\n// - `V` is the string value to search\n// - `substr` is the substr value to count\n//\n//      The function counts only non-overlapping instances of substr. For example:\n//      strings.coutnStr(v: \"ooooo\", substr: \"oo\")\n//      // Returns 2 -- (oo)(oo)o\n//\n// ## Count instances of a substring within a string\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//        _value: strings.countStr(v: r.message, substr: \"uh\")\n//     })\n//   )\n// ```\n//\nbuiltin countStr : (v: string, substr: string) => int\n\n//\n// index returns the index of the first instance of a substring in a string. If the substring is not present, it returns -1.\n//\n// ## Parameters\n//\n// - `V` is the string value to search\n// - `substr` is the substring to search for\n//\n// ## Find the first occurrence of a substring\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       the_index: strings.index(v: r.pageTitle, substr: \"the\")\n//     })\n//   )\n// ```\n//\nbuiltin index : (v: string, substr: string) => int\n\n//\n// indexAny returns the index of the first instance of specified characters in a string. If none of the specified characters are present, it returns -1.\n//\n// ## Parameters\n//\n// - `V` is the string value to search\n// - `chars` are the chars to search for\n//\n// ## Find the first occurrence of characters from a string\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       charIndex: strings.indexAny(v: r._field, chars: \"_-\")\n//     })\n//   )\n// ```\n//\nbuiltin indexAny : (v: string, chars: string) => int\n\n//\n// lastIndex returns the index of the last instance of a substring in a string. If the substring is not present, the function returns -1.\n//\n// ## Parameters\n//\n// - `V` is the string value to search\n// - `substr` is the substring to search for\n//\n// ## Find the last occurrence of a substring\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       the_index: strings.lastIndex(v: r.pageTitle, substr: \"the\")\n//     })\n//   )\n// ```\n//\nbuiltin lastIndex : (v: string, substr: string) => int\n\n//\n// lastIndexAny returns the index of the last instance of any specified characters in a string. If none of the specified characters are present, the function returns -1.\n//\n// ## Parameters\n//\n// - `V` is the string value to search\n// - `chars` are the characters to search for\n//\n// ## Find the last occurrence of characters from a string\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       charLastIndex: strings.lastIndexAny(v: r._field, chars: \"_-\")\n//     })\n//   )\n// ```\n//\nbuiltin lastIndexAny : (v: string, chars: string) => int\n\n//\n// isDigit tests if a single-character string is a digit (0-9).\n//\n// ## Parameters\n//\n// - `V` is the single-character string to test.\n//\n// ## Filter by columns with digits as values\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> filter(fn: (r) => strings.isDigit(v: r.serverRef))\n// ```\n//\nbuiltin isDigit : (v: string) => bool\n\n//\n// isLetter tests if a single character string is a letter (a-z, A-Z).\n//\n// ## Parameters\n//\n// - `V` is the single-character string to test.\n//\n// ## Filter by columns with digits as values\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> filter(fn: (r) => strings.isLetter(v: r.serverRef))\n// ```\n//\nbuiltin isLetter : (v: string) => bool\n\n//\n// isLower tests if a single-character string is lowercase.\n//\n// ## Parameters\n//\n// - `V` is the single-character string value to test.\n//\n// ## Filter by columns with single-letter lowercase values\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> filter(fn: (r) => strings.isLower(v: r.host))\n// ```\n//\nbuiltin isLower : (v: string) => bool\n\n//\n// isUpper tests if a single character string is uppercase.\n//\n// ## Parameters\n//\n// - `V` is the single-character string value to test.\n//\n// ## Filter by columns with single-letter uppercase values\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> filter(fn: (r) => strings.isUpper(v: r.host))\n// ```\n//\nbuiltin isUpper : (v: string) => bool\n\n//\n// repeat returns a string consisting of i copies of a specified string.\n//\n// ## Parameters\n//\n// - `V` is the string value to repeat.\n// - `i` is the number of times to repeat v.\n//\n// ## Repeat a string based on existing columns\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       laugh: r.laugh\n//       intensity: r.intensity\n//       laughter: strings.repeat(v: r.laugh, i: r.intensity)\n//     })\n//   )\n// ```\n//\nbuiltin repeat : (v: string, i: int) => string\n\n//\n// replace replaces the first i non-overlapping instances of a substring with a specified replacement.\n//\n// ## Parameters\n//\n// - `V` is the string value to search.\n// - `t` is the substring value to replace.\n// - `u` is the replacement for i instances of t.\n// - `i` is the number of non-overlapping t matches to replace.\n//\n// ## Replace a specific number of string matches\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       content: strings.replace(v: r.content, t: \"he\", u: \"her\", i: 3)\n//     })\n//   )\n// ```\n//\nbuiltin replace : (v: string, t: string, u: string, i: int) => string\n\n//\n// replaceAll replaces all non-overlapping instances of a substring with a specified replacement.\n//\n// ## Parameters\n//\n// - `V` is the string value to search.\n// - `t` is the substring to replace.\n// - `u` is the replacement for all instances of t.\n//\n// ## Replace string matches\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       content: strings.replaceAll(v: r.content, t: \"he\", u: \"her\")\n//     })\n//   )\n// ```\n//\nbuiltin replaceAll : (v: string, t: string, u: string) => string\n\n//\n// split splits a string on a specified separator and returns an array of substrings.\n//\n// ## Parameters\n//\n// - `V` is the string value to split.\n// - `t` is the string value that acts as the separator.\n//\n// ## Split a string into an array of substrings\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map (fn:(r) => strings.split(v: r.searchTags, t: \",\"))\n// ```\n//\nbuiltin split : (v: string, t: string) => [string]\n\n//\n// splitAfter splits a string after a specified separator and returns an array of substrings. Split substrings include the separator, t.\n//\n// ## Parameters\n//\n// - `V` is the string value to split.\n// - `t` is the string value that acts as the separator.\n//\n// ## Split a string into an array of substrings\n//\n// ```\n// import \"strings\"\n//\n// data\n//    |> map (fn:(r) => strings.splitAfter(v: r.searchTags, t: \",\"))\n// ```\n//\nbuiltin splitAfter : (v: string, t: string) => [string]\n\n//\n// splitN splits a string on a specified separator and returns an array of i substrings.\n//\n// ## Parameters\n//\n// - `V` is the string value to split.\n// - `t` is the string value that acts as the separator.\n// - `i` is the maximum number of split substrings to return. -1 returns all matching substrings.\n//\n//       - The last substring is the unsplit remainder.\n//\n// ## Split a string into an array of substrings\n//\n// ```\n// import \"strings\"\n//\n// data\n//    |> map (fn:(r) => strings.splitN(v: r.searchTags, t: \",\"))\n// ```\n//\nbuiltin splitN : (v: string, t: string, n: int) => [string]\n\n//\n// splitAfterN splits a string after a specified separator and returns an array of i substrings. Split substrings include the separator t.\n//\n// ## Parameters\n//\n// - `V` is the string value to split.\n// - `t` is the string value that acts as the separator.\n// - `i` is the maximum number of split substrings to return. -1 returns all matching substrings.\n//\n//       - The last substring is the unsplit remainder.\n//\n// ## Split a string into an array of substrings\n//\n// ```\n// import \"strings\"\n//\n// data\n//    |> map (fn:(r) => strings.splitAfterN(v: r.searchTags, t: \",\"))\n// ```\n//\nbuiltin splitAfterN : (v: string, t: string, i: int) => [string]\n\n//\n// joinStr concatenates elements of a string array into a single string using a specified separator.\n//\n// ## Parameters\n//\n// - `arr` is the array of strings to concatenate.\n// - `t` is the separator to use in the concatenated value.\n//\n// ## Join a list of strings into a single string\n//\n// ```\n// import \"strings\"\n//\n// searchTags = [\"tag1\", \"tag2\", \"tag3\"]\n//\n// strings.joinStr(arr: searchTags, v: \",\"))\n// ```\n//\nbuiltin joinStr : (arr: [string], v: string) => string\n\n//\n// strlen returns the length of a string. String length is determined by the number of UTF code points a string contains.\n//\n// ## Parameters\n//\n// - `V` is the string value to measure.\n//\n// ## Filter based on string value length\n//\n// ```\n// import \"strings\"\n//\n// data\n//    |> filter(fn: (r) => strings.strlen(v: r._measurement) <= 4)\n// ```\n//\n// ## Store the length of string values\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       length: strings.strlen(v: r._value)\n//     })\n//   )\n// ```\n//\nbuiltin strlen : (v: string) => int\n\n//\n// substring returns a substring based on start and end parameters. These parameters are represent indices of UTF code points in the string.\n//\n// ## Parameters\n//\n// - `v` is the string value to search for.\n// - `start` is the starting inclusive index of the substring.\n// - `end` is the ending exclusive index of the substring.\n//\n// ## Store the first four characters of a string\n//\n// ```\n// import \"strings\"\n//\n// data\n//   |> map(fn: (r) => ({\n//       r with\n//       abbr: strings.substring(v: r.name, start: 0, end: 4)\n//     })\n//   )\n// ```\nbuiltin substring",
				Start: ast.Position{
					Column: 1,
					Line:   2,
				},
			},
		},
		Body: []ast.Statement{&ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "// Transformation functions\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// title converts a string to title case.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to convert.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Convert all values of a column to title case\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//  import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "//  data\n"}, ast.Comment{Text: "//      |> map(fn: (r) => ({ r with pageTitle: strings.title(v: r.pageTitle) }))\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 14,
						Line:   21,
					},
					File:   "strings.flux",
					Source: "builtin title",
					Start: ast.Position{
						Column: 1,
						Line:   21,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 14,
							Line:   21,
						},
						File:   "strings.flux",
						Source: "title",
						Start: ast.Position{
							Column: 9,
							Line:   21,
						},
					},
				},
				Name: "title",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 38,
							Line:   21,
						},
						File:   "strings.flux",
						Source: "(v: string) => string",
						Start: ast.Position{
							Column: 17,
							Line:   21,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 38,
								Line:   21,
							},
							File:   "strings.flux",
							Source: "(v: string) => string",
							Start: ast.Position{
								Column: 17,
								Line:   21,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 27,
									Line:   21,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 18,
									Line:   21,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 19,
										Line:   21,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 18,
										Line:   21,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 27,
										Line:   21,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 21,
										Line:   21,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 27,
											Line:   21,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 21,
											Line:   21,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 38,
									Line:   21,
								},
								File:   "strings.flux",
								Source: "string",
								Start: ast.Position{
									Column: 32,
									Line:   21,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 38,
										Line:   21,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 32,
										Line:   21,
									},
								},
							},
							Name: "string",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// toUpper converts a string to uppercase.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to convert.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Convert all values of a column to upper case\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({ r with envVars: strings.toUpper(v: r.envVars) }))\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// The difference between toTitle and toUpper\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "//      - The results of toUpper() and toTitle are often the same, however the difference is visible when using special characters:\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "//      - str = \"ǳ\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "//      - strings.toUpper(v: str) // Returns Ǳ\n"}, ast.Comment{Text: "//      - strings.toTitle(v: str) // Returns ǲ\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 16,
						Line:   48,
					},
					File:   "strings.flux",
					Source: "builtin toUpper",
					Start: ast.Position{
						Column: 1,
						Line:   48,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 16,
							Line:   48,
						},
						File:   "strings.flux",
						Source: "toUpper",
						Start: ast.Position{
							Column: 9,
							Line:   48,
						},
					},
				},
				Name: "toUpper",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 40,
							Line:   48,
						},
						File:   "strings.flux",
						Source: "(v: string) => string",
						Start: ast.Position{
							Column: 19,
							Line:   48,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 40,
								Line:   48,
							},
							File:   "strings.flux",
							Source: "(v: string) => string",
							Start: ast.Position{
								Column: 19,
								Line:   48,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 29,
									Line:   48,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 20,
									Line:   48,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 21,
										Line:   48,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 20,
										Line:   48,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 29,
										Line:   48,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 23,
										Line:   48,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 29,
											Line:   48,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 23,
											Line:   48,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 40,
									Line:   48,
								},
								File:   "strings.flux",
								Source: "string",
								Start: ast.Position{
									Column: 34,
									Line:   48,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 40,
										Line:   48,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 34,
										Line:   48,
									},
								},
							},
							Name: "string",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// toLower converts a string to lowercase.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to convert.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Convert all values of a column to lower case\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//        r with exclamation: strings.toLower(v: r.exclamation)\n"}, ast.Comment{Text: "//      })\n"}, ast.Comment{Text: "//    )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 16,
						Line:   69,
					},
					File:   "strings.flux",
					Source: "builtin toLower",
					Start: ast.Position{
						Column: 1,
						Line:   69,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 16,
							Line:   69,
						},
						File:   "strings.flux",
						Source: "toLower",
						Start: ast.Position{
							Column: 9,
							Line:   69,
						},
					},
				},
				Name: "toLower",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 40,
							Line:   69,
						},
						File:   "strings.flux",
						Source: "(v: string) => string",
						Start: ast.Position{
							Column: 19,
							Line:   69,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 40,
								Line:   69,
							},
							File:   "strings.flux",
							Source: "(v: string) => string",
							Start: ast.Position{
								Column: 19,
								Line:   69,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 29,
									Line:   69,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 20,
									Line:   69,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 21,
										Line:   69,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 20,
										Line:   69,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 29,
										Line:   69,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 23,
										Line:   69,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 29,
											Line:   69,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 23,
											Line:   69,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 40,
									Line:   69,
								},
								File:   "strings.flux",
								Source: "string",
								Start: ast.Position{
									Column: 34,
									Line:   69,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 40,
										Line:   69,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 34,
										Line:   69,
									},
								},
							},
							Name: "string",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// trim removes leading and trailing characters specified in the cutset from a string.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string to remove characters from.\n"}, ast.Comment{Text: "// - `cutset` is the  leading and trailing characters to remove from the string.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "//      Only characters that match the cutset string exactly are trimmed.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Trim leading and trailing periods from all values in a column\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       variables: strings.trim(v: r.variables, cutset: \".\")\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 13,
						Line:   93,
					},
					File:   "strings.flux",
					Source: "builtin trim",
					Start: ast.Position{
						Column: 1,
						Line:   93,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 13,
							Line:   93,
						},
						File:   "strings.flux",
						Source: "trim",
						Start: ast.Position{
							Column: 9,
							Line:   93,
						},
					},
				},
				Name: "trim",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 53,
							Line:   93,
						},
						File:   "strings.flux",
						Source: "(v: string, cutset: string) => string",
						Start: ast.Position{
							Column: 16,
							Line:   93,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 53,
								Line:   93,
							},
							File:   "strings.flux",
							Source: "(v: string, cutset: string) => string",
							Start: ast.Position{
								Column: 16,
								Line:   93,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 26,
									Line:   93,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 17,
									Line:   93,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 18,
										Line:   93,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 17,
										Line:   93,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 26,
										Line:   93,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 20,
										Line:   93,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 26,
											Line:   93,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 20,
											Line:   93,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 42,
									Line:   93,
								},
								File:   "strings.flux",
								Source: "cutset: string",
								Start: ast.Position{
									Column: 28,
									Line:   93,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 34,
										Line:   93,
									},
									File:   "strings.flux",
									Source: "cutset",
									Start: ast.Position{
										Column: 28,
										Line:   93,
									},
								},
							},
							Name: "cutset",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 42,
										Line:   93,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 36,
										Line:   93,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 42,
											Line:   93,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 36,
											Line:   93,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 53,
									Line:   93,
								},
								File:   "strings.flux",
								Source: "string",
								Start: ast.Position{
									Column: 47,
									Line:   93,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 53,
										Line:   93,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 47,
										Line:   93,
									},
								},
							},
							Name: "string",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// trimPrefix removes a prefix from a string. Strings that do not start with the prefix are returned unchanged.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string to trim\n"}, ast.Comment{Text: "// - `prefix` is the prefix to remove\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Trim leading and trailing periods from all values in a column\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       sensorID: strings.trimPrefix(v: r.sensorId, prefix: \"s12_\")\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 19,
						Line:   116,
					},
					File:   "strings.flux",
					Source: "builtin trimPrefix",
					Start: ast.Position{
						Column: 1,
						Line:   116,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 19,
							Line:   116,
						},
						File:   "strings.flux",
						Source: "trimPrefix",
						Start: ast.Position{
							Column: 9,
							Line:   116,
						},
					},
				},
				Name: "trimPrefix",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 59,
							Line:   116,
						},
						File:   "strings.flux",
						Source: "(v: string, prefix: string) => string",
						Start: ast.Position{
							Column: 22,
							Line:   116,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 59,
								Line:   116,
							},
							File:   "strings.flux",
							Source: "(v: string, prefix: string) => string",
							Start: ast.Position{
								Column: 22,
								Line:   116,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 32,
									Line:   116,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 23,
									Line:   116,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 24,
										Line:   116,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 23,
										Line:   116,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 32,
										Line:   116,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 26,
										Line:   116,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 32,
											Line:   116,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 26,
											Line:   116,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 48,
									Line:   116,
								},
								File:   "strings.flux",
								Source: "prefix: string",
								Start: ast.Position{
									Column: 34,
									Line:   116,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 40,
										Line:   116,
									},
									File:   "strings.flux",
									Source: "prefix",
									Start: ast.Position{
										Column: 34,
										Line:   116,
									},
								},
							},
							Name: "prefix",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 48,
										Line:   116,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 42,
										Line:   116,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 48,
											Line:   116,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 42,
											Line:   116,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 59,
									Line:   116,
								},
								File:   "strings.flux",
								Source: "string",
								Start: ast.Position{
									Column: 53,
									Line:   116,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 59,
										Line:   116,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 53,
										Line:   116,
									},
								},
							},
							Name: "string",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// trimSpace removes leading and trailing spaces from a string.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string to remove spaces from\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Trim leading and trailing spaces from all values in a column\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({ r with userInput: strings.trimSpace(v: r.userInput) }))\n"}, ast.Comment{Text: "// ```\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 18,
						Line:   133,
					},
					File:   "strings.flux",
					Source: "builtin trimSpace",
					Start: ast.Position{
						Column: 1,
						Line:   133,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 18,
							Line:   133,
						},
						File:   "strings.flux",
						Source: "trimSpace",
						Start: ast.Position{
							Column: 9,
							Line:   133,
						},
					},
				},
				Name: "trimSpace",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 42,
							Line:   133,
						},
						File:   "strings.flux",
						Source: "(v: string) => string",
						Start: ast.Position{
							Column: 21,
							Line:   133,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 42,
								Line:   133,
							},
							File:   "strings.flux",
							Source: "(v: string) => string",
							Start: ast.Position{
								Column: 21,
								Line:   133,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 31,
									Line:   133,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 22,
									Line:   133,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 23,
										Line:   133,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 22,
										Line:   133,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 31,
										Line:   133,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 25,
										Line:   133,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 31,
											Line:   133,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 25,
											Line:   133,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 42,
									Line:   133,
								},
								File:   "strings.flux",
								Source: "string",
								Start: ast.Position{
									Column: 36,
									Line:   133,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 42,
										Line:   133,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 36,
										Line:   133,
									},
								},
							},
							Name: "string",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// The trimSuffix removes a suffix from a string. Strings that do not end with the suffix are returned unchanged.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string to trim\n"}, ast.Comment{Text: "// - `suffix` is the suffix to remove.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Remove a suffix from all values in a column\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       sensorID: strings.trimSuffix(v: r.sensorId, suffix: \"_s12\")\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 19,
						Line:   156,
					},
					File:   "strings.flux",
					Source: "builtin trimSuffix",
					Start: ast.Position{
						Column: 1,
						Line:   156,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 19,
							Line:   156,
						},
						File:   "strings.flux",
						Source: "trimSuffix",
						Start: ast.Position{
							Column: 9,
							Line:   156,
						},
					},
				},
				Name: "trimSuffix",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 59,
							Line:   156,
						},
						File:   "strings.flux",
						Source: "(v: string, suffix: string) => string",
						Start: ast.Position{
							Column: 22,
							Line:   156,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 59,
								Line:   156,
							},
							File:   "strings.flux",
							Source: "(v: string, suffix: string) => string",
							Start: ast.Position{
								Column: 22,
								Line:   156,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 32,
									Line:   156,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 23,
									Line:   156,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 24,
										Line:   156,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 23,
										Line:   156,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 32,
										Line:   156,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 26,
										Line:   156,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 32,
											Line:   156,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 26,
											Line:   156,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 48,
									Line:   156,
								},
								File:   "strings.flux",
								Source: "suffix: string",
								Start: ast.Position{
									Column: 34,
									Line:   156,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 40,
										Line:   156,
									},
									File:   "strings.flux",
									Source: "suffix",
									Start: ast.Position{
										Column: 34,
										Line:   156,
									},
								},
							},
							Name: "suffix",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 48,
										Line:   156,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 42,
										Line:   156,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 48,
											Line:   156,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 42,
											Line:   156,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 59,
									Line:   156,
								},
								File:   "strings.flux",
								Source: "string",
								Start: ast.Position{
									Column: 53,
									Line:   156,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 59,
										Line:   156,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 53,
										Line:   156,
									},
								},
							},
							Name: "string",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// trimRight removes trailing characters specified in the cutset from a string.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string to to remove characters from\n"}, ast.Comment{Text: "// - `cutset` is the trailing characters to trim from the string.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "//      Only characters that match the cutset string exactly are trimmed.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Trim trailing periods from all values in a column\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       variables: strings.trimRight(v: r.variables, cutset: \".\")\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 18,
						Line:   181,
					},
					File:   "strings.flux",
					Source: "builtin trimRight",
					Start: ast.Position{
						Column: 1,
						Line:   181,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 18,
							Line:   181,
						},
						File:   "strings.flux",
						Source: "trimRight",
						Start: ast.Position{
							Column: 9,
							Line:   181,
						},
					},
				},
				Name: "trimRight",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 58,
							Line:   181,
						},
						File:   "strings.flux",
						Source: "(v: string, cutset: string) => string",
						Start: ast.Position{
							Column: 21,
							Line:   181,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 58,
								Line:   181,
							},
							File:   "strings.flux",
							Source: "(v: string, cutset: string) => string",
							Start: ast.Position{
								Column: 21,
								Line:   181,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 31,
									Line:   181,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 22,
									Line:   181,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 23,
										Line:   181,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 22,
										Line:   181,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 31,
										Line:   181,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 25,
										Line:   181,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 31,
											Line:   181,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 25,
											Line:   181,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 47,
									Line:   181,
								},
								File:   "strings.flux",
								Source: "cutset: string",
								Start: ast.Position{
									Column: 33,
									Line:   181,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 39,
										Line:   181,
									},
									File:   "strings.flux",
									Source: "cutset",
									Start: ast.Position{
										Column: 33,
										Line:   181,
									},
								},
							},
							Name: "cutset",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 47,
										Line:   181,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 41,
										Line:   181,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 47,
											Line:   181,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 41,
											Line:   181,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 58,
									Line:   181,
								},
								File:   "strings.flux",
								Source: "string",
								Start: ast.Position{
									Column: 52,
									Line:   181,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 58,
										Line:   181,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 52,
										Line:   181,
									},
								},
							},
							Name: "string",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// trimLeft removes specified leading characters from a string.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string to to remove characters from\n"}, ast.Comment{Text: "// - `cutset` is the trailing characters to trim from the string.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Trim leading periods from all values in a column\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       variables: strings.trimLeft(v: r.variables, cutset: \".\")\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 17,
						Line:   204,
					},
					File:   "strings.flux",
					Source: "builtin trimLeft",
					Start: ast.Position{
						Column: 1,
						Line:   204,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 17,
							Line:   204,
						},
						File:   "strings.flux",
						Source: "trimLeft",
						Start: ast.Position{
							Column: 9,
							Line:   204,
						},
					},
				},
				Name: "trimLeft",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 57,
							Line:   204,
						},
						File:   "strings.flux",
						Source: "(v: string, cutset: string) => string",
						Start: ast.Position{
							Column: 20,
							Line:   204,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 57,
								Line:   204,
							},
							File:   "strings.flux",
							Source: "(v: string, cutset: string) => string",
							Start: ast.Position{
								Column: 20,
								Line:   204,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 30,
									Line:   204,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 21,
									Line:   204,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 22,
										Line:   204,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 21,
										Line:   204,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 30,
										Line:   204,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 24,
										Line:   204,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 30,
											Line:   204,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 24,
											Line:   204,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 46,
									Line:   204,
								},
								File:   "strings.flux",
								Source: "cutset: string",
								Start: ast.Position{
									Column: 32,
									Line:   204,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 38,
										Line:   204,
									},
									File:   "strings.flux",
									Source: "cutset",
									Start: ast.Position{
										Column: 32,
										Line:   204,
									},
								},
							},
							Name: "cutset",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 46,
										Line:   204,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 40,
										Line:   204,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 46,
											Line:   204,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 40,
											Line:   204,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 57,
									Line:   204,
								},
								File:   "strings.flux",
								Source: "string",
								Start: ast.Position{
									Column: 51,
									Line:   204,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 57,
										Line:   204,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 51,
										Line:   204,
									},
								},
							},
							Name: "string",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// toTitle converts all characters in a string to title case.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to convert.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Convert characters in a string to title case\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({ r with pageTitle: strings.toTitle(v: r.pageTitle) }))\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 16,
						Line:   222,
					},
					File:   "strings.flux",
					Source: "builtin toTitle",
					Start: ast.Position{
						Column: 1,
						Line:   222,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 16,
							Line:   222,
						},
						File:   "strings.flux",
						Source: "toTitle",
						Start: ast.Position{
							Column: 9,
							Line:   222,
						},
					},
				},
				Name: "toTitle",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 40,
							Line:   222,
						},
						File:   "strings.flux",
						Source: "(v: string) => string",
						Start: ast.Position{
							Column: 19,
							Line:   222,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 40,
								Line:   222,
							},
							File:   "strings.flux",
							Source: "(v: string) => string",
							Start: ast.Position{
								Column: 19,
								Line:   222,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 29,
									Line:   222,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 20,
									Line:   222,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 21,
										Line:   222,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 20,
										Line:   222,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 29,
										Line:   222,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 23,
										Line:   222,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 29,
											Line:   222,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 23,
											Line:   222,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 40,
									Line:   222,
								},
								File:   "strings.flux",
								Source: "string",
								Start: ast.Position{
									Column: 34,
									Line:   222,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 40,
										Line:   222,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 34,
										Line:   222,
									},
								},
							},
							Name: "string",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// hasPrefix indicates if a string begins with a specified prefix.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to search.\n"}, ast.Comment{Text: "// - `prefix` is the string prefix to search for.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Filter based on the presence of a prefix in a column value\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> filter(fn:(r) => strings.hasPrefix(v: r.metric, prefix: \"int_\" ))\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 18,
						Line:   241,
					},
					File:   "strings.flux",
					Source: "builtin hasPrefix",
					Start: ast.Position{
						Column: 1,
						Line:   241,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 18,
							Line:   241,
						},
						File:   "strings.flux",
						Source: "hasPrefix",
						Start: ast.Position{
							Column: 9,
							Line:   241,
						},
					},
				},
				Name: "hasPrefix",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 56,
							Line:   241,
						},
						File:   "strings.flux",
						Source: "(v: string, prefix: string) => bool",
						Start: ast.Position{
							Column: 21,
							Line:   241,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 56,
								Line:   241,
							},
							File:   "strings.flux",
							Source: "(v: string, prefix: string) => bool",
							Start: ast.Position{
								Column: 21,
								Line:   241,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 31,
									Line:   241,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 22,
									Line:   241,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 23,
										Line:   241,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 22,
										Line:   241,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 31,
										Line:   241,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 25,
										Line:   241,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 31,
											Line:   241,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 25,
											Line:   241,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 47,
									Line:   241,
								},
								File:   "strings.flux",
								Source: "prefix: string",
								Start: ast.Position{
									Column: 33,
									Line:   241,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 39,
										Line:   241,
									},
									File:   "strings.flux",
									Source: "prefix",
									Start: ast.Position{
										Column: 33,
										Line:   241,
									},
								},
							},
							Name: "prefix",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 47,
										Line:   241,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 41,
										Line:   241,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 47,
											Line:   241,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 41,
											Line:   241,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 56,
									Line:   241,
								},
								File:   "strings.flux",
								Source: "bool",
								Start: ast.Position{
									Column: 52,
									Line:   241,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 56,
										Line:   241,
									},
									File:   "strings.flux",
									Source: "bool",
									Start: ast.Position{
										Column: 52,
										Line:   241,
									},
								},
							},
							Name: "bool",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// hasSuffix indicates if a string ends with a specified suffix.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to search.\n"}, ast.Comment{Text: "// - `prefix` is the string suffix to search for.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Filter based on the presence of a suffix in a column value\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> filter(fn:(r) => strings.hasSuffix(v: r.metric, suffix: \"_count\" ))\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 18,
						Line:   260,
					},
					File:   "strings.flux",
					Source: "builtin hasSuffix",
					Start: ast.Position{
						Column: 1,
						Line:   260,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 18,
							Line:   260,
						},
						File:   "strings.flux",
						Source: "hasSuffix",
						Start: ast.Position{
							Column: 9,
							Line:   260,
						},
					},
				},
				Name: "hasSuffix",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 56,
							Line:   260,
						},
						File:   "strings.flux",
						Source: "(v: string, suffix: string) => bool",
						Start: ast.Position{
							Column: 21,
							Line:   260,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 56,
								Line:   260,
							},
							File:   "strings.flux",
							Source: "(v: string, suffix: string) => bool",
							Start: ast.Position{
								Column: 21,
								Line:   260,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 31,
									Line:   260,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 22,
									Line:   260,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 23,
										Line:   260,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 22,
										Line:   260,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 31,
										Line:   260,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 25,
										Line:   260,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 31,
											Line:   260,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 25,
											Line:   260,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 47,
									Line:   260,
								},
								File:   "strings.flux",
								Source: "suffix: string",
								Start: ast.Position{
									Column: 33,
									Line:   260,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 39,
										Line:   260,
									},
									File:   "strings.flux",
									Source: "suffix",
									Start: ast.Position{
										Column: 33,
										Line:   260,
									},
								},
							},
							Name: "suffix",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 47,
										Line:   260,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 41,
										Line:   260,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 47,
											Line:   260,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 41,
											Line:   260,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 56,
									Line:   260,
								},
								File:   "strings.flux",
								Source: "bool",
								Start: ast.Position{
									Column: 52,
									Line:   260,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 56,
										Line:   260,
									},
									File:   "strings.flux",
									Source: "bool",
									Start: ast.Position{
										Column: 52,
										Line:   260,
									},
								},
							},
							Name: "bool",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// containsStr reports whether a string contains a specified substring.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to search\n"}, ast.Comment{Text: "// - `substr` is the substring value to search for\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Report if a string contains a specific substring\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       _value: strings.containsStr(v: r.author, substr: \"John\")\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 20,
						Line:   283,
					},
					File:   "strings.flux",
					Source: "builtin containsStr",
					Start: ast.Position{
						Column: 1,
						Line:   283,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 20,
							Line:   283,
						},
						File:   "strings.flux",
						Source: "containsStr",
						Start: ast.Position{
							Column: 9,
							Line:   283,
						},
					},
				},
				Name: "containsStr",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 58,
							Line:   283,
						},
						File:   "strings.flux",
						Source: "(v: string, substr: string) => bool",
						Start: ast.Position{
							Column: 23,
							Line:   283,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 58,
								Line:   283,
							},
							File:   "strings.flux",
							Source: "(v: string, substr: string) => bool",
							Start: ast.Position{
								Column: 23,
								Line:   283,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 33,
									Line:   283,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 24,
									Line:   283,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 25,
										Line:   283,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 24,
										Line:   283,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 33,
										Line:   283,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 27,
										Line:   283,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 33,
											Line:   283,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 27,
											Line:   283,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 49,
									Line:   283,
								},
								File:   "strings.flux",
								Source: "substr: string",
								Start: ast.Position{
									Column: 35,
									Line:   283,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 41,
										Line:   283,
									},
									File:   "strings.flux",
									Source: "substr",
									Start: ast.Position{
										Column: 35,
										Line:   283,
									},
								},
							},
							Name: "substr",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 49,
										Line:   283,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 43,
										Line:   283,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 49,
											Line:   283,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 43,
											Line:   283,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 58,
									Line:   283,
								},
								File:   "strings.flux",
								Source: "bool",
								Start: ast.Position{
									Column: 54,
									Line:   283,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 58,
										Line:   283,
									},
									File:   "strings.flux",
									Source: "bool",
									Start: ast.Position{
										Column: 54,
										Line:   283,
									},
								},
							},
							Name: "bool",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// containsAny reports whether a specified string contains characters from another string.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to search\n"}, ast.Comment{Text: "// - `chars` is the character to search for\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Report if a string contains specific characters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       _value: strings.containsAny(v: r.price, chars: \"£$¢\")\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 20,
						Line:   306,
					},
					File:   "strings.flux",
					Source: "builtin containsAny",
					Start: ast.Position{
						Column: 1,
						Line:   306,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 20,
							Line:   306,
						},
						File:   "strings.flux",
						Source: "containsAny",
						Start: ast.Position{
							Column: 9,
							Line:   306,
						},
					},
				},
				Name: "containsAny",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 57,
							Line:   306,
						},
						File:   "strings.flux",
						Source: "(v: string, chars: string) => bool",
						Start: ast.Position{
							Column: 23,
							Line:   306,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 57,
								Line:   306,
							},
							File:   "strings.flux",
							Source: "(v: string, chars: string) => bool",
							Start: ast.Position{
								Column: 23,
								Line:   306,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 33,
									Line:   306,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 24,
									Line:   306,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 25,
										Line:   306,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 24,
										Line:   306,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 33,
										Line:   306,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 27,
										Line:   306,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 33,
											Line:   306,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 27,
											Line:   306,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 48,
									Line:   306,
								},
								File:   "strings.flux",
								Source: "chars: string",
								Start: ast.Position{
									Column: 35,
									Line:   306,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 40,
										Line:   306,
									},
									File:   "strings.flux",
									Source: "chars",
									Start: ast.Position{
										Column: 35,
										Line:   306,
									},
								},
							},
							Name: "chars",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 48,
										Line:   306,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 42,
										Line:   306,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 48,
											Line:   306,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 42,
											Line:   306,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 57,
									Line:   306,
								},
								File:   "strings.flux",
								Source: "bool",
								Start: ast.Position{
									Column: 53,
									Line:   306,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 57,
										Line:   306,
									},
									File:   "strings.flux",
									Source: "bool",
									Start: ast.Position{
										Column: 53,
										Line:   306,
									},
								},
							},
							Name: "bool",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// equalFold reports whether two UTF-8 strings are equal under Unicode case-folding.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to compare\n"}, ast.Comment{Text: "// - `t` is the string value to compare against\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Ignore case when testing if two strings are the same\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       string1: r.string1,\n"}, ast.Comment{Text: "//       string2: r.string2,\n"}, ast.Comment{Text: "//       same: strings.equalFold(v: r.string1, t: r.string2)\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 18,
						Line:   331,
					},
					File:   "strings.flux",
					Source: "builtin equalFold",
					Start: ast.Position{
						Column: 1,
						Line:   331,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 18,
							Line:   331,
						},
						File:   "strings.flux",
						Source: "equalFold",
						Start: ast.Position{
							Column: 9,
							Line:   331,
						},
					},
				},
				Name: "equalFold",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 51,
							Line:   331,
						},
						File:   "strings.flux",
						Source: "(v: string, t: string) => bool",
						Start: ast.Position{
							Column: 21,
							Line:   331,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 51,
								Line:   331,
							},
							File:   "strings.flux",
							Source: "(v: string, t: string) => bool",
							Start: ast.Position{
								Column: 21,
								Line:   331,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 31,
									Line:   331,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 22,
									Line:   331,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 23,
										Line:   331,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 22,
										Line:   331,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 31,
										Line:   331,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 25,
										Line:   331,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 31,
											Line:   331,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 25,
											Line:   331,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 42,
									Line:   331,
								},
								File:   "strings.flux",
								Source: "t: string",
								Start: ast.Position{
									Column: 33,
									Line:   331,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 34,
										Line:   331,
									},
									File:   "strings.flux",
									Source: "t",
									Start: ast.Position{
										Column: 33,
										Line:   331,
									},
								},
							},
							Name: "t",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 42,
										Line:   331,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 36,
										Line:   331,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 42,
											Line:   331,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 36,
											Line:   331,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 51,
									Line:   331,
								},
								File:   "strings.flux",
								Source: "bool",
								Start: ast.Position{
									Column: 47,
									Line:   331,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 51,
										Line:   331,
									},
									File:   "strings.flux",
									Source: "bool",
									Start: ast.Position{
										Column: 47,
										Line:   331,
									},
								},
							},
							Name: "bool",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// compare compares the lexicographical order of two strings.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "//      Return values\n"}, ast.Comment{Text: "//      Comparison\tReturn value\n"}, ast.Comment{Text: "//      v < t\t    -1\n"}, ast.Comment{Text: "//      v == t\t    0\n"}, ast.Comment{Text: "//      v > t\t    1\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to compare\n"}, ast.Comment{Text: "// - `t` is the string value to compare against\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Compare the lexicographical order of column values\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       _value: strings.compare(v: r.tag1, t: r.tag2)\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 16,
						Line:   360,
					},
					File:   "strings.flux",
					Source: "builtin compare",
					Start: ast.Position{
						Column: 1,
						Line:   360,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 16,
							Line:   360,
						},
						File:   "strings.flux",
						Source: "compare",
						Start: ast.Position{
							Column: 9,
							Line:   360,
						},
					},
				},
				Name: "compare",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 48,
							Line:   360,
						},
						File:   "strings.flux",
						Source: "(v: string, t: string) => int",
						Start: ast.Position{
							Column: 19,
							Line:   360,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 48,
								Line:   360,
							},
							File:   "strings.flux",
							Source: "(v: string, t: string) => int",
							Start: ast.Position{
								Column: 19,
								Line:   360,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 29,
									Line:   360,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 20,
									Line:   360,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 21,
										Line:   360,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 20,
										Line:   360,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 29,
										Line:   360,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 23,
										Line:   360,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 29,
											Line:   360,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 23,
											Line:   360,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 40,
									Line:   360,
								},
								File:   "strings.flux",
								Source: "t: string",
								Start: ast.Position{
									Column: 31,
									Line:   360,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 32,
										Line:   360,
									},
									File:   "strings.flux",
									Source: "t",
									Start: ast.Position{
										Column: 31,
										Line:   360,
									},
								},
							},
							Name: "t",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 40,
										Line:   360,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 34,
										Line:   360,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 40,
											Line:   360,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 34,
											Line:   360,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 48,
									Line:   360,
								},
								File:   "strings.flux",
								Source: "int",
								Start: ast.Position{
									Column: 45,
									Line:   360,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 48,
										Line:   360,
									},
									File:   "strings.flux",
									Source: "int",
									Start: ast.Position{
										Column: 45,
										Line:   360,
									},
								},
							},
							Name: "int",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "//countStr counts the number of non-overlapping instances of a substring appears in a string.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to search\n"}, ast.Comment{Text: "// - `substr` is the substr value to count\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "//      The function counts only non-overlapping instances of substr. For example:\n"}, ast.Comment{Text: "//      strings.coutnStr(v: \"ooooo\", substr: \"oo\")\n"}, ast.Comment{Text: "//      // Returns 2 -- (oo)(oo)o\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Count instances of a substring within a string\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//        _value: strings.countStr(v: r.message, substr: \"uh\")\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 17,
						Line:   387,
					},
					File:   "strings.flux",
					Source: "builtin countStr",
					Start: ast.Position{
						Column: 1,
						Line:   387,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 17,
							Line:   387,
						},
						File:   "strings.flux",
						Source: "countStr",
						Start: ast.Position{
							Column: 9,
							Line:   387,
						},
					},
				},
				Name: "countStr",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 54,
							Line:   387,
						},
						File:   "strings.flux",
						Source: "(v: string, substr: string) => int",
						Start: ast.Position{
							Column: 20,
							Line:   387,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 54,
								Line:   387,
							},
							File:   "strings.flux",
							Source: "(v: string, substr: string) => int",
							Start: ast.Position{
								Column: 20,
								Line:   387,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 30,
									Line:   387,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 21,
									Line:   387,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 22,
										Line:   387,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 21,
										Line:   387,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 30,
										Line:   387,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 24,
										Line:   387,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 30,
											Line:   387,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 24,
											Line:   387,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 46,
									Line:   387,
								},
								File:   "strings.flux",
								Source: "substr: string",
								Start: ast.Position{
									Column: 32,
									Line:   387,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 38,
										Line:   387,
									},
									File:   "strings.flux",
									Source: "substr",
									Start: ast.Position{
										Column: 32,
										Line:   387,
									},
								},
							},
							Name: "substr",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 46,
										Line:   387,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 40,
										Line:   387,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 46,
											Line:   387,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 40,
											Line:   387,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 54,
									Line:   387,
								},
								File:   "strings.flux",
								Source: "int",
								Start: ast.Position{
									Column: 51,
									Line:   387,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 54,
										Line:   387,
									},
									File:   "strings.flux",
									Source: "int",
									Start: ast.Position{
										Column: 51,
										Line:   387,
									},
								},
							},
							Name: "int",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// index returns the index of the first instance of a substring in a string. If the substring is not present, it returns -1.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to search\n"}, ast.Comment{Text: "// - `substr` is the substring to search for\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Find the first occurrence of a substring\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       the_index: strings.index(v: r.pageTitle, substr: \"the\")\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 14,
						Line:   410,
					},
					File:   "strings.flux",
					Source: "builtin index",
					Start: ast.Position{
						Column: 1,
						Line:   410,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 14,
							Line:   410,
						},
						File:   "strings.flux",
						Source: "index",
						Start: ast.Position{
							Column: 9,
							Line:   410,
						},
					},
				},
				Name: "index",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 51,
							Line:   410,
						},
						File:   "strings.flux",
						Source: "(v: string, substr: string) => int",
						Start: ast.Position{
							Column: 17,
							Line:   410,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 51,
								Line:   410,
							},
							File:   "strings.flux",
							Source: "(v: string, substr: string) => int",
							Start: ast.Position{
								Column: 17,
								Line:   410,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 27,
									Line:   410,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 18,
									Line:   410,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 19,
										Line:   410,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 18,
										Line:   410,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 27,
										Line:   410,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 21,
										Line:   410,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 27,
											Line:   410,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 21,
											Line:   410,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 43,
									Line:   410,
								},
								File:   "strings.flux",
								Source: "substr: string",
								Start: ast.Position{
									Column: 29,
									Line:   410,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 35,
										Line:   410,
									},
									File:   "strings.flux",
									Source: "substr",
									Start: ast.Position{
										Column: 29,
										Line:   410,
									},
								},
							},
							Name: "substr",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 43,
										Line:   410,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 37,
										Line:   410,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 43,
											Line:   410,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 37,
											Line:   410,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 51,
									Line:   410,
								},
								File:   "strings.flux",
								Source: "int",
								Start: ast.Position{
									Column: 48,
									Line:   410,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 51,
										Line:   410,
									},
									File:   "strings.flux",
									Source: "int",
									Start: ast.Position{
										Column: 48,
										Line:   410,
									},
								},
							},
							Name: "int",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// indexAny returns the index of the first instance of specified characters in a string. If none of the specified characters are present, it returns -1.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to search\n"}, ast.Comment{Text: "// - `chars` are the chars to search for\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Find the first occurrence of characters from a string\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       charIndex: strings.indexAny(v: r._field, chars: \"_-\")\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 17,
						Line:   433,
					},
					File:   "strings.flux",
					Source: "builtin indexAny",
					Start: ast.Position{
						Column: 1,
						Line:   433,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 17,
							Line:   433,
						},
						File:   "strings.flux",
						Source: "indexAny",
						Start: ast.Position{
							Column: 9,
							Line:   433,
						},
					},
				},
				Name: "indexAny",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 53,
							Line:   433,
						},
						File:   "strings.flux",
						Source: "(v: string, chars: string) => int",
						Start: ast.Position{
							Column: 20,
							Line:   433,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 53,
								Line:   433,
							},
							File:   "strings.flux",
							Source: "(v: string, chars: string) => int",
							Start: ast.Position{
								Column: 20,
								Line:   433,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 30,
									Line:   433,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 21,
									Line:   433,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 22,
										Line:   433,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 21,
										Line:   433,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 30,
										Line:   433,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 24,
										Line:   433,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 30,
											Line:   433,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 24,
											Line:   433,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 45,
									Line:   433,
								},
								File:   "strings.flux",
								Source: "chars: string",
								Start: ast.Position{
									Column: 32,
									Line:   433,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 37,
										Line:   433,
									},
									File:   "strings.flux",
									Source: "chars",
									Start: ast.Position{
										Column: 32,
										Line:   433,
									},
								},
							},
							Name: "chars",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 45,
										Line:   433,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 39,
										Line:   433,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 45,
											Line:   433,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 39,
											Line:   433,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 53,
									Line:   433,
								},
								File:   "strings.flux",
								Source: "int",
								Start: ast.Position{
									Column: 50,
									Line:   433,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 53,
										Line:   433,
									},
									File:   "strings.flux",
									Source: "int",
									Start: ast.Position{
										Column: 50,
										Line:   433,
									},
								},
							},
							Name: "int",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// lastIndex returns the index of the last instance of a substring in a string. If the substring is not present, the function returns -1.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to search\n"}, ast.Comment{Text: "// - `substr` is the substring to search for\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Find the last occurrence of a substring\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       the_index: strings.lastIndex(v: r.pageTitle, substr: \"the\")\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 18,
						Line:   456,
					},
					File:   "strings.flux",
					Source: "builtin lastIndex",
					Start: ast.Position{
						Column: 1,
						Line:   456,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 18,
							Line:   456,
						},
						File:   "strings.flux",
						Source: "lastIndex",
						Start: ast.Position{
							Column: 9,
							Line:   456,
						},
					},
				},
				Name: "lastIndex",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 55,
							Line:   456,
						},
						File:   "strings.flux",
						Source: "(v: string, substr: string) => int",
						Start: ast.Position{
							Column: 21,
							Line:   456,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 55,
								Line:   456,
							},
							File:   "strings.flux",
							Source: "(v: string, substr: string) => int",
							Start: ast.Position{
								Column: 21,
								Line:   456,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 31,
									Line:   456,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 22,
									Line:   456,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 23,
										Line:   456,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 22,
										Line:   456,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 31,
										Line:   456,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 25,
										Line:   456,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 31,
											Line:   456,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 25,
											Line:   456,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 47,
									Line:   456,
								},
								File:   "strings.flux",
								Source: "substr: string",
								Start: ast.Position{
									Column: 33,
									Line:   456,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 39,
										Line:   456,
									},
									File:   "strings.flux",
									Source: "substr",
									Start: ast.Position{
										Column: 33,
										Line:   456,
									},
								},
							},
							Name: "substr",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 47,
										Line:   456,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 41,
										Line:   456,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 47,
											Line:   456,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 41,
											Line:   456,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 55,
									Line:   456,
								},
								File:   "strings.flux",
								Source: "int",
								Start: ast.Position{
									Column: 52,
									Line:   456,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 55,
										Line:   456,
									},
									File:   "strings.flux",
									Source: "int",
									Start: ast.Position{
										Column: 52,
										Line:   456,
									},
								},
							},
							Name: "int",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// lastIndexAny returns the index of the last instance of any specified characters in a string. If none of the specified characters are present, the function returns -1.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to search\n"}, ast.Comment{Text: "// - `chars` are the characters to search for\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Find the last occurrence of characters from a string\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       charLastIndex: strings.lastIndexAny(v: r._field, chars: \"_-\")\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 21,
						Line:   479,
					},
					File:   "strings.flux",
					Source: "builtin lastIndexAny",
					Start: ast.Position{
						Column: 1,
						Line:   479,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 21,
							Line:   479,
						},
						File:   "strings.flux",
						Source: "lastIndexAny",
						Start: ast.Position{
							Column: 9,
							Line:   479,
						},
					},
				},
				Name: "lastIndexAny",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 57,
							Line:   479,
						},
						File:   "strings.flux",
						Source: "(v: string, chars: string) => int",
						Start: ast.Position{
							Column: 24,
							Line:   479,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 57,
								Line:   479,
							},
							File:   "strings.flux",
							Source: "(v: string, chars: string) => int",
							Start: ast.Position{
								Column: 24,
								Line:   479,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 34,
									Line:   479,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 25,
									Line:   479,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 26,
										Line:   479,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 25,
										Line:   479,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 34,
										Line:   479,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 28,
										Line:   479,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 34,
											Line:   479,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 28,
											Line:   479,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 49,
									Line:   479,
								},
								File:   "strings.flux",
								Source: "chars: string",
								Start: ast.Position{
									Column: 36,
									Line:   479,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 41,
										Line:   479,
									},
									File:   "strings.flux",
									Source: "chars",
									Start: ast.Position{
										Column: 36,
										Line:   479,
									},
								},
							},
							Name: "chars",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 49,
										Line:   479,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 43,
										Line:   479,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 49,
											Line:   479,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 43,
											Line:   479,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 57,
									Line:   479,
								},
								File:   "strings.flux",
								Source: "int",
								Start: ast.Position{
									Column: 54,
									Line:   479,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 57,
										Line:   479,
									},
									File:   "strings.flux",
									Source: "int",
									Start: ast.Position{
										Column: 54,
										Line:   479,
									},
								},
							},
							Name: "int",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// isDigit tests if a single-character string is a digit (0-9).\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the single-character string to test.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Filter by columns with digits as values\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> filter(fn: (r) => strings.isDigit(v: r.serverRef))\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 16,
						Line:   497,
					},
					File:   "strings.flux",
					Source: "builtin isDigit",
					Start: ast.Position{
						Column: 1,
						Line:   497,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 16,
							Line:   497,
						},
						File:   "strings.flux",
						Source: "isDigit",
						Start: ast.Position{
							Column: 9,
							Line:   497,
						},
					},
				},
				Name: "isDigit",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 38,
							Line:   497,
						},
						File:   "strings.flux",
						Source: "(v: string) => bool",
						Start: ast.Position{
							Column: 19,
							Line:   497,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 38,
								Line:   497,
							},
							File:   "strings.flux",
							Source: "(v: string) => bool",
							Start: ast.Position{
								Column: 19,
								Line:   497,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 29,
									Line:   497,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 20,
									Line:   497,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 21,
										Line:   497,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 20,
										Line:   497,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 29,
										Line:   497,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 23,
										Line:   497,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 29,
											Line:   497,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 23,
											Line:   497,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 38,
									Line:   497,
								},
								File:   "strings.flux",
								Source: "bool",
								Start: ast.Position{
									Column: 34,
									Line:   497,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 38,
										Line:   497,
									},
									File:   "strings.flux",
									Source: "bool",
									Start: ast.Position{
										Column: 34,
										Line:   497,
									},
								},
							},
							Name: "bool",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// isLetter tests if a single character string is a letter (a-z, A-Z).\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the single-character string to test.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Filter by columns with digits as values\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> filter(fn: (r) => strings.isLetter(v: r.serverRef))\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 17,
						Line:   515,
					},
					File:   "strings.flux",
					Source: "builtin isLetter",
					Start: ast.Position{
						Column: 1,
						Line:   515,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 17,
							Line:   515,
						},
						File:   "strings.flux",
						Source: "isLetter",
						Start: ast.Position{
							Column: 9,
							Line:   515,
						},
					},
				},
				Name: "isLetter",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 39,
							Line:   515,
						},
						File:   "strings.flux",
						Source: "(v: string) => bool",
						Start: ast.Position{
							Column: 20,
							Line:   515,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 39,
								Line:   515,
							},
							File:   "strings.flux",
							Source: "(v: string) => bool",
							Start: ast.Position{
								Column: 20,
								Line:   515,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 30,
									Line:   515,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 21,
									Line:   515,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 22,
										Line:   515,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 21,
										Line:   515,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 30,
										Line:   515,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 24,
										Line:   515,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 30,
											Line:   515,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 24,
											Line:   515,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 39,
									Line:   515,
								},
								File:   "strings.flux",
								Source: "bool",
								Start: ast.Position{
									Column: 35,
									Line:   515,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 39,
										Line:   515,
									},
									File:   "strings.flux",
									Source: "bool",
									Start: ast.Position{
										Column: 35,
										Line:   515,
									},
								},
							},
							Name: "bool",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// isLower tests if a single-character string is lowercase.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the single-character string value to test.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Filter by columns with single-letter lowercase values\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> filter(fn: (r) => strings.isLower(v: r.host))\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 16,
						Line:   533,
					},
					File:   "strings.flux",
					Source: "builtin isLower",
					Start: ast.Position{
						Column: 1,
						Line:   533,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 16,
							Line:   533,
						},
						File:   "strings.flux",
						Source: "isLower",
						Start: ast.Position{
							Column: 9,
							Line:   533,
						},
					},
				},
				Name: "isLower",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 38,
							Line:   533,
						},
						File:   "strings.flux",
						Source: "(v: string) => bool",
						Start: ast.Position{
							Column: 19,
							Line:   533,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 38,
								Line:   533,
							},
							File:   "strings.flux",
							Source: "(v: string) => bool",
							Start: ast.Position{
								Column: 19,
								Line:   533,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 29,
									Line:   533,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 20,
									Line:   533,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 21,
										Line:   533,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 20,
										Line:   533,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 29,
										Line:   533,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 23,
										Line:   533,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 29,
											Line:   533,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 23,
											Line:   533,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 38,
									Line:   533,
								},
								File:   "strings.flux",
								Source: "bool",
								Start: ast.Position{
									Column: 34,
									Line:   533,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 38,
										Line:   533,
									},
									File:   "strings.flux",
									Source: "bool",
									Start: ast.Position{
										Column: 34,
										Line:   533,
									},
								},
							},
							Name: "bool",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// isUpper tests if a single character string is uppercase.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the single-character string value to test.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Filter by columns with single-letter uppercase values\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> filter(fn: (r) => strings.isUpper(v: r.host))\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 16,
						Line:   551,
					},
					File:   "strings.flux",
					Source: "builtin isUpper",
					Start: ast.Position{
						Column: 1,
						Line:   551,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 16,
							Line:   551,
						},
						File:   "strings.flux",
						Source: "isUpper",
						Start: ast.Position{
							Column: 9,
							Line:   551,
						},
					},
				},
				Name: "isUpper",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 38,
							Line:   551,
						},
						File:   "strings.flux",
						Source: "(v: string) => bool",
						Start: ast.Position{
							Column: 19,
							Line:   551,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 38,
								Line:   551,
							},
							File:   "strings.flux",
							Source: "(v: string) => bool",
							Start: ast.Position{
								Column: 19,
								Line:   551,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 29,
									Line:   551,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 20,
									Line:   551,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 21,
										Line:   551,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 20,
										Line:   551,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 29,
										Line:   551,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 23,
										Line:   551,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 29,
											Line:   551,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 23,
											Line:   551,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 38,
									Line:   551,
								},
								File:   "strings.flux",
								Source: "bool",
								Start: ast.Position{
									Column: 34,
									Line:   551,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 38,
										Line:   551,
									},
									File:   "strings.flux",
									Source: "bool",
									Start: ast.Position{
										Column: 34,
										Line:   551,
									},
								},
							},
							Name: "bool",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// repeat returns a string consisting of i copies of a specified string.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to repeat.\n"}, ast.Comment{Text: "// - `i` is the number of times to repeat v.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Repeat a string based on existing columns\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       laugh: r.laugh\n"}, ast.Comment{Text: "//       intensity: r.intensity\n"}, ast.Comment{Text: "//       laughter: strings.repeat(v: r.laugh, i: r.intensity)\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 15,
						Line:   575,
					},
					File:   "strings.flux",
					Source: "builtin repeat",
					Start: ast.Position{
						Column: 1,
						Line:   575,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 15,
							Line:   575,
						},
						File:   "strings.flux",
						Source: "repeat",
						Start: ast.Position{
							Column: 9,
							Line:   575,
						},
					},
				},
				Name: "repeat",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 47,
							Line:   575,
						},
						File:   "strings.flux",
						Source: "(v: string, i: int) => string",
						Start: ast.Position{
							Column: 18,
							Line:   575,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 47,
								Line:   575,
							},
							File:   "strings.flux",
							Source: "(v: string, i: int) => string",
							Start: ast.Position{
								Column: 18,
								Line:   575,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 28,
									Line:   575,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 19,
									Line:   575,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 20,
										Line:   575,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 19,
										Line:   575,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 28,
										Line:   575,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 22,
										Line:   575,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 28,
											Line:   575,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 22,
											Line:   575,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 36,
									Line:   575,
								},
								File:   "strings.flux",
								Source: "i: int",
								Start: ast.Position{
									Column: 30,
									Line:   575,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 31,
										Line:   575,
									},
									File:   "strings.flux",
									Source: "i",
									Start: ast.Position{
										Column: 30,
										Line:   575,
									},
								},
							},
							Name: "i",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 36,
										Line:   575,
									},
									File:   "strings.flux",
									Source: "int",
									Start: ast.Position{
										Column: 33,
										Line:   575,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 36,
											Line:   575,
										},
										File:   "strings.flux",
										Source: "int",
										Start: ast.Position{
											Column: 33,
											Line:   575,
										},
									},
								},
								Name: "int",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 47,
									Line:   575,
								},
								File:   "strings.flux",
								Source: "string",
								Start: ast.Position{
									Column: 41,
									Line:   575,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 47,
										Line:   575,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 41,
										Line:   575,
									},
								},
							},
							Name: "string",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// replace replaces the first i non-overlapping instances of a substring with a specified replacement.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to search.\n"}, ast.Comment{Text: "// - `t` is the substring value to replace.\n"}, ast.Comment{Text: "// - `u` is the replacement for i instances of t.\n"}, ast.Comment{Text: "// - `i` is the number of non-overlapping t matches to replace.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Replace a specific number of string matches\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       content: strings.replace(v: r.content, t: \"he\", u: \"her\", i: 3)\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 16,
						Line:   600,
					},
					File:   "strings.flux",
					Source: "builtin replace",
					Start: ast.Position{
						Column: 1,
						Line:   600,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 16,
							Line:   600,
						},
						File:   "strings.flux",
						Source: "replace",
						Start: ast.Position{
							Column: 9,
							Line:   600,
						},
					},
				},
				Name: "replace",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 70,
							Line:   600,
						},
						File:   "strings.flux",
						Source: "(v: string, t: string, u: string, i: int) => string",
						Start: ast.Position{
							Column: 19,
							Line:   600,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 70,
								Line:   600,
							},
							File:   "strings.flux",
							Source: "(v: string, t: string, u: string, i: int) => string",
							Start: ast.Position{
								Column: 19,
								Line:   600,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 29,
									Line:   600,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 20,
									Line:   600,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 21,
										Line:   600,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 20,
										Line:   600,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 29,
										Line:   600,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 23,
										Line:   600,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 29,
											Line:   600,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 23,
											Line:   600,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 40,
									Line:   600,
								},
								File:   "strings.flux",
								Source: "t: string",
								Start: ast.Position{
									Column: 31,
									Line:   600,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 32,
										Line:   600,
									},
									File:   "strings.flux",
									Source: "t",
									Start: ast.Position{
										Column: 31,
										Line:   600,
									},
								},
							},
							Name: "t",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 40,
										Line:   600,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 34,
										Line:   600,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 40,
											Line:   600,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 34,
											Line:   600,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 51,
									Line:   600,
								},
								File:   "strings.flux",
								Source: "u: string",
								Start: ast.Position{
									Column: 42,
									Line:   600,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 43,
										Line:   600,
									},
									File:   "strings.flux",
									Source: "u",
									Start: ast.Position{
										Column: 42,
										Line:   600,
									},
								},
							},
							Name: "u",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 51,
										Line:   600,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 45,
										Line:   600,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 51,
											Line:   600,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 45,
											Line:   600,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 59,
									Line:   600,
								},
								File:   "strings.flux",
								Source: "i: int",
								Start: ast.Position{
									Column: 53,
									Line:   600,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 54,
										Line:   600,
									},
									File:   "strings.flux",
									Source: "i",
									Start: ast.Position{
										Column: 53,
										Line:   600,
									},
								},
							},
							Name: "i",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 59,
										Line:   600,
									},
									File:   "strings.flux",
									Source: "int",
									Start: ast.Position{
										Column: 56,
										Line:   600,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 59,
											Line:   600,
										},
										File:   "strings.flux",
										Source: "int",
										Start: ast.Position{
											Column: 56,
											Line:   600,
										},
									},
								},
								Name: "int",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 70,
									Line:   600,
								},
								File:   "strings.flux",
								Source: "string",
								Start: ast.Position{
									Column: 64,
									Line:   600,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 70,
										Line:   600,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 64,
										Line:   600,
									},
								},
							},
							Name: "string",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// replaceAll replaces all non-overlapping instances of a substring with a specified replacement.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to search.\n"}, ast.Comment{Text: "// - `t` is the substring to replace.\n"}, ast.Comment{Text: "// - `u` is the replacement for all instances of t.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Replace string matches\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       content: strings.replaceAll(v: r.content, t: \"he\", u: \"her\")\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 19,
						Line:   624,
					},
					File:   "strings.flux",
					Source: "builtin replaceAll",
					Start: ast.Position{
						Column: 1,
						Line:   624,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 19,
							Line:   624,
						},
						File:   "strings.flux",
						Source: "replaceAll",
						Start: ast.Position{
							Column: 9,
							Line:   624,
						},
					},
				},
				Name: "replaceAll",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 65,
							Line:   624,
						},
						File:   "strings.flux",
						Source: "(v: string, t: string, u: string) => string",
						Start: ast.Position{
							Column: 22,
							Line:   624,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 65,
								Line:   624,
							},
							File:   "strings.flux",
							Source: "(v: string, t: string, u: string) => string",
							Start: ast.Position{
								Column: 22,
								Line:   624,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 32,
									Line:   624,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 23,
									Line:   624,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 24,
										Line:   624,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 23,
										Line:   624,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 32,
										Line:   624,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 26,
										Line:   624,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 32,
											Line:   624,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 26,
											Line:   624,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 43,
									Line:   624,
								},
								File:   "strings.flux",
								Source: "t: string",
								Start: ast.Position{
									Column: 34,
									Line:   624,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 35,
										Line:   624,
									},
									File:   "strings.flux",
									Source: "t",
									Start: ast.Position{
										Column: 34,
										Line:   624,
									},
								},
							},
							Name: "t",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 43,
										Line:   624,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 37,
										Line:   624,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 43,
											Line:   624,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 37,
											Line:   624,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 54,
									Line:   624,
								},
								File:   "strings.flux",
								Source: "u: string",
								Start: ast.Position{
									Column: 45,
									Line:   624,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 46,
										Line:   624,
									},
									File:   "strings.flux",
									Source: "u",
									Start: ast.Position{
										Column: 45,
										Line:   624,
									},
								},
							},
							Name: "u",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 54,
										Line:   624,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 48,
										Line:   624,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 54,
											Line:   624,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 48,
											Line:   624,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 65,
									Line:   624,
								},
								File:   "strings.flux",
								Source: "string",
								Start: ast.Position{
									Column: 59,
									Line:   624,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 65,
										Line:   624,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 59,
										Line:   624,
									},
								},
							},
							Name: "string",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// split splits a string on a specified separator and returns an array of substrings.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to split.\n"}, ast.Comment{Text: "// - `t` is the string value that acts as the separator.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Split a string into an array of substrings\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map (fn:(r) => strings.split(v: r.searchTags, t: \",\"))\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 14,
						Line:   643,
					},
					File:   "strings.flux",
					Source: "builtin split",
					Start: ast.Position{
						Column: 1,
						Line:   643,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 14,
							Line:   643,
						},
						File:   "strings.flux",
						Source: "split",
						Start: ast.Position{
							Column: 9,
							Line:   643,
						},
					},
				},
				Name: "split",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 51,
							Line:   643,
						},
						File:   "strings.flux",
						Source: "(v: string, t: string) => [string]",
						Start: ast.Position{
							Column: 17,
							Line:   643,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 51,
								Line:   643,
							},
							File:   "strings.flux",
							Source: "(v: string, t: string) => [string]",
							Start: ast.Position{
								Column: 17,
								Line:   643,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 27,
									Line:   643,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 18,
									Line:   643,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 19,
										Line:   643,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 18,
										Line:   643,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 27,
										Line:   643,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 21,
										Line:   643,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 27,
											Line:   643,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 21,
											Line:   643,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 38,
									Line:   643,
								},
								File:   "strings.flux",
								Source: "t: string",
								Start: ast.Position{
									Column: 29,
									Line:   643,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 30,
										Line:   643,
									},
									File:   "strings.flux",
									Source: "t",
									Start: ast.Position{
										Column: 29,
										Line:   643,
									},
								},
							},
							Name: "t",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 38,
										Line:   643,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 32,
										Line:   643,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 38,
											Line:   643,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 32,
											Line:   643,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.ArrayType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 51,
									Line:   643,
								},
								File:   "strings.flux",
								Source: "[string]",
								Start: ast.Position{
									Column: 43,
									Line:   643,
								},
							},
						},
						ElementType: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 50,
										Line:   643,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 44,
										Line:   643,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 50,
											Line:   643,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 44,
											Line:   643,
										},
									},
								},
								Name: "string",
							},
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// splitAfter splits a string after a specified separator and returns an array of substrings. Split substrings include the separator, t.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to split.\n"}, ast.Comment{Text: "// - `t` is the string value that acts as the separator.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Split a string into an array of substrings\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//    |> map (fn:(r) => strings.splitAfter(v: r.searchTags, t: \",\"))\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 19,
						Line:   662,
					},
					File:   "strings.flux",
					Source: "builtin splitAfter",
					Start: ast.Position{
						Column: 1,
						Line:   662,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 19,
							Line:   662,
						},
						File:   "strings.flux",
						Source: "splitAfter",
						Start: ast.Position{
							Column: 9,
							Line:   662,
						},
					},
				},
				Name: "splitAfter",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 56,
							Line:   662,
						},
						File:   "strings.flux",
						Source: "(v: string, t: string) => [string]",
						Start: ast.Position{
							Column: 22,
							Line:   662,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 56,
								Line:   662,
							},
							File:   "strings.flux",
							Source: "(v: string, t: string) => [string]",
							Start: ast.Position{
								Column: 22,
								Line:   662,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 32,
									Line:   662,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 23,
									Line:   662,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 24,
										Line:   662,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 23,
										Line:   662,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 32,
										Line:   662,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 26,
										Line:   662,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 32,
											Line:   662,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 26,
											Line:   662,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 43,
									Line:   662,
								},
								File:   "strings.flux",
								Source: "t: string",
								Start: ast.Position{
									Column: 34,
									Line:   662,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 35,
										Line:   662,
									},
									File:   "strings.flux",
									Source: "t",
									Start: ast.Position{
										Column: 34,
										Line:   662,
									},
								},
							},
							Name: "t",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 43,
										Line:   662,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 37,
										Line:   662,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 43,
											Line:   662,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 37,
											Line:   662,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.ArrayType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 56,
									Line:   662,
								},
								File:   "strings.flux",
								Source: "[string]",
								Start: ast.Position{
									Column: 48,
									Line:   662,
								},
							},
						},
						ElementType: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 55,
										Line:   662,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 49,
										Line:   662,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 55,
											Line:   662,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 49,
											Line:   662,
										},
									},
								},
								Name: "string",
							},
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// splitN splits a string on a specified separator and returns an array of i substrings.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to split.\n"}, ast.Comment{Text: "// - `t` is the string value that acts as the separator.\n"}, ast.Comment{Text: "// - `i` is the maximum number of split substrings to return. -1 returns all matching substrings.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "//       - The last substring is the unsplit remainder.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Split a string into an array of substrings\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//    |> map (fn:(r) => strings.splitN(v: r.searchTags, t: \",\"))\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 15,
						Line:   684,
					},
					File:   "strings.flux",
					Source: "builtin splitN",
					Start: ast.Position{
						Column: 1,
						Line:   684,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 15,
							Line:   684,
						},
						File:   "strings.flux",
						Source: "splitN",
						Start: ast.Position{
							Column: 9,
							Line:   684,
						},
					},
				},
				Name: "splitN",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 60,
							Line:   684,
						},
						File:   "strings.flux",
						Source: "(v: string, t: string, n: int) => [string]",
						Start: ast.Position{
							Column: 18,
							Line:   684,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 60,
								Line:   684,
							},
							File:   "strings.flux",
							Source: "(v: string, t: string, n: int) => [string]",
							Start: ast.Position{
								Column: 18,
								Line:   684,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 28,
									Line:   684,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 19,
									Line:   684,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 20,
										Line:   684,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 19,
										Line:   684,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 28,
										Line:   684,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 22,
										Line:   684,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 28,
											Line:   684,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 22,
											Line:   684,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 39,
									Line:   684,
								},
								File:   "strings.flux",
								Source: "t: string",
								Start: ast.Position{
									Column: 30,
									Line:   684,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 31,
										Line:   684,
									},
									File:   "strings.flux",
									Source: "t",
									Start: ast.Position{
										Column: 30,
										Line:   684,
									},
								},
							},
							Name: "t",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 39,
										Line:   684,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 33,
										Line:   684,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 39,
											Line:   684,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 33,
											Line:   684,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 47,
									Line:   684,
								},
								File:   "strings.flux",
								Source: "n: int",
								Start: ast.Position{
									Column: 41,
									Line:   684,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 42,
										Line:   684,
									},
									File:   "strings.flux",
									Source: "n",
									Start: ast.Position{
										Column: 41,
										Line:   684,
									},
								},
							},
							Name: "n",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 47,
										Line:   684,
									},
									File:   "strings.flux",
									Source: "int",
									Start: ast.Position{
										Column: 44,
										Line:   684,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 47,
											Line:   684,
										},
										File:   "strings.flux",
										Source: "int",
										Start: ast.Position{
											Column: 44,
											Line:   684,
										},
									},
								},
								Name: "int",
							},
						},
					}},
					Return: &ast.ArrayType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 60,
									Line:   684,
								},
								File:   "strings.flux",
								Source: "[string]",
								Start: ast.Position{
									Column: 52,
									Line:   684,
								},
							},
						},
						ElementType: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 59,
										Line:   684,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 53,
										Line:   684,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 59,
											Line:   684,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 53,
											Line:   684,
										},
									},
								},
								Name: "string",
							},
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// splitAfterN splits a string after a specified separator and returns an array of i substrings. Split substrings include the separator t.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to split.\n"}, ast.Comment{Text: "// - `t` is the string value that acts as the separator.\n"}, ast.Comment{Text: "// - `i` is the maximum number of split substrings to return. -1 returns all matching substrings.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "//       - The last substring is the unsplit remainder.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Split a string into an array of substrings\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//    |> map (fn:(r) => strings.splitAfterN(v: r.searchTags, t: \",\"))\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 20,
						Line:   706,
					},
					File:   "strings.flux",
					Source: "builtin splitAfterN",
					Start: ast.Position{
						Column: 1,
						Line:   706,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 20,
							Line:   706,
						},
						File:   "strings.flux",
						Source: "splitAfterN",
						Start: ast.Position{
							Column: 9,
							Line:   706,
						},
					},
				},
				Name: "splitAfterN",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 65,
							Line:   706,
						},
						File:   "strings.flux",
						Source: "(v: string, t: string, i: int) => [string]",
						Start: ast.Position{
							Column: 23,
							Line:   706,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 65,
								Line:   706,
							},
							File:   "strings.flux",
							Source: "(v: string, t: string, i: int) => [string]",
							Start: ast.Position{
								Column: 23,
								Line:   706,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 33,
									Line:   706,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 24,
									Line:   706,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 25,
										Line:   706,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 24,
										Line:   706,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 33,
										Line:   706,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 27,
										Line:   706,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 33,
											Line:   706,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 27,
											Line:   706,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 44,
									Line:   706,
								},
								File:   "strings.flux",
								Source: "t: string",
								Start: ast.Position{
									Column: 35,
									Line:   706,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 36,
										Line:   706,
									},
									File:   "strings.flux",
									Source: "t",
									Start: ast.Position{
										Column: 35,
										Line:   706,
									},
								},
							},
							Name: "t",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 44,
										Line:   706,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 38,
										Line:   706,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 44,
											Line:   706,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 38,
											Line:   706,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 52,
									Line:   706,
								},
								File:   "strings.flux",
								Source: "i: int",
								Start: ast.Position{
									Column: 46,
									Line:   706,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 47,
										Line:   706,
									},
									File:   "strings.flux",
									Source: "i",
									Start: ast.Position{
										Column: 46,
										Line:   706,
									},
								},
							},
							Name: "i",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 52,
										Line:   706,
									},
									File:   "strings.flux",
									Source: "int",
									Start: ast.Position{
										Column: 49,
										Line:   706,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 52,
											Line:   706,
										},
										File:   "strings.flux",
										Source: "int",
										Start: ast.Position{
											Column: 49,
											Line:   706,
										},
									},
								},
								Name: "int",
							},
						},
					}},
					Return: &ast.ArrayType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 65,
									Line:   706,
								},
								File:   "strings.flux",
								Source: "[string]",
								Start: ast.Position{
									Column: 57,
									Line:   706,
								},
							},
						},
						ElementType: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 64,
										Line:   706,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 58,
										Line:   706,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 64,
											Line:   706,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 58,
											Line:   706,
										},
									},
								},
								Name: "string",
							},
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// joinStr concatenates elements of a string array into a single string using a specified separator.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `arr` is the array of strings to concatenate.\n"}, ast.Comment{Text: "// - `t` is the separator to use in the concatenated value.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Join a list of strings into a single string\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// searchTags = [\"tag1\", \"tag2\", \"tag3\"]\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// strings.joinStr(arr: searchTags, v: \",\"))\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 16,
						Line:   726,
					},
					File:   "strings.flux",
					Source: "builtin joinStr",
					Start: ast.Position{
						Column: 1,
						Line:   726,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 16,
							Line:   726,
						},
						File:   "strings.flux",
						Source: "joinStr",
						Start: ast.Position{
							Column: 9,
							Line:   726,
						},
					},
				},
				Name: "joinStr",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 55,
							Line:   726,
						},
						File:   "strings.flux",
						Source: "(arr: [string], v: string) => string",
						Start: ast.Position{
							Column: 19,
							Line:   726,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 55,
								Line:   726,
							},
							File:   "strings.flux",
							Source: "(arr: [string], v: string) => string",
							Start: ast.Position{
								Column: 19,
								Line:   726,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 33,
									Line:   726,
								},
								File:   "strings.flux",
								Source: "arr: [string]",
								Start: ast.Position{
									Column: 20,
									Line:   726,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 23,
										Line:   726,
									},
									File:   "strings.flux",
									Source: "arr",
									Start: ast.Position{
										Column: 20,
										Line:   726,
									},
								},
							},
							Name: "arr",
						},
						Ty: &ast.ArrayType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 33,
										Line:   726,
									},
									File:   "strings.flux",
									Source: "[string]",
									Start: ast.Position{
										Column: 25,
										Line:   726,
									},
								},
							},
							ElementType: &ast.NamedType{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 32,
											Line:   726,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 26,
											Line:   726,
										},
									},
								},
								ID: &ast.Identifier{
									BaseNode: ast.BaseNode{
										Comments: nil,
										Errors:   nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 32,
												Line:   726,
											},
											File:   "strings.flux",
											Source: "string",
											Start: ast.Position{
												Column: 26,
												Line:   726,
											},
										},
									},
									Name: "string",
								},
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 44,
									Line:   726,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 35,
									Line:   726,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 36,
										Line:   726,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 35,
										Line:   726,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 44,
										Line:   726,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 38,
										Line:   726,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 44,
											Line:   726,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 38,
											Line:   726,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 55,
									Line:   726,
								},
								File:   "strings.flux",
								Source: "string",
								Start: ast.Position{
									Column: 49,
									Line:   726,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 55,
										Line:   726,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 49,
										Line:   726,
									},
								},
							},
							Name: "string",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// strlen returns the length of a string. String length is determined by the number of UTF code points a string contains.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `V` is the string value to measure.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Filter based on string value length\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//    |> filter(fn: (r) => strings.strlen(v: r._measurement) <= 4)\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Store the length of string values\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       length: strings.strlen(v: r._value)\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "//\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 15,
						Line:   757,
					},
					File:   "strings.flux",
					Source: "builtin strlen",
					Start: ast.Position{
						Column: 1,
						Line:   757,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 15,
							Line:   757,
						},
						File:   "strings.flux",
						Source: "strlen",
						Start: ast.Position{
							Column: 9,
							Line:   757,
						},
					},
				},
				Name: "strlen",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 36,
							Line:   757,
						},
						File:   "strings.flux",
						Source: "(v: string) => int",
						Start: ast.Position{
							Column: 18,
							Line:   757,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 36,
								Line:   757,
							},
							File:   "strings.flux",
							Source: "(v: string) => int",
							Start: ast.Position{
								Column: 18,
								Line:   757,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 28,
									Line:   757,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 19,
									Line:   757,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 20,
										Line:   757,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 19,
										Line:   757,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 28,
										Line:   757,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 22,
										Line:   757,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 28,
											Line:   757,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 22,
											Line:   757,
										},
									},
								},
								Name: "string",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 36,
									Line:   757,
								},
								File:   "strings.flux",
								Source: "int",
								Start: ast.Position{
									Column: 33,
									Line:   757,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 36,
										Line:   757,
									},
									File:   "strings.flux",
									Source: "int",
									Start: ast.Position{
										Column: 33,
										Line:   757,
									},
								},
							},
							Name: "int",
						},
					},
				},
			},
		}, &ast.BuiltinStatement{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "//\n"}, ast.Comment{Text: "// substring returns a substring based on start and end parameters. These parameters are represent indices of UTF code points in the string.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Parameters\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// - `v` is the string value to search for.\n"}, ast.Comment{Text: "// - `start` is the starting inclusive index of the substring.\n"}, ast.Comment{Text: "// - `end` is the ending exclusive index of the substring.\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ## Store the first four characters of a string\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// ```\n"}, ast.Comment{Text: "// import \"strings\"\n"}, ast.Comment{Text: "//\n"}, ast.Comment{Text: "// data\n"}, ast.Comment{Text: "//   |> map(fn: (r) => ({\n"}, ast.Comment{Text: "//       r with\n"}, ast.Comment{Text: "//       abbr: strings.substring(v: r.name, start: 0, end: 4)\n"}, ast.Comment{Text: "//     })\n"}, ast.Comment{Text: "//   )\n"}, ast.Comment{Text: "// ```\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 18,
						Line:   780,
					},
					File:   "strings.flux",
					Source: "builtin substring",
					Start: ast.Position{
						Column: 1,
						Line:   780,
					},
				},
			},
			Colon: nil,
			ID: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 18,
							Line:   780,
						},
						File:   "strings.flux",
						Source: "substring",
						Start: ast.Position{
							Column: 9,
							Line:   780,
						},
					},
				},
				Name: "substring",
			},
			Ty: ast.TypeExpression{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 64,
							Line:   780,
						},
						File:   "strings.flux",
						Source: "(v: string, start: int, end: int) => string",
						Start: ast.Position{
							Column: 21,
							Line:   780,
						},
					},
				},
				Constraints: []*ast.TypeConstraint{},
				Ty: &ast.FunctionType{
					BaseNode: ast.BaseNode{
						Comments: nil,
						Errors:   nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 64,
								Line:   780,
							},
							File:   "strings.flux",
							Source: "(v: string, start: int, end: int) => string",
							Start: ast.Position{
								Column: 21,
								Line:   780,
							},
						},
					},
					Parameters: []*ast.ParameterType{&ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 31,
									Line:   780,
								},
								File:   "strings.flux",
								Source: "v: string",
								Start: ast.Position{
									Column: 22,
									Line:   780,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 23,
										Line:   780,
									},
									File:   "strings.flux",
									Source: "v",
									Start: ast.Position{
										Column: 22,
										Line:   780,
									},
								},
							},
							Name: "v",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 31,
										Line:   780,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 25,
										Line:   780,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 31,
											Line:   780,
										},
										File:   "strings.flux",
										Source: "string",
										Start: ast.Position{
											Column: 25,
											Line:   780,
										},
									},
								},
								Name: "string",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 43,
									Line:   780,
								},
								File:   "strings.flux",
								Source: "start: int",
								Start: ast.Position{
									Column: 33,
									Line:   780,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 38,
										Line:   780,
									},
									File:   "strings.flux",
									Source: "start",
									Start: ast.Position{
										Column: 33,
										Line:   780,
									},
								},
							},
							Name: "start",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 43,
										Line:   780,
									},
									File:   "strings.flux",
									Source: "int",
									Start: ast.Position{
										Column: 40,
										Line:   780,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 43,
											Line:   780,
										},
										File:   "strings.flux",
										Source: "int",
										Start: ast.Position{
											Column: 40,
											Line:   780,
										},
									},
								},
								Name: "int",
							},
						},
					}, &ast.ParameterType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 53,
									Line:   780,
								},
								File:   "strings.flux",
								Source: "end: int",
								Start: ast.Position{
									Column: 45,
									Line:   780,
								},
							},
						},
						Kind: "Required",
						Name: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 48,
										Line:   780,
									},
									File:   "strings.flux",
									Source: "end",
									Start: ast.Position{
										Column: 45,
										Line:   780,
									},
								},
							},
							Name: "end",
						},
						Ty: &ast.NamedType{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 53,
										Line:   780,
									},
									File:   "strings.flux",
									Source: "int",
									Start: ast.Position{
										Column: 50,
										Line:   780,
									},
								},
							},
							ID: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Comments: nil,
									Errors:   nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 53,
											Line:   780,
										},
										File:   "strings.flux",
										Source: "int",
										Start: ast.Position{
											Column: 50,
											Line:   780,
										},
									},
								},
								Name: "int",
							},
						},
					}},
					Return: &ast.NamedType{
						BaseNode: ast.BaseNode{
							Comments: nil,
							Errors:   nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 64,
									Line:   780,
								},
								File:   "strings.flux",
								Source: "string",
								Start: ast.Position{
									Column: 58,
									Line:   780,
								},
							},
						},
						ID: &ast.Identifier{
							BaseNode: ast.BaseNode{
								Comments: nil,
								Errors:   nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 64,
										Line:   780,
									},
									File:   "strings.flux",
									Source: "string",
									Start: ast.Position{
										Column: 58,
										Line:   780,
									},
								},
							},
							Name: "string",
						},
					},
				},
			},
		}},
		Eof:      nil,
		Imports:  nil,
		Metadata: "parser-type=rust",
		Name:     "strings.flux",
		Package: &ast.PackageClause{
			BaseNode: ast.BaseNode{
				Comments: []ast.Comment{ast.Comment{Text: "// The strings package provides functions to manipulate UTF-8 encoded strings.\n"}},
				Errors:   nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 16,
						Line:   2,
					},
					File:   "strings.flux",
					Source: "package strings",
					Start: ast.Position{
						Column: 1,
						Line:   2,
					},
				},
			},
			Name: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Comments: nil,
					Errors:   nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 16,
							Line:   2,
						},
						File:   "strings.flux",
						Source: "strings",
						Start: ast.Position{
							Column: 9,
							Line:   2,
						},
					},
				},
				Name: "strings",
			},
		},
	}},
	Package: "strings",
	Path:    "strings",
}

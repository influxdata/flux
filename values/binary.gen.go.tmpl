package values

import (

	fluxarray "github.com/influxdata/flux/array"
    "github.com/apache/arrow/go/v7/arrow/memory"
	"github.com/influxdata/flux/codes"
	"github.com/influxdata/flux/internal/errors"
	"github.com/influxdata/flux/semantic"
)

{{range $index, $op := .}}

func vector{{$op.Name}}(l, r Vector, mem memory.Allocator) (Value, error) {
	switch l.ElementType().Nature() {

    {{range $index, $type := .Types}}

    {{if eq $type "Uint"}}
	case semantic.UInt:
    {{else}}
	case semantic.{{$type}}:
    {{end}}
        var lal, ral fluxarray.{{$type}}ArrLike
        vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.{{$type}}ArrLike()
		    vrCount += 1
		} else {
		    lal = l.Arr().(*fluxarray.{{$type}})
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
            ral = vecRepeat.{{$type}}ArrLike()
		    vrCount += 1
		} else {
		    ral = r.Arr().(*fluxarray.{{$type}})
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.{{$type}}{{$op.Name}}
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
		    // FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
		    panic("TODO: const folding")
		}

		x, err := fluxarray.{{$type}}{{$op.Name}}(lal, ral, mem)
		if err != nil {
			return nil, err
		}
    {{if eq $op.Op "^"}}
		return NewVectorValue(x, semantic.BasicFloat), nil
    {{else}}
		return NewVectorValue(x, semantic.Basic{{$type}}), nil
    {{end}}

    {{end}}

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector {{$op.Name}}: %v", l.ElementType())
	}
}

{{end}}

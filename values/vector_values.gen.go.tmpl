package values

import (
	"fmt"
	"regexp"

	arrow "github.com/influxdata/flux/array"
	"github.com/influxdata/flux/memory"
	"github.com/influxdata/flux/semantic"
)

func NewVectorValue(arr arrow.Array, typ semantic.MonoType) Vector {
	switch typ {
	{{range .}}
	case {{.MonoType}}:
		return New{{.Name}}VectorValue(arr.(*{{.Type}}))
	{{end}}
	default:
		panic(fmt.Errorf("unsupported column data type: %s", typ))
	}
}

// A convenience method for unit testing
func NewVectorFromElements(mem memory.Allocator, es ...interface{}) Vector {
	var typ semantic.MonoType
	switch es[0].(type) {
	{{range .}}
	case {{.InterfaceType}}:
		typ = {{.MonoType}}
	{{end}}
	default:
		panic(fmt.Errorf("unsupported data type"))
	}

	vs := make([]Value, len(es))
	for i, e := range es {
		vs[i] = New(e)
	}
	return newVectorFromSlice(vs, typ, mem)
}

func newVectorFromSlice(values []Value, typ semantic.MonoType, mem memory.Allocator) Vector {
	switch typ {
	{{range .}}
	case {{.MonoType}}:
		b := arrow.New{{.ValueName}}Builder(mem)
		for _, v := range values {
			b.Append(v.{{.ValueType}}())
		}
		arr := b.New{{.ValueName}}Array()
		return New{{.Name}}VectorValue(arr)
	{{end}}
	default:
		panic(fmt.Errorf("unsupported column data type: %s", typ))
	}
}

func NewVectorRepeatValue(v Value) Vector {
    typ := v.Type()
	switch typ {
	{{range .}}
	case {{.MonoType}}:
		return &vectorRepeatValue{
            val: v,
            typ: semantic.NewVectorType({{.MonoType}}),
        }
	{{end}}
	default:
		panic(fmt.Errorf("unsupported column data type: %s", typ))
	}
}
type vectorRepeatValue struct {
	val Value
	typ semantic.MonoType
}
type intArrLikeAdapter struct {
    v int64
}
type uintArrLikeAdapter struct {
    v uint64
}
type floatArrLikeAdapter struct {
    v float64
}
type stringArrLikeAdapter struct {
    v string
}
func (vr *vectorRepeatValue) IntArrLike() arrow.IntArrLike { return intArrLikeAdapter { v: vr.val.Int() }}
func (vr *vectorRepeatValue) UintArrLike() arrow.UintArrLike { return uintArrLikeAdapter { v: vr.val.UInt() }}
func (vr *vectorRepeatValue) FloatArrLike() arrow.FloatArrLike { return floatArrLikeAdapter { v: vr.val.Float() }}
func (vr *vectorRepeatValue) StringArrLike() arrow.StringArrLike { return stringArrLikeAdapter { v: vr.val.Str() }}
func (ala intArrLikeAdapter) IsValid(i int) bool { return true }
func (ala uintArrLikeAdapter) IsValid(i int) bool { return true }
func (ala floatArrLikeAdapter) IsValid(i int) bool { return true }
func (ala stringArrLikeAdapter) IsValid(i int) bool { return true }
func (ala intArrLikeAdapter) Value(int) int64 { return ala.v }
func (ala uintArrLikeAdapter) Value(int) uint64 { return ala.v }
func (ala floatArrLikeAdapter) Value(int) float64 { return ala.v }
func (ala stringArrLikeAdapter) Value(int) string { return ala.v }
func (ala intArrLikeAdapter) Len() int { panic("unsupported: vector repeat values have no length") }
func (ala uintArrLikeAdapter) Len() int { panic("unsupported: vector repeat values have no length") }
func (ala floatArrLikeAdapter) Len() int { panic("unsupported: vector repeat values have no length") }
func (ala stringArrLikeAdapter) Len() int { panic("unsupported: vector repeat values have no length") }

func (v *vectorRepeatValue) ElementType() semantic.MonoType {
	t, err := v.typ.ElemType()
	if err != nil {
		panic("could not get element type of vector value")
	}
	return t
}
func (v *vectorRepeatValue) Arr() arrow.Array {
    panic("unsupported - vectorRepeatValue has no array backing")
}
func (v *vectorRepeatValue) Retain() {
    v.val.Retain()
}
func (v *vectorRepeatValue) Release() {
    v.val.Release()
}
func (v *vectorRepeatValue) Type() semantic.MonoType { return v.typ }
func (v *vectorRepeatValue) IsNull() bool { return false }
func (v *vectorRepeatValue) Str() string { panic(UnexpectedKind(semantic.Vector, semantic.String)) }
func (v *vectorRepeatValue) Bytes() []byte { panic(UnexpectedKind(semantic.Vector, semantic.Bytes)) }
func (v *vectorRepeatValue) Int() int64 { panic(UnexpectedKind(semantic.Vector, semantic.Int)) }
func (v *vectorRepeatValue) UInt() uint64 { panic(UnexpectedKind(semantic.Vector, semantic.UInt)) }
func (v *vectorRepeatValue) Float() float64 { panic(UnexpectedKind(semantic.Vector, semantic.Float)) }
func (v *vectorRepeatValue) Bool() bool { panic(UnexpectedKind(semantic.Vector, semantic.Bool)) }
func (v *vectorRepeatValue) Time() Time { panic(UnexpectedKind(semantic.Vector, semantic.Time)) }
func (v *vectorRepeatValue) Duration() Duration { panic(UnexpectedKind(semantic.Vector, semantic.Duration)) }
func (v *vectorRepeatValue) Regexp() *regexp.Regexp { panic(UnexpectedKind(semantic.Vector, semantic.Regexp)) }
func (v *vectorRepeatValue) Array() Array { panic(UnexpectedKind(semantic.Vector, semantic.Array)) }
func (v *vectorRepeatValue) Object() Object { panic(UnexpectedKind(semantic.Vector, semantic.Object)) }
func (v *vectorRepeatValue) Function() Function { panic(UnexpectedKind(semantic.Vector, semantic.Function)) }
func (v *vectorRepeatValue) Dict() Dictionary { panic(UnexpectedKind(semantic.Vector, semantic.Dictionary)) }
func (v *vectorRepeatValue) Vector() Vector {
	return v
}
func (v *vectorRepeatValue) Equal(other Value) bool {
	panic("cannot compare two vectors for equality")
}

var _ Value = &vectorRepeatValue{}
var _ Vector = &vectorRepeatValue{}
{{range .}}
var _ Value = &{{.Name}}VectorValue{}
var _ Vector = &{{.Name}}VectorValue{}
var _ arrow.Array = &{{.Type}}{}

type {{.Name}}VectorValue struct {
	arr *{{.Type}}
	typ semantic.MonoType
}

func New{{.Name}}VectorValue(arr *{{.Type}}) Vector {
	return &{{.Name}}VectorValue{
		arr: arr,
		typ: semantic.NewVectorType({{.MonoType}}),
	}
}


func (v *{{.Name}}VectorValue) ElementType() semantic.MonoType {
	t, err := v.typ.ElemType()
	if err != nil {
		panic("could not get element type of vector value")
	}
	return t
}
func (v *{{.Name}}VectorValue) Arr() arrow.Array { return v.arr }
func (v *{{.Name}}VectorValue) Retain() {
	v.arr.Retain()
}
func (v *{{.Name}}VectorValue) Release() {
	v.arr.Release()
}

func (v *{{.Name}}VectorValue) Type() semantic.MonoType { return v.typ }
func (v *{{.Name}}VectorValue) IsNull() bool { return false }
func (v *{{.Name}}VectorValue) Str() string { panic(UnexpectedKind(semantic.Vector, semantic.String)) }
func (v *{{.Name}}VectorValue) Bytes() []byte { panic(UnexpectedKind(semantic.Vector, semantic.Bytes)) }
func (v *{{.Name}}VectorValue) Int() int64 { panic(UnexpectedKind(semantic.Vector, semantic.Int)) }
func (v *{{.Name}}VectorValue) UInt() uint64 { panic(UnexpectedKind(semantic.Vector, semantic.UInt)) }
func (v *{{.Name}}VectorValue) Float() float64 { panic(UnexpectedKind(semantic.Vector, semantic.Float)) }
func (v *{{.Name}}VectorValue) Bool() bool { panic(UnexpectedKind(semantic.Vector, semantic.Bool)) }
func (v *{{.Name}}VectorValue) Time() Time { panic(UnexpectedKind(semantic.Vector, semantic.Time)) }
func (v *{{.Name}}VectorValue) Duration() Duration { panic(UnexpectedKind(semantic.Vector, semantic.Duration)) }
func (v *{{.Name}}VectorValue) Regexp() *regexp.Regexp { panic(UnexpectedKind(semantic.Vector, semantic.Regexp)) }
func (v *{{.Name}}VectorValue) Array() Array { panic(UnexpectedKind(semantic.Vector, semantic.Array)) }
func (v *{{.Name}}VectorValue) Object() Object { panic(UnexpectedKind(semantic.Vector, semantic.Object)) }
func (v *{{.Name}}VectorValue) Function() Function { panic(UnexpectedKind(semantic.Vector, semantic.Function)) }
func (v *{{.Name}}VectorValue) Dict() Dictionary { panic(UnexpectedKind(semantic.Vector, semantic.Dictionary)) }
func (v *{{.Name}}VectorValue) Vector() Vector {
	return v
}

func (v *{{.Name}}VectorValue) Equal(other Value) bool {
	panic("cannot compare two vectors for equality")
}
{{end}}

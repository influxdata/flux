// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: binary.gen.go.tmpl

package values

import (
	"github.com/apache/arrow/go/v7/arrow/memory"
	fluxarray "github.com/influxdata/flux/array"
	"github.com/influxdata/flux/codes"
	"github.com/influxdata/flux/internal/errors"
	"github.com/influxdata/flux/semantic"
)

func vectorAdd(l, r Vector, mem memory.Allocator) (Value, error) {
	var lvr, rvr *Value
	if vr, ok := l.(*VectorRepeatValue); ok {
		lvr = &vr.val
	}
	if vr, ok := r.(*VectorRepeatValue); ok {
		rvr = &vr.val
	}

	if lvr != nil && rvr != nil {
		// XXX: we can handle this case here if we are willing to plumb the
		// OperatorKind through here so we can do the lookup for the row-based version of this op.
		panic("got 2 VectorRepeatValue; 'const folding' should be done earlier, in the function lookup")
	}

	switch l.ElementType().Nature() {

	case semantic.Int:

		var (
			x *fluxarray.Int

			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntAddLConst((*lvr).Int(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntAddRConst(l.Arr().(*fluxarray.Int), (*rvr).Int(), mem)
		} else {
			x, err = fluxarray.IntAdd(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicInt), nil

	case semantic.UInt:

		var (
			x *fluxarray.Uint

			err error
		)
		if lvr != nil {
			x, err = fluxarray.UintAddLConst((*lvr).UInt(), r.Arr().(*fluxarray.Uint), mem)
		} else if rvr != nil {
			x, err = fluxarray.UintAddRConst(l.Arr().(*fluxarray.Uint), (*rvr).UInt(), mem)
		} else {
			x, err = fluxarray.UintAdd(l.Arr().(*fluxarray.Uint), r.Arr().(*fluxarray.Uint), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicUint), nil

	case semantic.Float:

		var (
			x *fluxarray.Float

			err error
		)
		if lvr != nil {
			x, err = fluxarray.FloatAddLConst((*lvr).Float(), r.Arr().(*fluxarray.Float), mem)
		} else if rvr != nil {
			x, err = fluxarray.FloatAddRConst(l.Arr().(*fluxarray.Float), (*rvr).Float(), mem)
		} else {
			x, err = fluxarray.FloatAdd(l.Arr().(*fluxarray.Float), r.Arr().(*fluxarray.Float), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicFloat), nil

	case semantic.String:

		var (
			x *fluxarray.String

			err error
		)
		if lvr != nil {
			x, err = fluxarray.StringAddLConst((*lvr).Str(), r.Arr().(*fluxarray.String), mem)
		} else if rvr != nil {
			x, err = fluxarray.StringAddRConst(l.Arr().(*fluxarray.String), (*rvr).Str(), mem)
		} else {
			x, err = fluxarray.StringAdd(l.Arr().(*fluxarray.String), r.Arr().(*fluxarray.String), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicString), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector Add: %v", l.ElementType())
	}
}

func vectorSub(l, r Vector, mem memory.Allocator) (Value, error) {
	var lvr, rvr *Value
	if vr, ok := l.(*VectorRepeatValue); ok {
		lvr = &vr.val
	}
	if vr, ok := r.(*VectorRepeatValue); ok {
		rvr = &vr.val
	}

	if lvr != nil && rvr != nil {
		// XXX: we can handle this case here if we are willing to plumb the
		// OperatorKind through here so we can do the lookup for the row-based version of this op.
		panic("got 2 VectorRepeatValue; 'const folding' should be done earlier, in the function lookup")
	}

	switch l.ElementType().Nature() {

	case semantic.Int:

		var (
			x *fluxarray.Int

			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntSubLConst((*lvr).Int(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntSubRConst(l.Arr().(*fluxarray.Int), (*rvr).Int(), mem)
		} else {
			x, err = fluxarray.IntSub(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicInt), nil

	case semantic.UInt:

		var (
			x *fluxarray.Uint

			err error
		)
		if lvr != nil {
			x, err = fluxarray.UintSubLConst((*lvr).UInt(), r.Arr().(*fluxarray.Uint), mem)
		} else if rvr != nil {
			x, err = fluxarray.UintSubRConst(l.Arr().(*fluxarray.Uint), (*rvr).UInt(), mem)
		} else {
			x, err = fluxarray.UintSub(l.Arr().(*fluxarray.Uint), r.Arr().(*fluxarray.Uint), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicUint), nil

	case semantic.Float:

		var (
			x *fluxarray.Float

			err error
		)
		if lvr != nil {
			x, err = fluxarray.FloatSubLConst((*lvr).Float(), r.Arr().(*fluxarray.Float), mem)
		} else if rvr != nil {
			x, err = fluxarray.FloatSubRConst(l.Arr().(*fluxarray.Float), (*rvr).Float(), mem)
		} else {
			x, err = fluxarray.FloatSub(l.Arr().(*fluxarray.Float), r.Arr().(*fluxarray.Float), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicFloat), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector Sub: %v", l.ElementType())
	}
}

func vectorMul(l, r Vector, mem memory.Allocator) (Value, error) {
	var lvr, rvr *Value
	if vr, ok := l.(*VectorRepeatValue); ok {
		lvr = &vr.val
	}
	if vr, ok := r.(*VectorRepeatValue); ok {
		rvr = &vr.val
	}

	if lvr != nil && rvr != nil {
		// XXX: we can handle this case here if we are willing to plumb the
		// OperatorKind through here so we can do the lookup for the row-based version of this op.
		panic("got 2 VectorRepeatValue; 'const folding' should be done earlier, in the function lookup")
	}

	switch l.ElementType().Nature() {

	case semantic.Int:

		var (
			x *fluxarray.Int

			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntMulLConst((*lvr).Int(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntMulRConst(l.Arr().(*fluxarray.Int), (*rvr).Int(), mem)
		} else {
			x, err = fluxarray.IntMul(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicInt), nil

	case semantic.UInt:

		var (
			x *fluxarray.Uint

			err error
		)
		if lvr != nil {
			x, err = fluxarray.UintMulLConst((*lvr).UInt(), r.Arr().(*fluxarray.Uint), mem)
		} else if rvr != nil {
			x, err = fluxarray.UintMulRConst(l.Arr().(*fluxarray.Uint), (*rvr).UInt(), mem)
		} else {
			x, err = fluxarray.UintMul(l.Arr().(*fluxarray.Uint), r.Arr().(*fluxarray.Uint), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicUint), nil

	case semantic.Float:

		var (
			x *fluxarray.Float

			err error
		)
		if lvr != nil {
			x, err = fluxarray.FloatMulLConst((*lvr).Float(), r.Arr().(*fluxarray.Float), mem)
		} else if rvr != nil {
			x, err = fluxarray.FloatMulRConst(l.Arr().(*fluxarray.Float), (*rvr).Float(), mem)
		} else {
			x, err = fluxarray.FloatMul(l.Arr().(*fluxarray.Float), r.Arr().(*fluxarray.Float), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicFloat), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector Mul: %v", l.ElementType())
	}
}

func vectorDiv(l, r Vector, mem memory.Allocator) (Value, error) {
	var lvr, rvr *Value
	if vr, ok := l.(*VectorRepeatValue); ok {
		lvr = &vr.val
	}
	if vr, ok := r.(*VectorRepeatValue); ok {
		rvr = &vr.val
	}

	if lvr != nil && rvr != nil {
		// XXX: we can handle this case here if we are willing to plumb the
		// OperatorKind through here so we can do the lookup for the row-based version of this op.
		panic("got 2 VectorRepeatValue; 'const folding' should be done earlier, in the function lookup")
	}

	switch l.ElementType().Nature() {

	case semantic.Int:

		var (
			x *fluxarray.Int

			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntDivLConst((*lvr).Int(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntDivRConst(l.Arr().(*fluxarray.Int), (*rvr).Int(), mem)
		} else {
			x, err = fluxarray.IntDiv(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicInt), nil

	case semantic.UInt:

		var (
			x *fluxarray.Uint

			err error
		)
		if lvr != nil {
			x, err = fluxarray.UintDivLConst((*lvr).UInt(), r.Arr().(*fluxarray.Uint), mem)
		} else if rvr != nil {
			x, err = fluxarray.UintDivRConst(l.Arr().(*fluxarray.Uint), (*rvr).UInt(), mem)
		} else {
			x, err = fluxarray.UintDiv(l.Arr().(*fluxarray.Uint), r.Arr().(*fluxarray.Uint), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicUint), nil

	case semantic.Float:

		var (
			x *fluxarray.Float

			err error
		)
		if lvr != nil {
			x, err = fluxarray.FloatDivLConst((*lvr).Float(), r.Arr().(*fluxarray.Float), mem)
		} else if rvr != nil {
			x, err = fluxarray.FloatDivRConst(l.Arr().(*fluxarray.Float), (*rvr).Float(), mem)
		} else {
			x, err = fluxarray.FloatDiv(l.Arr().(*fluxarray.Float), r.Arr().(*fluxarray.Float), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicFloat), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector Div: %v", l.ElementType())
	}
}

func vectorMod(l, r Vector, mem memory.Allocator) (Value, error) {
	var lvr, rvr *Value
	if vr, ok := l.(*VectorRepeatValue); ok {
		lvr = &vr.val
	}
	if vr, ok := r.(*VectorRepeatValue); ok {
		rvr = &vr.val
	}

	if lvr != nil && rvr != nil {
		// XXX: we can handle this case here if we are willing to plumb the
		// OperatorKind through here so we can do the lookup for the row-based version of this op.
		panic("got 2 VectorRepeatValue; 'const folding' should be done earlier, in the function lookup")
	}

	switch l.ElementType().Nature() {

	case semantic.Int:

		var (
			x *fluxarray.Int

			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntModLConst((*lvr).Int(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntModRConst(l.Arr().(*fluxarray.Int), (*rvr).Int(), mem)
		} else {
			x, err = fluxarray.IntMod(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicInt), nil

	case semantic.UInt:

		var (
			x *fluxarray.Uint

			err error
		)
		if lvr != nil {
			x, err = fluxarray.UintModLConst((*lvr).UInt(), r.Arr().(*fluxarray.Uint), mem)
		} else if rvr != nil {
			x, err = fluxarray.UintModRConst(l.Arr().(*fluxarray.Uint), (*rvr).UInt(), mem)
		} else {
			x, err = fluxarray.UintMod(l.Arr().(*fluxarray.Uint), r.Arr().(*fluxarray.Uint), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicUint), nil

	case semantic.Float:

		var (
			x *fluxarray.Float

			err error
		)
		if lvr != nil {
			x, err = fluxarray.FloatModLConst((*lvr).Float(), r.Arr().(*fluxarray.Float), mem)
		} else if rvr != nil {
			x, err = fluxarray.FloatModRConst(l.Arr().(*fluxarray.Float), (*rvr).Float(), mem)
		} else {
			x, err = fluxarray.FloatMod(l.Arr().(*fluxarray.Float), r.Arr().(*fluxarray.Float), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicFloat), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector Mod: %v", l.ElementType())
	}
}

func vectorPow(l, r Vector, mem memory.Allocator) (Value, error) {
	var lvr, rvr *Value
	if vr, ok := l.(*VectorRepeatValue); ok {
		lvr = &vr.val
	}
	if vr, ok := r.(*VectorRepeatValue); ok {
		rvr = &vr.val
	}

	if lvr != nil && rvr != nil {
		// XXX: we can handle this case here if we are willing to plumb the
		// OperatorKind through here so we can do the lookup for the row-based version of this op.
		panic("got 2 VectorRepeatValue; 'const folding' should be done earlier, in the function lookup")
	}

	switch l.ElementType().Nature() {

	case semantic.Int:

		var (
			x *fluxarray.Float

			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntPowLConst((*lvr).Int(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntPowRConst(l.Arr().(*fluxarray.Int), (*rvr).Int(), mem)
		} else {
			x, err = fluxarray.IntPow(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicFloat), nil

	case semantic.UInt:

		var (
			x *fluxarray.Float

			err error
		)
		if lvr != nil {
			x, err = fluxarray.UintPowLConst((*lvr).UInt(), r.Arr().(*fluxarray.Uint), mem)
		} else if rvr != nil {
			x, err = fluxarray.UintPowRConst(l.Arr().(*fluxarray.Uint), (*rvr).UInt(), mem)
		} else {
			x, err = fluxarray.UintPow(l.Arr().(*fluxarray.Uint), r.Arr().(*fluxarray.Uint), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicFloat), nil

	case semantic.Float:

		var (
			x *fluxarray.Float

			err error
		)
		if lvr != nil {
			x, err = fluxarray.FloatPowLConst((*lvr).Float(), r.Arr().(*fluxarray.Float), mem)
		} else if rvr != nil {
			x, err = fluxarray.FloatPowRConst(l.Arr().(*fluxarray.Float), (*rvr).Float(), mem)
		} else {
			x, err = fluxarray.FloatPow(l.Arr().(*fluxarray.Float), r.Arr().(*fluxarray.Float), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicFloat), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector Pow: %v", l.ElementType())
	}
}

func vectorEqual(l, r Vector, mem memory.Allocator) (Value, error) {
	var lvr, rvr *Value
	if vr, ok := l.(*VectorRepeatValue); ok {
		lvr = &vr.val
	}
	if vr, ok := r.(*VectorRepeatValue); ok {
		rvr = &vr.val
	}

	if lvr != nil && rvr != nil {
		// XXX: we can handle this case here if we are willing to plumb the
		// OperatorKind through here so we can do the lookup for the row-based version of this op.
		panic("got 2 VectorRepeatValue; 'const folding' should be done earlier, in the function lookup")
	}

	switch l.ElementType().Nature() {

	case semantic.Time:
		var (
			x   *fluxarray.Boolean
			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntEqualLConst((*lvr).Time().Time().UnixNano(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntEqualRConst(l.Arr().(*fluxarray.Int), (*rvr).Time().Time().UnixNano(), mem)
		} else {
			x, err = fluxarray.IntEqual(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}
		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.Bool:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.BooleanEqualLConst((*lvr).Bool(), r.Arr().(*fluxarray.Boolean), mem)
		} else if rvr != nil {
			x, err = fluxarray.BooleanEqualRConst(l.Arr().(*fluxarray.Boolean), (*rvr).Bool(), mem)
		} else {
			x, err = fluxarray.BooleanEqual(l.Arr().(*fluxarray.Boolean), r.Arr().(*fluxarray.Boolean), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.Int:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntEqualLConst((*lvr).Int(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntEqualRConst(l.Arr().(*fluxarray.Int), (*rvr).Int(), mem)
		} else {
			x, err = fluxarray.IntEqual(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.UInt:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.UintEqualLConst((*lvr).UInt(), r.Arr().(*fluxarray.Uint), mem)
		} else if rvr != nil {
			x, err = fluxarray.UintEqualRConst(l.Arr().(*fluxarray.Uint), (*rvr).UInt(), mem)
		} else {
			x, err = fluxarray.UintEqual(l.Arr().(*fluxarray.Uint), r.Arr().(*fluxarray.Uint), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.Float:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.FloatEqualLConst((*lvr).Float(), r.Arr().(*fluxarray.Float), mem)
		} else if rvr != nil {
			x, err = fluxarray.FloatEqualRConst(l.Arr().(*fluxarray.Float), (*rvr).Float(), mem)
		} else {
			x, err = fluxarray.FloatEqual(l.Arr().(*fluxarray.Float), r.Arr().(*fluxarray.Float), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.String:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.StringEqualLConst((*lvr).Str(), r.Arr().(*fluxarray.String), mem)
		} else if rvr != nil {
			x, err = fluxarray.StringEqualRConst(l.Arr().(*fluxarray.String), (*rvr).Str(), mem)
		} else {
			x, err = fluxarray.StringEqual(l.Arr().(*fluxarray.String), r.Arr().(*fluxarray.String), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector Equal: %v", l.ElementType())
	}
}

func vectorNotEqual(l, r Vector, mem memory.Allocator) (Value, error) {
	var lvr, rvr *Value
	if vr, ok := l.(*VectorRepeatValue); ok {
		lvr = &vr.val
	}
	if vr, ok := r.(*VectorRepeatValue); ok {
		rvr = &vr.val
	}

	if lvr != nil && rvr != nil {
		// XXX: we can handle this case here if we are willing to plumb the
		// OperatorKind through here so we can do the lookup for the row-based version of this op.
		panic("got 2 VectorRepeatValue; 'const folding' should be done earlier, in the function lookup")
	}

	switch l.ElementType().Nature() {

	case semantic.Time:
		var (
			x   *fluxarray.Boolean
			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntNotEqualLConst((*lvr).Time().Time().UnixNano(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntNotEqualRConst(l.Arr().(*fluxarray.Int), (*rvr).Time().Time().UnixNano(), mem)
		} else {
			x, err = fluxarray.IntNotEqual(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}
		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.Bool:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.BooleanNotEqualLConst((*lvr).Bool(), r.Arr().(*fluxarray.Boolean), mem)
		} else if rvr != nil {
			x, err = fluxarray.BooleanNotEqualRConst(l.Arr().(*fluxarray.Boolean), (*rvr).Bool(), mem)
		} else {
			x, err = fluxarray.BooleanNotEqual(l.Arr().(*fluxarray.Boolean), r.Arr().(*fluxarray.Boolean), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.Int:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntNotEqualLConst((*lvr).Int(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntNotEqualRConst(l.Arr().(*fluxarray.Int), (*rvr).Int(), mem)
		} else {
			x, err = fluxarray.IntNotEqual(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.UInt:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.UintNotEqualLConst((*lvr).UInt(), r.Arr().(*fluxarray.Uint), mem)
		} else if rvr != nil {
			x, err = fluxarray.UintNotEqualRConst(l.Arr().(*fluxarray.Uint), (*rvr).UInt(), mem)
		} else {
			x, err = fluxarray.UintNotEqual(l.Arr().(*fluxarray.Uint), r.Arr().(*fluxarray.Uint), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.Float:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.FloatNotEqualLConst((*lvr).Float(), r.Arr().(*fluxarray.Float), mem)
		} else if rvr != nil {
			x, err = fluxarray.FloatNotEqualRConst(l.Arr().(*fluxarray.Float), (*rvr).Float(), mem)
		} else {
			x, err = fluxarray.FloatNotEqual(l.Arr().(*fluxarray.Float), r.Arr().(*fluxarray.Float), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.String:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.StringNotEqualLConst((*lvr).Str(), r.Arr().(*fluxarray.String), mem)
		} else if rvr != nil {
			x, err = fluxarray.StringNotEqualRConst(l.Arr().(*fluxarray.String), (*rvr).Str(), mem)
		} else {
			x, err = fluxarray.StringNotEqual(l.Arr().(*fluxarray.String), r.Arr().(*fluxarray.String), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector NotEqual: %v", l.ElementType())
	}
}

func vectorLessThan(l, r Vector, mem memory.Allocator) (Value, error) {
	var lvr, rvr *Value
	if vr, ok := l.(*VectorRepeatValue); ok {
		lvr = &vr.val
	}
	if vr, ok := r.(*VectorRepeatValue); ok {
		rvr = &vr.val
	}

	if lvr != nil && rvr != nil {
		// XXX: we can handle this case here if we are willing to plumb the
		// OperatorKind through here so we can do the lookup for the row-based version of this op.
		panic("got 2 VectorRepeatValue; 'const folding' should be done earlier, in the function lookup")
	}

	switch l.ElementType().Nature() {

	case semantic.Time:
		var (
			x   *fluxarray.Boolean
			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntLessThanLConst((*lvr).Time().Time().UnixNano(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntLessThanRConst(l.Arr().(*fluxarray.Int), (*rvr).Time().Time().UnixNano(), mem)
		} else {
			x, err = fluxarray.IntLessThan(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}
		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.Int:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntLessThanLConst((*lvr).Int(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntLessThanRConst(l.Arr().(*fluxarray.Int), (*rvr).Int(), mem)
		} else {
			x, err = fluxarray.IntLessThan(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.UInt:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.UintLessThanLConst((*lvr).UInt(), r.Arr().(*fluxarray.Uint), mem)
		} else if rvr != nil {
			x, err = fluxarray.UintLessThanRConst(l.Arr().(*fluxarray.Uint), (*rvr).UInt(), mem)
		} else {
			x, err = fluxarray.UintLessThan(l.Arr().(*fluxarray.Uint), r.Arr().(*fluxarray.Uint), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.Float:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.FloatLessThanLConst((*lvr).Float(), r.Arr().(*fluxarray.Float), mem)
		} else if rvr != nil {
			x, err = fluxarray.FloatLessThanRConst(l.Arr().(*fluxarray.Float), (*rvr).Float(), mem)
		} else {
			x, err = fluxarray.FloatLessThan(l.Arr().(*fluxarray.Float), r.Arr().(*fluxarray.Float), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.String:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.StringLessThanLConst((*lvr).Str(), r.Arr().(*fluxarray.String), mem)
		} else if rvr != nil {
			x, err = fluxarray.StringLessThanRConst(l.Arr().(*fluxarray.String), (*rvr).Str(), mem)
		} else {
			x, err = fluxarray.StringLessThan(l.Arr().(*fluxarray.String), r.Arr().(*fluxarray.String), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector LessThan: %v", l.ElementType())
	}
}

func vectorLessThanEqual(l, r Vector, mem memory.Allocator) (Value, error) {
	var lvr, rvr *Value
	if vr, ok := l.(*VectorRepeatValue); ok {
		lvr = &vr.val
	}
	if vr, ok := r.(*VectorRepeatValue); ok {
		rvr = &vr.val
	}

	if lvr != nil && rvr != nil {
		// XXX: we can handle this case here if we are willing to plumb the
		// OperatorKind through here so we can do the lookup for the row-based version of this op.
		panic("got 2 VectorRepeatValue; 'const folding' should be done earlier, in the function lookup")
	}

	switch l.ElementType().Nature() {

	case semantic.Time:
		var (
			x   *fluxarray.Boolean
			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntLessThanEqualLConst((*lvr).Time().Time().UnixNano(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntLessThanEqualRConst(l.Arr().(*fluxarray.Int), (*rvr).Time().Time().UnixNano(), mem)
		} else {
			x, err = fluxarray.IntLessThanEqual(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}
		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.Int:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntLessThanEqualLConst((*lvr).Int(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntLessThanEqualRConst(l.Arr().(*fluxarray.Int), (*rvr).Int(), mem)
		} else {
			x, err = fluxarray.IntLessThanEqual(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.UInt:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.UintLessThanEqualLConst((*lvr).UInt(), r.Arr().(*fluxarray.Uint), mem)
		} else if rvr != nil {
			x, err = fluxarray.UintLessThanEqualRConst(l.Arr().(*fluxarray.Uint), (*rvr).UInt(), mem)
		} else {
			x, err = fluxarray.UintLessThanEqual(l.Arr().(*fluxarray.Uint), r.Arr().(*fluxarray.Uint), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.Float:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.FloatLessThanEqualLConst((*lvr).Float(), r.Arr().(*fluxarray.Float), mem)
		} else if rvr != nil {
			x, err = fluxarray.FloatLessThanEqualRConst(l.Arr().(*fluxarray.Float), (*rvr).Float(), mem)
		} else {
			x, err = fluxarray.FloatLessThanEqual(l.Arr().(*fluxarray.Float), r.Arr().(*fluxarray.Float), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.String:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.StringLessThanEqualLConst((*lvr).Str(), r.Arr().(*fluxarray.String), mem)
		} else if rvr != nil {
			x, err = fluxarray.StringLessThanEqualRConst(l.Arr().(*fluxarray.String), (*rvr).Str(), mem)
		} else {
			x, err = fluxarray.StringLessThanEqual(l.Arr().(*fluxarray.String), r.Arr().(*fluxarray.String), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector LessThanEqual: %v", l.ElementType())
	}
}

func vectorGreaterThan(l, r Vector, mem memory.Allocator) (Value, error) {
	var lvr, rvr *Value
	if vr, ok := l.(*VectorRepeatValue); ok {
		lvr = &vr.val
	}
	if vr, ok := r.(*VectorRepeatValue); ok {
		rvr = &vr.val
	}

	if lvr != nil && rvr != nil {
		// XXX: we can handle this case here if we are willing to plumb the
		// OperatorKind through here so we can do the lookup for the row-based version of this op.
		panic("got 2 VectorRepeatValue; 'const folding' should be done earlier, in the function lookup")
	}

	switch l.ElementType().Nature() {

	case semantic.Time:
		var (
			x   *fluxarray.Boolean
			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntGreaterThanLConst((*lvr).Time().Time().UnixNano(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntGreaterThanRConst(l.Arr().(*fluxarray.Int), (*rvr).Time().Time().UnixNano(), mem)
		} else {
			x, err = fluxarray.IntGreaterThan(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}
		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.Int:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntGreaterThanLConst((*lvr).Int(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntGreaterThanRConst(l.Arr().(*fluxarray.Int), (*rvr).Int(), mem)
		} else {
			x, err = fluxarray.IntGreaterThan(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.UInt:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.UintGreaterThanLConst((*lvr).UInt(), r.Arr().(*fluxarray.Uint), mem)
		} else if rvr != nil {
			x, err = fluxarray.UintGreaterThanRConst(l.Arr().(*fluxarray.Uint), (*rvr).UInt(), mem)
		} else {
			x, err = fluxarray.UintGreaterThan(l.Arr().(*fluxarray.Uint), r.Arr().(*fluxarray.Uint), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.Float:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.FloatGreaterThanLConst((*lvr).Float(), r.Arr().(*fluxarray.Float), mem)
		} else if rvr != nil {
			x, err = fluxarray.FloatGreaterThanRConst(l.Arr().(*fluxarray.Float), (*rvr).Float(), mem)
		} else {
			x, err = fluxarray.FloatGreaterThan(l.Arr().(*fluxarray.Float), r.Arr().(*fluxarray.Float), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.String:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.StringGreaterThanLConst((*lvr).Str(), r.Arr().(*fluxarray.String), mem)
		} else if rvr != nil {
			x, err = fluxarray.StringGreaterThanRConst(l.Arr().(*fluxarray.String), (*rvr).Str(), mem)
		} else {
			x, err = fluxarray.StringGreaterThan(l.Arr().(*fluxarray.String), r.Arr().(*fluxarray.String), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector GreaterThan: %v", l.ElementType())
	}
}

func vectorGreaterThanEqual(l, r Vector, mem memory.Allocator) (Value, error) {
	var lvr, rvr *Value
	if vr, ok := l.(*VectorRepeatValue); ok {
		lvr = &vr.val
	}
	if vr, ok := r.(*VectorRepeatValue); ok {
		rvr = &vr.val
	}

	if lvr != nil && rvr != nil {
		// XXX: we can handle this case here if we are willing to plumb the
		// OperatorKind through here so we can do the lookup for the row-based version of this op.
		panic("got 2 VectorRepeatValue; 'const folding' should be done earlier, in the function lookup")
	}

	switch l.ElementType().Nature() {

	case semantic.Time:
		var (
			x   *fluxarray.Boolean
			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntGreaterThanEqualLConst((*lvr).Time().Time().UnixNano(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntGreaterThanEqualRConst(l.Arr().(*fluxarray.Int), (*rvr).Time().Time().UnixNano(), mem)
		} else {
			x, err = fluxarray.IntGreaterThanEqual(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}
		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.Int:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.IntGreaterThanEqualLConst((*lvr).Int(), r.Arr().(*fluxarray.Int), mem)
		} else if rvr != nil {
			x, err = fluxarray.IntGreaterThanEqualRConst(l.Arr().(*fluxarray.Int), (*rvr).Int(), mem)
		} else {
			x, err = fluxarray.IntGreaterThanEqual(l.Arr().(*fluxarray.Int), r.Arr().(*fluxarray.Int), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.UInt:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.UintGreaterThanEqualLConst((*lvr).UInt(), r.Arr().(*fluxarray.Uint), mem)
		} else if rvr != nil {
			x, err = fluxarray.UintGreaterThanEqualRConst(l.Arr().(*fluxarray.Uint), (*rvr).UInt(), mem)
		} else {
			x, err = fluxarray.UintGreaterThanEqual(l.Arr().(*fluxarray.Uint), r.Arr().(*fluxarray.Uint), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.Float:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.FloatGreaterThanEqualLConst((*lvr).Float(), r.Arr().(*fluxarray.Float), mem)
		} else if rvr != nil {
			x, err = fluxarray.FloatGreaterThanEqualRConst(l.Arr().(*fluxarray.Float), (*rvr).Float(), mem)
		} else {
			x, err = fluxarray.FloatGreaterThanEqual(l.Arr().(*fluxarray.Float), r.Arr().(*fluxarray.Float), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	case semantic.String:

		var (
			x *fluxarray.Boolean

			err error
		)
		if lvr != nil {
			x, err = fluxarray.StringGreaterThanEqualLConst((*lvr).Str(), r.Arr().(*fluxarray.String), mem)
		} else if rvr != nil {
			x, err = fluxarray.StringGreaterThanEqualRConst(l.Arr().(*fluxarray.String), (*rvr).Str(), mem)
		} else {
			x, err = fluxarray.StringGreaterThanEqual(l.Arr().(*fluxarray.String), r.Arr().(*fluxarray.String), mem)
		}

		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicBool), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector GreaterThanEqual: %v", l.ElementType())
	}
}

// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: binary.gen.go.tmpl

package values

import (
	"github.com/apache/arrow/go/v7/arrow/memory"
	fluxarray "github.com/influxdata/flux/array"
	"github.com/influxdata/flux/codes"
	"github.com/influxdata/flux/internal/errors"
	"github.com/influxdata/flux/semantic"
)

func vectorAdd(l, r Vector, mem memory.Allocator) (Value, error) {
	switch l.ElementType().Nature() {

	case semantic.Int:

		var lal, ral fluxarray.IntArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.IntArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Int)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.IntArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Int)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.IntAdd
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.IntAdd(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicInt), nil

	case semantic.UInt:

		var lal, ral fluxarray.UintArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.UintArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Uint)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.UintArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Uint)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.UintAdd
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.UintAdd(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicUint), nil

	case semantic.Float:

		var lal, ral fluxarray.FloatArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.FloatArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Float)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.FloatArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Float)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.FloatAdd
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.FloatAdd(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicFloat), nil

	case semantic.String:

		var lal, ral fluxarray.StringArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.StringArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.String)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.StringArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.String)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.StringAdd
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.StringAdd(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicString), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector Add: %v", l.ElementType())
	}
}

func vectorSub(l, r Vector, mem memory.Allocator) (Value, error) {
	switch l.ElementType().Nature() {

	case semantic.Int:

		var lal, ral fluxarray.IntArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.IntArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Int)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.IntArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Int)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.IntSub
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.IntSub(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicInt), nil

	case semantic.UInt:

		var lal, ral fluxarray.UintArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.UintArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Uint)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.UintArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Uint)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.UintSub
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.UintSub(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicUint), nil

	case semantic.Float:

		var lal, ral fluxarray.FloatArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.FloatArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Float)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.FloatArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Float)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.FloatSub
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.FloatSub(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicFloat), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector Sub: %v", l.ElementType())
	}
}

func vectorMul(l, r Vector, mem memory.Allocator) (Value, error) {
	switch l.ElementType().Nature() {

	case semantic.Int:

		var lal, ral fluxarray.IntArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.IntArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Int)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.IntArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Int)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.IntMul
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.IntMul(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicInt), nil

	case semantic.UInt:

		var lal, ral fluxarray.UintArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.UintArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Uint)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.UintArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Uint)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.UintMul
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.UintMul(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicUint), nil

	case semantic.Float:

		var lal, ral fluxarray.FloatArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.FloatArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Float)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.FloatArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Float)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.FloatMul
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.FloatMul(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicFloat), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector Mul: %v", l.ElementType())
	}
}

func vectorDiv(l, r Vector, mem memory.Allocator) (Value, error) {
	switch l.ElementType().Nature() {

	case semantic.Int:

		var lal, ral fluxarray.IntArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.IntArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Int)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.IntArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Int)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.IntDiv
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.IntDiv(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicInt), nil

	case semantic.UInt:

		var lal, ral fluxarray.UintArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.UintArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Uint)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.UintArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Uint)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.UintDiv
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.UintDiv(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicUint), nil

	case semantic.Float:

		var lal, ral fluxarray.FloatArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.FloatArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Float)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.FloatArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Float)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.FloatDiv
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.FloatDiv(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicFloat), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector Div: %v", l.ElementType())
	}
}

func vectorMod(l, r Vector, mem memory.Allocator) (Value, error) {
	switch l.ElementType().Nature() {

	case semantic.Int:

		var lal, ral fluxarray.IntArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.IntArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Int)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.IntArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Int)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.IntMod
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.IntMod(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicInt), nil

	case semantic.UInt:

		var lal, ral fluxarray.UintArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.UintArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Uint)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.UintArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Uint)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.UintMod
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.UintMod(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicUint), nil

	case semantic.Float:

		var lal, ral fluxarray.FloatArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.FloatArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Float)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.FloatArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Float)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.FloatMod
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.FloatMod(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicFloat), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector Mod: %v", l.ElementType())
	}
}

func vectorPow(l, r Vector, mem memory.Allocator) (Value, error) {
	switch l.ElementType().Nature() {

	case semantic.Int:

		var lal, ral fluxarray.IntArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.IntArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Int)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.IntArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Int)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.IntPow
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.IntPow(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicFloat), nil

	case semantic.UInt:

		var lal, ral fluxarray.UintArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.UintArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Uint)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.UintArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Uint)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.UintPow
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.UintPow(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicFloat), nil

	case semantic.Float:

		var lal, ral fluxarray.FloatArrLike
		vrCount := 0
		if vecRepeat, ok := l.(*vectorRepeatValue); ok {
			lal = vecRepeat.FloatArrLike()
			vrCount += 1
		} else {
			lal = l.Arr().(*fluxarray.Float)
		}

		if vecRepeat, ok := r.(*vectorRepeatValue); ok {
			ral = vecRepeat.FloatArrLike()
			vrCount += 1
		} else {
			ral = r.Arr().(*fluxarray.Float)
		}

		// When we have 2 vec repeats, we're talking about constant folding which
		// will lead to a panic in funcs like fluxarray.FloatPow
		// N.b. Until const folding is implemented, the rust side should take
		// steps to refuse to vectorize expressions that land us in this code path.
		if vrCount == 2 {
			// FIXME: perform the op directly on the 2 constants here and return a new vecRepeat
			panic("TODO: const folding")
		}

		x, err := fluxarray.FloatPow(lal, ral, mem)
		if err != nil {
			return nil, err
		}

		return NewVectorValue(x, semantic.BasicFloat), nil

	default:
		return nil, errors.Newf(codes.Invalid, "unsupported type for vector Pow: %v", l.ElementType())
	}
}

// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod fbsemantic {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_MONO_TYPE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_MONO_TYPE: u8 = 7;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_MONO_TYPE: [MonoType; 8] = [
        MonoType::NONE,
        MonoType::Basic,
        MonoType::Var,
        MonoType::Arr,
        MonoType::Record,
        MonoType::Fun,
        MonoType::Dict,
        MonoType::Vector,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct MonoType(pub u8);
    #[allow(non_upper_case_globals)]
    impl MonoType {
        pub const NONE: Self = Self(0);
        pub const Basic: Self = Self(1);
        pub const Var: Self = Self(2);
        pub const Arr: Self = Self(3);
        pub const Record: Self = Self(4);
        pub const Fun: Self = Self(5);
        pub const Dict: Self = Self(6);
        pub const Vector: Self = Self(7);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 7;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::Basic,
            Self::Var,
            Self::Arr,
            Self::Record,
            Self::Fun,
            Self::Dict,
            Self::Vector,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::Basic => Some("Basic"),
                Self::Var => Some("Var"),
                Self::Arr => Some("Arr"),
                Self::Record => Some("Record"),
                Self::Fun => Some("Fun"),
                Self::Dict => Some("Dict"),
                Self::Vector => Some("Vector"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for MonoType {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for MonoType {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for MonoType {
        type Output = MonoType;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for MonoType {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for MonoType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for MonoType {}
    pub struct MonoTypeUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_TYPE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_TYPE: u8 = 8;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_TYPE: [Type; 9] = [
        Type::Bool,
        Type::Int,
        Type::Uint,
        Type::Float,
        Type::String,
        Type::Duration,
        Type::Time,
        Type::Regexp,
        Type::Bytes,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct Type(pub u8);
    #[allow(non_upper_case_globals)]
    impl Type {
        pub const Bool: Self = Self(0);
        pub const Int: Self = Self(1);
        pub const Uint: Self = Self(2);
        pub const Float: Self = Self(3);
        pub const String: Self = Self(4);
        pub const Duration: Self = Self(5);
        pub const Time: Self = Self(6);
        pub const Regexp: Self = Self(7);
        pub const Bytes: Self = Self(8);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 8;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::Bool,
            Self::Int,
            Self::Uint,
            Self::Float,
            Self::String,
            Self::Duration,
            Self::Time,
            Self::Regexp,
            Self::Bytes,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Bool => Some("Bool"),
                Self::Int => Some("Int"),
                Self::Uint => Some("Uint"),
                Self::Float => Some("Float"),
                Self::String => Some("String"),
                Self::Duration => Some("Duration"),
                Self::Time => Some("Time"),
                Self::Regexp => Some("Regexp"),
                Self::Bytes => Some("Bytes"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for Type {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for Type {
        type Output = Type;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for Type {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for Type {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Type {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_KIND: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_KIND: u8 = 10;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_KIND: [Kind; 11] = [
        Kind::Addable,
        Kind::Subtractable,
        Kind::Divisible,
        Kind::Numeric,
        Kind::Comparable,
        Kind::Equatable,
        Kind::Nullable,
        Kind::Record,
        Kind::Negatable,
        Kind::Timeable,
        Kind::Stringable,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct Kind(pub u8);
    #[allow(non_upper_case_globals)]
    impl Kind {
        pub const Addable: Self = Self(0);
        pub const Subtractable: Self = Self(1);
        pub const Divisible: Self = Self(2);
        pub const Numeric: Self = Self(3);
        pub const Comparable: Self = Self(4);
        pub const Equatable: Self = Self(5);
        pub const Nullable: Self = Self(6);
        pub const Record: Self = Self(7);
        pub const Negatable: Self = Self(8);
        pub const Timeable: Self = Self(9);
        pub const Stringable: Self = Self(10);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 10;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::Addable,
            Self::Subtractable,
            Self::Divisible,
            Self::Numeric,
            Self::Comparable,
            Self::Equatable,
            Self::Nullable,
            Self::Record,
            Self::Negatable,
            Self::Timeable,
            Self::Stringable,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Addable => Some("Addable"),
                Self::Subtractable => Some("Subtractable"),
                Self::Divisible => Some("Divisible"),
                Self::Numeric => Some("Numeric"),
                Self::Comparable => Some("Comparable"),
                Self::Equatable => Some("Equatable"),
                Self::Nullable => Some("Nullable"),
                Self::Record => Some("Record"),
                Self::Negatable => Some("Negatable"),
                Self::Timeable => Some("Timeable"),
                Self::Stringable => Some("Stringable"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for Kind {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for Kind {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for Kind {
        type Output = Kind;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for Kind {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for Kind {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Kind {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_STATEMENT: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_STATEMENT: u8 = 7;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_STATEMENT: [Statement; 8] = [
        Statement::NONE,
        Statement::OptionStatement,
        Statement::BuiltinStatement,
        Statement::TestStatement,
        Statement::ExpressionStatement,
        Statement::NativeVariableAssignment,
        Statement::MemberAssignment,
        Statement::ReturnStatement,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct Statement(pub u8);
    #[allow(non_upper_case_globals)]
    impl Statement {
        pub const NONE: Self = Self(0);
        pub const OptionStatement: Self = Self(1);
        pub const BuiltinStatement: Self = Self(2);
        pub const TestStatement: Self = Self(3);
        pub const ExpressionStatement: Self = Self(4);
        pub const NativeVariableAssignment: Self = Self(5);
        pub const MemberAssignment: Self = Self(6);
        pub const ReturnStatement: Self = Self(7);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 7;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::OptionStatement,
            Self::BuiltinStatement,
            Self::TestStatement,
            Self::ExpressionStatement,
            Self::NativeVariableAssignment,
            Self::MemberAssignment,
            Self::ReturnStatement,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::OptionStatement => Some("OptionStatement"),
                Self::BuiltinStatement => Some("BuiltinStatement"),
                Self::TestStatement => Some("TestStatement"),
                Self::ExpressionStatement => Some("ExpressionStatement"),
                Self::NativeVariableAssignment => Some("NativeVariableAssignment"),
                Self::MemberAssignment => Some("MemberAssignment"),
                Self::ReturnStatement => Some("ReturnStatement"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for Statement {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for Statement {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for Statement {
        type Output = Statement;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for Statement {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for Statement {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Statement {}
    pub struct StatementUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_ASSIGNMENT: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_ASSIGNMENT: u8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_ASSIGNMENT: [Assignment; 3] = [
        Assignment::NONE,
        Assignment::MemberAssignment,
        Assignment::NativeVariableAssignment,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct Assignment(pub u8);
    #[allow(non_upper_case_globals)]
    impl Assignment {
        pub const NONE: Self = Self(0);
        pub const MemberAssignment: Self = Self(1);
        pub const NativeVariableAssignment: Self = Self(2);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::MemberAssignment,
            Self::NativeVariableAssignment,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::MemberAssignment => Some("MemberAssignment"),
                Self::NativeVariableAssignment => Some("NativeVariableAssignment"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for Assignment {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for Assignment {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for Assignment {
        type Output = Assignment;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for Assignment {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for Assignment {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Assignment {}
    pub struct AssignmentUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_EXPRESSION: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_EXPRESSION: u8 = 21;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_EXPRESSION: [Expression; 22] = [
        Expression::NONE,
        Expression::StringExpression,
        Expression::ArrayExpression,
        Expression::DictExpression,
        Expression::FunctionExpression,
        Expression::BinaryExpression,
        Expression::CallExpression,
        Expression::ConditionalExpression,
        Expression::IdentifierExpression,
        Expression::LogicalExpression,
        Expression::MemberExpression,
        Expression::IndexExpression,
        Expression::ObjectExpression,
        Expression::UnaryExpression,
        Expression::BooleanLiteral,
        Expression::DateTimeLiteral,
        Expression::DurationLiteral,
        Expression::FloatLiteral,
        Expression::IntegerLiteral,
        Expression::StringLiteral,
        Expression::RegexpLiteral,
        Expression::UnsignedIntegerLiteral,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct Expression(pub u8);
    #[allow(non_upper_case_globals)]
    impl Expression {
        pub const NONE: Self = Self(0);
        pub const StringExpression: Self = Self(1);
        pub const ArrayExpression: Self = Self(2);
        pub const DictExpression: Self = Self(3);
        pub const FunctionExpression: Self = Self(4);
        pub const BinaryExpression: Self = Self(5);
        pub const CallExpression: Self = Self(6);
        pub const ConditionalExpression: Self = Self(7);
        pub const IdentifierExpression: Self = Self(8);
        pub const LogicalExpression: Self = Self(9);
        pub const MemberExpression: Self = Self(10);
        pub const IndexExpression: Self = Self(11);
        pub const ObjectExpression: Self = Self(12);
        pub const UnaryExpression: Self = Self(13);
        pub const BooleanLiteral: Self = Self(14);
        pub const DateTimeLiteral: Self = Self(15);
        pub const DurationLiteral: Self = Self(16);
        pub const FloatLiteral: Self = Self(17);
        pub const IntegerLiteral: Self = Self(18);
        pub const StringLiteral: Self = Self(19);
        pub const RegexpLiteral: Self = Self(20);
        pub const UnsignedIntegerLiteral: Self = Self(21);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 21;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::StringExpression,
            Self::ArrayExpression,
            Self::DictExpression,
            Self::FunctionExpression,
            Self::BinaryExpression,
            Self::CallExpression,
            Self::ConditionalExpression,
            Self::IdentifierExpression,
            Self::LogicalExpression,
            Self::MemberExpression,
            Self::IndexExpression,
            Self::ObjectExpression,
            Self::UnaryExpression,
            Self::BooleanLiteral,
            Self::DateTimeLiteral,
            Self::DurationLiteral,
            Self::FloatLiteral,
            Self::IntegerLiteral,
            Self::StringLiteral,
            Self::RegexpLiteral,
            Self::UnsignedIntegerLiteral,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::StringExpression => Some("StringExpression"),
                Self::ArrayExpression => Some("ArrayExpression"),
                Self::DictExpression => Some("DictExpression"),
                Self::FunctionExpression => Some("FunctionExpression"),
                Self::BinaryExpression => Some("BinaryExpression"),
                Self::CallExpression => Some("CallExpression"),
                Self::ConditionalExpression => Some("ConditionalExpression"),
                Self::IdentifierExpression => Some("IdentifierExpression"),
                Self::LogicalExpression => Some("LogicalExpression"),
                Self::MemberExpression => Some("MemberExpression"),
                Self::IndexExpression => Some("IndexExpression"),
                Self::ObjectExpression => Some("ObjectExpression"),
                Self::UnaryExpression => Some("UnaryExpression"),
                Self::BooleanLiteral => Some("BooleanLiteral"),
                Self::DateTimeLiteral => Some("DateTimeLiteral"),
                Self::DurationLiteral => Some("DurationLiteral"),
                Self::FloatLiteral => Some("FloatLiteral"),
                Self::IntegerLiteral => Some("IntegerLiteral"),
                Self::StringLiteral => Some("StringLiteral"),
                Self::RegexpLiteral => Some("RegexpLiteral"),
                Self::UnsignedIntegerLiteral => Some("UnsignedIntegerLiteral"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for Expression {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for Expression {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for Expression {
        type Output = Expression;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for Expression {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for Expression {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Expression {}
    pub struct ExpressionUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_OPERATOR: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_OPERATOR: i8 = 20;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_OPERATOR: [Operator; 21] = [
        Operator::MultiplicationOperator,
        Operator::DivisionOperator,
        Operator::ModuloOperator,
        Operator::PowerOperator,
        Operator::AdditionOperator,
        Operator::SubtractionOperator,
        Operator::LessThanEqualOperator,
        Operator::LessThanOperator,
        Operator::GreaterThanEqualOperator,
        Operator::GreaterThanOperator,
        Operator::StartsWithOperator,
        Operator::InOperator,
        Operator::NotOperator,
        Operator::ExistsOperator,
        Operator::NotEmptyOperator,
        Operator::EmptyOperator,
        Operator::EqualOperator,
        Operator::NotEqualOperator,
        Operator::RegexpMatchOperator,
        Operator::NotRegexpMatchOperator,
        Operator::InvalidOperator,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct Operator(pub i8);
    #[allow(non_upper_case_globals)]
    impl Operator {
        pub const MultiplicationOperator: Self = Self(0);
        pub const DivisionOperator: Self = Self(1);
        pub const ModuloOperator: Self = Self(2);
        pub const PowerOperator: Self = Self(3);
        pub const AdditionOperator: Self = Self(4);
        pub const SubtractionOperator: Self = Self(5);
        pub const LessThanEqualOperator: Self = Self(6);
        pub const LessThanOperator: Self = Self(7);
        pub const GreaterThanEqualOperator: Self = Self(8);
        pub const GreaterThanOperator: Self = Self(9);
        pub const StartsWithOperator: Self = Self(10);
        pub const InOperator: Self = Self(11);
        pub const NotOperator: Self = Self(12);
        pub const ExistsOperator: Self = Self(13);
        pub const NotEmptyOperator: Self = Self(14);
        pub const EmptyOperator: Self = Self(15);
        pub const EqualOperator: Self = Self(16);
        pub const NotEqualOperator: Self = Self(17);
        pub const RegexpMatchOperator: Self = Self(18);
        pub const NotRegexpMatchOperator: Self = Self(19);
        pub const InvalidOperator: Self = Self(20);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 20;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::MultiplicationOperator,
            Self::DivisionOperator,
            Self::ModuloOperator,
            Self::PowerOperator,
            Self::AdditionOperator,
            Self::SubtractionOperator,
            Self::LessThanEqualOperator,
            Self::LessThanOperator,
            Self::GreaterThanEqualOperator,
            Self::GreaterThanOperator,
            Self::StartsWithOperator,
            Self::InOperator,
            Self::NotOperator,
            Self::ExistsOperator,
            Self::NotEmptyOperator,
            Self::EmptyOperator,
            Self::EqualOperator,
            Self::NotEqualOperator,
            Self::RegexpMatchOperator,
            Self::NotRegexpMatchOperator,
            Self::InvalidOperator,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::MultiplicationOperator => Some("MultiplicationOperator"),
                Self::DivisionOperator => Some("DivisionOperator"),
                Self::ModuloOperator => Some("ModuloOperator"),
                Self::PowerOperator => Some("PowerOperator"),
                Self::AdditionOperator => Some("AdditionOperator"),
                Self::SubtractionOperator => Some("SubtractionOperator"),
                Self::LessThanEqualOperator => Some("LessThanEqualOperator"),
                Self::LessThanOperator => Some("LessThanOperator"),
                Self::GreaterThanEqualOperator => Some("GreaterThanEqualOperator"),
                Self::GreaterThanOperator => Some("GreaterThanOperator"),
                Self::StartsWithOperator => Some("StartsWithOperator"),
                Self::InOperator => Some("InOperator"),
                Self::NotOperator => Some("NotOperator"),
                Self::ExistsOperator => Some("ExistsOperator"),
                Self::NotEmptyOperator => Some("NotEmptyOperator"),
                Self::EmptyOperator => Some("EmptyOperator"),
                Self::EqualOperator => Some("EqualOperator"),
                Self::NotEqualOperator => Some("NotEqualOperator"),
                Self::RegexpMatchOperator => Some("RegexpMatchOperator"),
                Self::NotRegexpMatchOperator => Some("NotRegexpMatchOperator"),
                Self::InvalidOperator => Some("InvalidOperator"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for Operator {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for Operator {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for Operator {
        type Output = Operator;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for Operator {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = i8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = i8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for Operator {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Operator {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_LOGICAL_OPERATOR: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_LOGICAL_OPERATOR: i8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_LOGICAL_OPERATOR: [LogicalOperator; 2] =
        [LogicalOperator::AndOperator, LogicalOperator::OrOperator];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct LogicalOperator(pub i8);
    #[allow(non_upper_case_globals)]
    impl LogicalOperator {
        pub const AndOperator: Self = Self(0);
        pub const OrOperator: Self = Self(1);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::AndOperator, Self::OrOperator];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::AndOperator => Some("AndOperator"),
                Self::OrOperator => Some("OrOperator"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for LogicalOperator {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for LogicalOperator {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for LogicalOperator {
        type Output = LogicalOperator;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for LogicalOperator {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = i8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = i8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for LogicalOperator {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for LogicalOperator {}
    // struct Position, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Position(pub [u8; 8]);
    impl Default for Position {
        fn default() -> Self {
            Self([0; 8])
        }
    }
    impl std::fmt::Debug for Position {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("Position")
                .field("line", &self.line())
                .field("column", &self.column())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Position {}
    impl flatbuffers::SafeSliceAccess for Position {}
    impl<'a> flatbuffers::Follow<'a> for Position {
        type Inner = &'a Position;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Position>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Position {
        type Inner = &'a Position;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Position>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Position {
        type Output = Position;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(self as *const Position as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }
    impl<'b> flatbuffers::Push for &'b Position {
        type Output = Position;

        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(*self as *const Position as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for Position {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }
    impl<'a> Position {
        #[allow(clippy::too_many_arguments)]
        pub fn new(line: i32, column: i32) -> Self {
            let mut s = Self([0; 8]);
            s.set_line(line);
            s.set_column(column);
            s
        }

        pub fn line(&self) -> i32 {
            let mut mem = core::mem::MaybeUninit::<i32>::uninit();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<i32>(),
                );
                mem.assume_init()
            }
            .from_little_endian()
        }

        pub fn set_line(&mut self, x: i32) {
            let x_le = x.to_little_endian();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const i32 as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<i32>(),
                );
            }
        }

        pub fn column(&self) -> i32 {
            let mut mem = core::mem::MaybeUninit::<i32>::uninit();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<i32>(),
                );
                mem.assume_init()
            }
            .from_little_endian()
        }

        pub fn set_column(&mut self, x: i32) {
            let x_le = x.to_little_endian();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const i32 as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<i32>(),
                );
            }
        }
    }

    pub enum FresherOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Fresher<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Fresher<'a> {
        type Inner = Fresher<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Fresher<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Fresher { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FresherArgs,
        ) -> flatbuffers::WIPOffset<Fresher<'bldr>> {
            let mut builder = FresherBuilder::new(_fbb);
            builder.add_u(args.u);
            builder.finish()
        }

        pub const VT_U: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn u(&self) -> u64 {
            self._tab.get::<u64>(Fresher::VT_U, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for Fresher<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>(&"u", Self::VT_U, false)?
                .finish();
            Ok(())
        }
    }
    pub struct FresherArgs {
        pub u: u64,
    }
    impl<'a> Default for FresherArgs {
        #[inline]
        fn default() -> Self {
            FresherArgs { u: 0 }
        }
    }
    pub struct FresherBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FresherBuilder<'a, 'b> {
        #[inline]
        pub fn add_u(&mut self, u: u64) {
            self.fbb_.push_slot::<u64>(Fresher::VT_U, u, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FresherBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FresherBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Fresher<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Fresher<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Fresher");
            ds.field("u", &self.u());
            ds.finish()
        }
    }
    pub enum TypeEnvironmentOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TypeEnvironment<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TypeEnvironment<'a> {
        type Inner = TypeEnvironment<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> TypeEnvironment<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TypeEnvironment { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TypeEnvironmentArgs<'args>,
        ) -> flatbuffers::WIPOffset<TypeEnvironment<'bldr>> {
            let mut builder = TypeEnvironmentBuilder::new(_fbb);
            if let Some(x) = args.assignments {
                builder.add_assignments(x);
            }
            builder.finish()
        }

        pub const VT_ASSIGNMENTS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn assignments(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TypeAssignment<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TypeAssignment>>,
            >>(TypeEnvironment::VT_ASSIGNMENTS, None)
        }
    }

    impl flatbuffers::Verifiable for TypeEnvironment<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TypeAssignment>>,
                >>(&"assignments", Self::VT_ASSIGNMENTS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TypeEnvironmentArgs<'a> {
        pub assignments: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TypeAssignment<'a>>>,
            >,
        >,
    }
    impl<'a> Default for TypeEnvironmentArgs<'a> {
        #[inline]
        fn default() -> Self {
            TypeEnvironmentArgs { assignments: None }
        }
    }
    pub struct TypeEnvironmentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TypeEnvironmentBuilder<'a, 'b> {
        #[inline]
        pub fn add_assignments(
            &mut self,
            assignments: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TypeAssignment<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TypeEnvironment::VT_ASSIGNMENTS,
                assignments,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TypeEnvironmentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TypeEnvironmentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TypeEnvironment<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for TypeEnvironment<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("TypeEnvironment");
            ds.field("assignments", &self.assignments());
            ds.finish()
        }
    }
    pub enum TypeAssignmentOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TypeAssignment<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TypeAssignment<'a> {
        type Inner = TypeAssignment<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> TypeAssignment<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TypeAssignment { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TypeAssignmentArgs<'args>,
        ) -> flatbuffers::WIPOffset<TypeAssignment<'bldr>> {
            let mut builder = TypeAssignmentBuilder::new(_fbb);
            if let Some(x) = args.ty {
                builder.add_ty(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.finish()
        }

        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_TY: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn id(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TypeAssignment::VT_ID, None)
        }
        #[inline]
        pub fn ty(&self) -> Option<PolyType<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<PolyType>>(TypeAssignment::VT_TY, None)
        }
    }

    impl flatbuffers::Verifiable for TypeAssignment<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<PolyType>>(&"ty", Self::VT_TY, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TypeAssignmentArgs<'a> {
        pub id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub ty: Option<flatbuffers::WIPOffset<PolyType<'a>>>,
    }
    impl<'a> Default for TypeAssignmentArgs<'a> {
        #[inline]
        fn default() -> Self {
            TypeAssignmentArgs { id: None, ty: None }
        }
    }
    pub struct TypeAssignmentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TypeAssignmentBuilder<'a, 'b> {
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TypeAssignment::VT_ID, id);
        }
        #[inline]
        pub fn add_ty(&mut self, ty: flatbuffers::WIPOffset<PolyType<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<PolyType>>(TypeAssignment::VT_TY, ty);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TypeAssignmentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TypeAssignmentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TypeAssignment<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for TypeAssignment<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("TypeAssignment");
            ds.field("id", &self.id());
            ds.field("ty", &self.ty());
            ds.finish()
        }
    }
    pub enum MonoTypeHolderOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MonoTypeHolder<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MonoTypeHolder<'a> {
        type Inner = MonoTypeHolder<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> MonoTypeHolder<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MonoTypeHolder { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MonoTypeHolderArgs,
        ) -> flatbuffers::WIPOffset<MonoTypeHolder<'bldr>> {
            let mut builder = MonoTypeHolderBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_TYP: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(MonoTypeHolder::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    MonoTypeHolder::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_record(&self) -> Option<Record<'a>> {
            if self.typ_type() == MonoType::Record {
                self.typ().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_dict(&self) -> Option<Dict<'a>> {
            if self.typ_type() == MonoType::Dict {
                self.typ().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_vector(&self) -> Option<Vector<'a>> {
            if self.typ_type() == MonoType::Vector {
                self.typ().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for MonoTypeHolder<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_union::<MonoType, _>(
                    &"typ_type",
                    Self::VT_TYP_TYPE,
                    &"typ",
                    Self::VT_TYP,
                    false,
                    |key, v, pos| match key {
                        MonoType::Basic => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>(
                                "MonoType::Basic",
                                pos,
                            ),
                        MonoType::Var => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>(
                                "MonoType::Var",
                                pos,
                            ),
                        MonoType::Arr => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>(
                                "MonoType::Arr",
                                pos,
                            ),
                        MonoType::Record => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>(
                                "MonoType::Record",
                                pos,
                            ),
                        MonoType::Fun => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>(
                                "MonoType::Fun",
                                pos,
                            ),
                        MonoType::Dict => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>(
                                "MonoType::Dict",
                                pos,
                            ),
                        MonoType::Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>(
                                "MonoType::Vector",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct MonoTypeHolderArgs {
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for MonoTypeHolderArgs {
        #[inline]
        fn default() -> Self {
            MonoTypeHolderArgs {
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct MonoTypeHolderBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MonoTypeHolderBuilder<'a, 'b> {
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(MonoTypeHolder::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MonoTypeHolder::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MonoTypeHolderBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MonoTypeHolderBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MonoTypeHolder<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for MonoTypeHolder<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("MonoTypeHolder");
            ds.field("typ_type", &self.typ_type());
            match self.typ_type() {
                MonoType::Basic => {
                    if let Some(x) = self.typ_as_basic() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.typ_as_var() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.typ_as_arr() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.typ_as_record() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.typ_as_fun() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.typ_as_dict() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.typ_as_vector() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("typ", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum VarOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Var<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Var<'a> {
        type Inner = Var<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Var<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Var { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args VarArgs,
        ) -> flatbuffers::WIPOffset<Var<'bldr>> {
            let mut builder = VarBuilder::new(_fbb);
            builder.add_i(args.i);
            builder.finish()
        }

        pub const VT_I: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn i(&self) -> u64 {
            self._tab.get::<u64>(Var::VT_I, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for Var<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>(&"i", Self::VT_I, false)?
                .finish();
            Ok(())
        }
    }
    pub struct VarArgs {
        pub i: u64,
    }
    impl<'a> Default for VarArgs {
        #[inline]
        fn default() -> Self {
            VarArgs { i: 0 }
        }
    }
    pub struct VarBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> VarBuilder<'a, 'b> {
        #[inline]
        pub fn add_i(&mut self, i: u64) {
            self.fbb_.push_slot::<u64>(Var::VT_I, i, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VarBuilder<'a, 'b> {
            let start = _fbb.start_table();
            VarBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Var<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Var<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Var");
            ds.field("i", &self.i());
            ds.finish()
        }
    }
    pub enum BasicOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Basic<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Basic<'a> {
        type Inner = Basic<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Basic<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Basic { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BasicArgs,
        ) -> flatbuffers::WIPOffset<Basic<'bldr>> {
            let mut builder = BasicBuilder::new(_fbb);
            builder.add_t(args.t);
            builder.finish()
        }

        pub const VT_T: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn t(&self) -> Type {
            self._tab
                .get::<Type>(Basic::VT_T, Some(Type::Bool))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for Basic<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<Type>(&"t", Self::VT_T, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BasicArgs {
        pub t: Type,
    }
    impl<'a> Default for BasicArgs {
        #[inline]
        fn default() -> Self {
            BasicArgs { t: Type::Bool }
        }
    }
    pub struct BasicBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BasicBuilder<'a, 'b> {
        #[inline]
        pub fn add_t(&mut self, t: Type) {
            self.fbb_.push_slot::<Type>(Basic::VT_T, t, Type::Bool);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BasicBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BasicBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Basic<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Basic<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Basic");
            ds.field("t", &self.t());
            ds.finish()
        }
    }
    pub enum ArrOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Arr<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Arr<'a> {
        type Inner = Arr<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Arr<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Arr { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ArrArgs,
        ) -> flatbuffers::WIPOffset<Arr<'bldr>> {
            let mut builder = ArrBuilder::new(_fbb);
            if let Some(x) = args.t {
                builder.add_t(x);
            }
            builder.add_t_type(args.t_type);
            builder.finish()
        }

        pub const VT_T_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_T: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn t_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(Arr::VT_T_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn t(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Arr::VT_T, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_basic(&self) -> Option<Basic<'a>> {
            if self.t_type() == MonoType::Basic {
                self.t().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_var(&self) -> Option<Var<'a>> {
            if self.t_type() == MonoType::Var {
                self.t().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_arr(&self) -> Option<Arr<'a>> {
            if self.t_type() == MonoType::Arr {
                self.t().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_record(&self) -> Option<Record<'a>> {
            if self.t_type() == MonoType::Record {
                self.t().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_fun(&self) -> Option<Fun<'a>> {
            if self.t_type() == MonoType::Fun {
                self.t().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_dict(&self) -> Option<Dict<'a>> {
            if self.t_type() == MonoType::Dict {
                self.t().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_vector(&self) -> Option<Vector<'a>> {
            if self.t_type() == MonoType::Vector {
                self.t().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for Arr<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_union::<MonoType, _>(
                    &"t_type",
                    Self::VT_T_TYPE,
                    &"t",
                    Self::VT_T,
                    false,
                    |key, v, pos| match key {
                        MonoType::Basic => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>(
                                "MonoType::Basic",
                                pos,
                            ),
                        MonoType::Var => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>(
                                "MonoType::Var",
                                pos,
                            ),
                        MonoType::Arr => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>(
                                "MonoType::Arr",
                                pos,
                            ),
                        MonoType::Record => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>(
                                "MonoType::Record",
                                pos,
                            ),
                        MonoType::Fun => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>(
                                "MonoType::Fun",
                                pos,
                            ),
                        MonoType::Dict => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>(
                                "MonoType::Dict",
                                pos,
                            ),
                        MonoType::Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>(
                                "MonoType::Vector",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ArrArgs {
        pub t_type: MonoType,
        pub t: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ArrArgs {
        #[inline]
        fn default() -> Self {
            ArrArgs {
                t_type: MonoType::NONE,
                t: None,
            }
        }
    }
    pub struct ArrBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ArrBuilder<'a, 'b> {
        #[inline]
        pub fn add_t_type(&mut self, t_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(Arr::VT_T_TYPE, t_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_t(&mut self, t: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Arr::VT_T, t);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ArrBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Arr<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Arr<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Arr");
            ds.field("t_type", &self.t_type());
            match self.t_type() {
                MonoType::Basic => {
                    if let Some(x) = self.t_as_basic() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.t_as_var() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.t_as_arr() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.t_as_record() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.t_as_fun() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.t_as_dict() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.t_as_vector() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("t", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum VectorOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Vector<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Vector<'a> {
        type Inner = Vector<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Vector<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Vector { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args VectorArgs,
        ) -> flatbuffers::WIPOffset<Vector<'bldr>> {
            let mut builder = VectorBuilder::new(_fbb);
            if let Some(x) = args.t {
                builder.add_t(x);
            }
            builder.add_t_type(args.t_type);
            builder.finish()
        }

        pub const VT_T_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_T: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn t_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(Vector::VT_T_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn t(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Vector::VT_T, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_basic(&self) -> Option<Basic<'a>> {
            if self.t_type() == MonoType::Basic {
                self.t().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_var(&self) -> Option<Var<'a>> {
            if self.t_type() == MonoType::Var {
                self.t().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_arr(&self) -> Option<Arr<'a>> {
            if self.t_type() == MonoType::Arr {
                self.t().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_record(&self) -> Option<Record<'a>> {
            if self.t_type() == MonoType::Record {
                self.t().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_fun(&self) -> Option<Fun<'a>> {
            if self.t_type() == MonoType::Fun {
                self.t().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_dict(&self) -> Option<Dict<'a>> {
            if self.t_type() == MonoType::Dict {
                self.t().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_vector(&self) -> Option<Vector<'a>> {
            if self.t_type() == MonoType::Vector {
                self.t().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for Vector<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_union::<MonoType, _>(
                    &"t_type",
                    Self::VT_T_TYPE,
                    &"t",
                    Self::VT_T,
                    false,
                    |key, v, pos| match key {
                        MonoType::Basic => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>(
                                "MonoType::Basic",
                                pos,
                            ),
                        MonoType::Var => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>(
                                "MonoType::Var",
                                pos,
                            ),
                        MonoType::Arr => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>(
                                "MonoType::Arr",
                                pos,
                            ),
                        MonoType::Record => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>(
                                "MonoType::Record",
                                pos,
                            ),
                        MonoType::Fun => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>(
                                "MonoType::Fun",
                                pos,
                            ),
                        MonoType::Dict => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>(
                                "MonoType::Dict",
                                pos,
                            ),
                        MonoType::Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>(
                                "MonoType::Vector",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct VectorArgs {
        pub t_type: MonoType,
        pub t: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for VectorArgs {
        #[inline]
        fn default() -> Self {
            VectorArgs {
                t_type: MonoType::NONE,
                t: None,
            }
        }
    }
    pub struct VectorBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> VectorBuilder<'a, 'b> {
        #[inline]
        pub fn add_t_type(&mut self, t_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(Vector::VT_T_TYPE, t_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_t(&mut self, t: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Vector::VT_T, t);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VectorBuilder<'a, 'b> {
            let start = _fbb.start_table();
            VectorBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Vector<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Vector<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Vector");
            ds.field("t_type", &self.t_type());
            match self.t_type() {
                MonoType::Basic => {
                    if let Some(x) = self.t_as_basic() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.t_as_var() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.t_as_arr() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.t_as_record() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.t_as_fun() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.t_as_dict() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.t_as_vector() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("t", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum RecordOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Record<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Record<'a> {
        type Inner = Record<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Record<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Record { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RecordArgs<'args>,
        ) -> flatbuffers::WIPOffset<Record<'bldr>> {
            let mut builder = RecordBuilder::new(_fbb);
            if let Some(x) = args.extends {
                builder.add_extends(x);
            }
            if let Some(x) = args.props {
                builder.add_props(x);
            }
            builder.finish()
        }

        pub const VT_PROPS: flatbuffers::VOffsetT = 4;
        pub const VT_EXTENDS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn props(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Prop<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Prop>>,
            >>(Record::VT_PROPS, None)
        }
        #[inline]
        pub fn extends(&self) -> Option<Var<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Var>>(Record::VT_EXTENDS, None)
        }
    }

    impl flatbuffers::Verifiable for Record<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Prop>>,
                >>(&"props", Self::VT_PROPS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Var>>(
                    &"extends",
                    Self::VT_EXTENDS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct RecordArgs<'a> {
        pub props: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Prop<'a>>>>,
        >,
        pub extends: Option<flatbuffers::WIPOffset<Var<'a>>>,
    }
    impl<'a> Default for RecordArgs<'a> {
        #[inline]
        fn default() -> Self {
            RecordArgs {
                props: None,
                extends: None,
            }
        }
    }
    pub struct RecordBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RecordBuilder<'a, 'b> {
        #[inline]
        pub fn add_props(
            &mut self,
            props: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Prop<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Record::VT_PROPS, props);
        }
        #[inline]
        pub fn add_extends(&mut self, extends: flatbuffers::WIPOffset<Var<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Var>>(Record::VT_EXTENDS, extends);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RecordBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RecordBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Record<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Record<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Record");
            ds.field("props", &self.props());
            ds.field("extends", &self.extends());
            ds.finish()
        }
    }
    pub enum FunOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Fun<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Fun<'a> {
        type Inner = Fun<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Fun<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Fun { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FunArgs<'args>,
        ) -> flatbuffers::WIPOffset<Fun<'bldr>> {
            let mut builder = FunBuilder::new(_fbb);
            if let Some(x) = args.retn {
                builder.add_retn(x);
            }
            if let Some(x) = args.args {
                builder.add_args(x);
            }
            builder.add_retn_type(args.retn_type);
            builder.finish()
        }

        pub const VT_ARGS: flatbuffers::VOffsetT = 4;
        pub const VT_RETN_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_RETN: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn args(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Argument<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Argument>>,
            >>(Fun::VT_ARGS, None)
        }
        #[inline]
        pub fn retn_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(Fun::VT_RETN_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn retn(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Fun::VT_RETN, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn retn_as_basic(&self) -> Option<Basic<'a>> {
            if self.retn_type() == MonoType::Basic {
                self.retn().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn retn_as_var(&self) -> Option<Var<'a>> {
            if self.retn_type() == MonoType::Var {
                self.retn().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn retn_as_arr(&self) -> Option<Arr<'a>> {
            if self.retn_type() == MonoType::Arr {
                self.retn().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn retn_as_record(&self) -> Option<Record<'a>> {
            if self.retn_type() == MonoType::Record {
                self.retn().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn retn_as_fun(&self) -> Option<Fun<'a>> {
            if self.retn_type() == MonoType::Fun {
                self.retn().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn retn_as_dict(&self) -> Option<Dict<'a>> {
            if self.retn_type() == MonoType::Dict {
                self.retn().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn retn_as_vector(&self) -> Option<Vector<'a>> {
            if self.retn_type() == MonoType::Vector {
                self.retn().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for Fun<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Argument>>,
                >>(&"args", Self::VT_ARGS, false)?
                .visit_union::<MonoType, _>(
                    &"retn_type",
                    Self::VT_RETN_TYPE,
                    &"retn",
                    Self::VT_RETN,
                    false,
                    |key, v, pos| match key {
                        MonoType::Basic => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>(
                                "MonoType::Basic",
                                pos,
                            ),
                        MonoType::Var => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>(
                                "MonoType::Var",
                                pos,
                            ),
                        MonoType::Arr => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>(
                                "MonoType::Arr",
                                pos,
                            ),
                        MonoType::Record => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>(
                                "MonoType::Record",
                                pos,
                            ),
                        MonoType::Fun => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>(
                                "MonoType::Fun",
                                pos,
                            ),
                        MonoType::Dict => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>(
                                "MonoType::Dict",
                                pos,
                            ),
                        MonoType::Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>(
                                "MonoType::Vector",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct FunArgs<'a> {
        pub args: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Argument<'a>>>,
            >,
        >,
        pub retn_type: MonoType,
        pub retn: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for FunArgs<'a> {
        #[inline]
        fn default() -> Self {
            FunArgs {
                args: None,
                retn_type: MonoType::NONE,
                retn: None,
            }
        }
    }
    pub struct FunBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FunBuilder<'a, 'b> {
        #[inline]
        pub fn add_args(
            &mut self,
            args: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Argument<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Fun::VT_ARGS, args);
        }
        #[inline]
        pub fn add_retn_type(&mut self, retn_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(Fun::VT_RETN_TYPE, retn_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_retn(&mut self, retn: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Fun::VT_RETN, retn);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FunBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FunBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Fun<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Fun<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Fun");
            ds.field("args", &self.args());
            ds.field("retn_type", &self.retn_type());
            match self.retn_type() {
                MonoType::Basic => {
                    if let Some(x) = self.retn_as_basic() {
                        ds.field("retn", &x)
                    } else {
                        ds.field(
                            "retn",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.retn_as_var() {
                        ds.field("retn", &x)
                    } else {
                        ds.field(
                            "retn",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.retn_as_arr() {
                        ds.field("retn", &x)
                    } else {
                        ds.field(
                            "retn",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.retn_as_record() {
                        ds.field("retn", &x)
                    } else {
                        ds.field(
                            "retn",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.retn_as_fun() {
                        ds.field("retn", &x)
                    } else {
                        ds.field(
                            "retn",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.retn_as_dict() {
                        ds.field("retn", &x)
                    } else {
                        ds.field(
                            "retn",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.retn_as_vector() {
                        ds.field("retn", &x)
                    } else {
                        ds.field(
                            "retn",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("retn", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum DictOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Dict<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Dict<'a> {
        type Inner = Dict<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Dict<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Dict { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DictArgs,
        ) -> flatbuffers::WIPOffset<Dict<'bldr>> {
            let mut builder = DictBuilder::new(_fbb);
            if let Some(x) = args.v {
                builder.add_v(x);
            }
            if let Some(x) = args.k {
                builder.add_k(x);
            }
            builder.add_v_type(args.v_type);
            builder.add_k_type(args.k_type);
            builder.finish()
        }

        pub const VT_K_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_K: flatbuffers::VOffsetT = 6;
        pub const VT_V_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_V: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn k_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(Dict::VT_K_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn k(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Dict::VT_K, None)
        }
        #[inline]
        pub fn v_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(Dict::VT_V_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn v(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Dict::VT_V, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn k_as_basic(&self) -> Option<Basic<'a>> {
            if self.k_type() == MonoType::Basic {
                self.k().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn k_as_var(&self) -> Option<Var<'a>> {
            if self.k_type() == MonoType::Var {
                self.k().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn k_as_arr(&self) -> Option<Arr<'a>> {
            if self.k_type() == MonoType::Arr {
                self.k().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn k_as_record(&self) -> Option<Record<'a>> {
            if self.k_type() == MonoType::Record {
                self.k().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn k_as_fun(&self) -> Option<Fun<'a>> {
            if self.k_type() == MonoType::Fun {
                self.k().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn k_as_dict(&self) -> Option<Dict<'a>> {
            if self.k_type() == MonoType::Dict {
                self.k().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn k_as_vector(&self) -> Option<Vector<'a>> {
            if self.k_type() == MonoType::Vector {
                self.k().map(Vector::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_basic(&self) -> Option<Basic<'a>> {
            if self.v_type() == MonoType::Basic {
                self.v().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_var(&self) -> Option<Var<'a>> {
            if self.v_type() == MonoType::Var {
                self.v().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_arr(&self) -> Option<Arr<'a>> {
            if self.v_type() == MonoType::Arr {
                self.v().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_record(&self) -> Option<Record<'a>> {
            if self.v_type() == MonoType::Record {
                self.v().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_fun(&self) -> Option<Fun<'a>> {
            if self.v_type() == MonoType::Fun {
                self.v().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_dict(&self) -> Option<Dict<'a>> {
            if self.v_type() == MonoType::Dict {
                self.v().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_vector(&self) -> Option<Vector<'a>> {
            if self.v_type() == MonoType::Vector {
                self.v().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for Dict<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_union::<MonoType, _>(
                    &"k_type",
                    Self::VT_K_TYPE,
                    &"k",
                    Self::VT_K,
                    false,
                    |key, v, pos| match key {
                        MonoType::Basic => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>(
                                "MonoType::Basic",
                                pos,
                            ),
                        MonoType::Var => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>(
                                "MonoType::Var",
                                pos,
                            ),
                        MonoType::Arr => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>(
                                "MonoType::Arr",
                                pos,
                            ),
                        MonoType::Record => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>(
                                "MonoType::Record",
                                pos,
                            ),
                        MonoType::Fun => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>(
                                "MonoType::Fun",
                                pos,
                            ),
                        MonoType::Dict => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>(
                                "MonoType::Dict",
                                pos,
                            ),
                        MonoType::Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>(
                                "MonoType::Vector",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .visit_union::<MonoType, _>(
                    &"v_type",
                    Self::VT_V_TYPE,
                    &"v",
                    Self::VT_V,
                    false,
                    |key, v, pos| match key {
                        MonoType::Basic => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>(
                                "MonoType::Basic",
                                pos,
                            ),
                        MonoType::Var => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>(
                                "MonoType::Var",
                                pos,
                            ),
                        MonoType::Arr => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>(
                                "MonoType::Arr",
                                pos,
                            ),
                        MonoType::Record => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>(
                                "MonoType::Record",
                                pos,
                            ),
                        MonoType::Fun => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>(
                                "MonoType::Fun",
                                pos,
                            ),
                        MonoType::Dict => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>(
                                "MonoType::Dict",
                                pos,
                            ),
                        MonoType::Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>(
                                "MonoType::Vector",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct DictArgs {
        pub k_type: MonoType,
        pub k: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub v_type: MonoType,
        pub v: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for DictArgs {
        #[inline]
        fn default() -> Self {
            DictArgs {
                k_type: MonoType::NONE,
                k: None,
                v_type: MonoType::NONE,
                v: None,
            }
        }
    }
    pub struct DictBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DictBuilder<'a, 'b> {
        #[inline]
        pub fn add_k_type(&mut self, k_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(Dict::VT_K_TYPE, k_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_k(&mut self, k: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Dict::VT_K, k);
        }
        #[inline]
        pub fn add_v_type(&mut self, v_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(Dict::VT_V_TYPE, v_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_v(&mut self, v: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Dict::VT_V, v);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DictBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DictBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Dict<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Dict<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Dict");
            ds.field("k_type", &self.k_type());
            match self.k_type() {
                MonoType::Basic => {
                    if let Some(x) = self.k_as_basic() {
                        ds.field("k", &x)
                    } else {
                        ds.field(
                            "k",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.k_as_var() {
                        ds.field("k", &x)
                    } else {
                        ds.field(
                            "k",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.k_as_arr() {
                        ds.field("k", &x)
                    } else {
                        ds.field(
                            "k",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.k_as_record() {
                        ds.field("k", &x)
                    } else {
                        ds.field(
                            "k",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.k_as_fun() {
                        ds.field("k", &x)
                    } else {
                        ds.field(
                            "k",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.k_as_dict() {
                        ds.field("k", &x)
                    } else {
                        ds.field(
                            "k",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.k_as_vector() {
                        ds.field("k", &x)
                    } else {
                        ds.field(
                            "k",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("k", &x)
                }
            };
            ds.field("v_type", &self.v_type());
            match self.v_type() {
                MonoType::Basic => {
                    if let Some(x) = self.v_as_basic() {
                        ds.field("v", &x)
                    } else {
                        ds.field(
                            "v",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.v_as_var() {
                        ds.field("v", &x)
                    } else {
                        ds.field(
                            "v",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.v_as_arr() {
                        ds.field("v", &x)
                    } else {
                        ds.field(
                            "v",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.v_as_record() {
                        ds.field("v", &x)
                    } else {
                        ds.field(
                            "v",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.v_as_fun() {
                        ds.field("v", &x)
                    } else {
                        ds.field(
                            "v",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.v_as_dict() {
                        ds.field("v", &x)
                    } else {
                        ds.field(
                            "v",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.v_as_vector() {
                        ds.field("v", &x)
                    } else {
                        ds.field(
                            "v",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("v", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum ArgumentOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Argument<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Argument<'a> {
        type Inner = Argument<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Argument<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Argument { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ArgumentArgs<'args>,
        ) -> flatbuffers::WIPOffset<Argument<'bldr>> {
            let mut builder = ArgumentBuilder::new(_fbb);
            if let Some(x) = args.t {
                builder.add_t(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_optional(args.optional);
            builder.add_pipe(args.pipe);
            builder.add_t_type(args.t_type);
            builder.finish()
        }

        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_T_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_T: flatbuffers::VOffsetT = 8;
        pub const VT_PIPE: flatbuffers::VOffsetT = 10;
        pub const VT_OPTIONAL: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Argument::VT_NAME, None)
        }
        #[inline]
        pub fn t_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(Argument::VT_T_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn t(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Argument::VT_T, None)
        }
        #[inline]
        pub fn pipe(&self) -> bool {
            self._tab
                .get::<bool>(Argument::VT_PIPE, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn optional(&self) -> bool {
            self._tab
                .get::<bool>(Argument::VT_OPTIONAL, Some(false))
                .unwrap()
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_basic(&self) -> Option<Basic<'a>> {
            if self.t_type() == MonoType::Basic {
                self.t().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_var(&self) -> Option<Var<'a>> {
            if self.t_type() == MonoType::Var {
                self.t().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_arr(&self) -> Option<Arr<'a>> {
            if self.t_type() == MonoType::Arr {
                self.t().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_record(&self) -> Option<Record<'a>> {
            if self.t_type() == MonoType::Record {
                self.t().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_fun(&self) -> Option<Fun<'a>> {
            if self.t_type() == MonoType::Fun {
                self.t().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_dict(&self) -> Option<Dict<'a>> {
            if self.t_type() == MonoType::Dict {
                self.t().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_vector(&self) -> Option<Vector<'a>> {
            if self.t_type() == MonoType::Vector {
                self.t().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for Argument<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
                .visit_union::<MonoType, _>(
                    &"t_type",
                    Self::VT_T_TYPE,
                    &"t",
                    Self::VT_T,
                    false,
                    |key, v, pos| match key {
                        MonoType::Basic => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>(
                                "MonoType::Basic",
                                pos,
                            ),
                        MonoType::Var => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>(
                                "MonoType::Var",
                                pos,
                            ),
                        MonoType::Arr => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>(
                                "MonoType::Arr",
                                pos,
                            ),
                        MonoType::Record => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>(
                                "MonoType::Record",
                                pos,
                            ),
                        MonoType::Fun => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>(
                                "MonoType::Fun",
                                pos,
                            ),
                        MonoType::Dict => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>(
                                "MonoType::Dict",
                                pos,
                            ),
                        MonoType::Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>(
                                "MonoType::Vector",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .visit_field::<bool>(&"pipe", Self::VT_PIPE, false)?
                .visit_field::<bool>(&"optional", Self::VT_OPTIONAL, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ArgumentArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub t_type: MonoType,
        pub t: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub pipe: bool,
        pub optional: bool,
    }
    impl<'a> Default for ArgumentArgs<'a> {
        #[inline]
        fn default() -> Self {
            ArgumentArgs {
                name: None,
                t_type: MonoType::NONE,
                t: None,
                pipe: false,
                optional: false,
            }
        }
    }
    pub struct ArgumentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ArgumentBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Argument::VT_NAME, name);
        }
        #[inline]
        pub fn add_t_type(&mut self, t_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(Argument::VT_T_TYPE, t_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_t(&mut self, t: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Argument::VT_T, t);
        }
        #[inline]
        pub fn add_pipe(&mut self, pipe: bool) {
            self.fbb_.push_slot::<bool>(Argument::VT_PIPE, pipe, false);
        }
        #[inline]
        pub fn add_optional(&mut self, optional: bool) {
            self.fbb_
                .push_slot::<bool>(Argument::VT_OPTIONAL, optional, false);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArgumentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ArgumentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Argument<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Argument<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Argument");
            ds.field("name", &self.name());
            ds.field("t_type", &self.t_type());
            match self.t_type() {
                MonoType::Basic => {
                    if let Some(x) = self.t_as_basic() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.t_as_var() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.t_as_arr() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.t_as_record() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.t_as_fun() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.t_as_dict() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.t_as_vector() {
                        ds.field("t", &x)
                    } else {
                        ds.field(
                            "t",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("t", &x)
                }
            };
            ds.field("pipe", &self.pipe());
            ds.field("optional", &self.optional());
            ds.finish()
        }
    }
    pub enum PropOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Prop<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Prop<'a> {
        type Inner = Prop<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Prop<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Prop { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PropArgs<'args>,
        ) -> flatbuffers::WIPOffset<Prop<'bldr>> {
            let mut builder = PropBuilder::new(_fbb);
            if let Some(x) = args.v {
                builder.add_v(x);
            }
            if let Some(x) = args.k {
                builder.add_k(x);
            }
            builder.add_v_type(args.v_type);
            builder.finish()
        }

        pub const VT_K: flatbuffers::VOffsetT = 4;
        pub const VT_V_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_V: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn k(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Prop::VT_K, None)
        }
        #[inline]
        pub fn v_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(Prop::VT_V_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn v(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Prop::VT_V, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_basic(&self) -> Option<Basic<'a>> {
            if self.v_type() == MonoType::Basic {
                self.v().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_var(&self) -> Option<Var<'a>> {
            if self.v_type() == MonoType::Var {
                self.v().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_arr(&self) -> Option<Arr<'a>> {
            if self.v_type() == MonoType::Arr {
                self.v().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_record(&self) -> Option<Record<'a>> {
            if self.v_type() == MonoType::Record {
                self.v().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_fun(&self) -> Option<Fun<'a>> {
            if self.v_type() == MonoType::Fun {
                self.v().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_dict(&self) -> Option<Dict<'a>> {
            if self.v_type() == MonoType::Dict {
                self.v().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_vector(&self) -> Option<Vector<'a>> {
            if self.v_type() == MonoType::Vector {
                self.v().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for Prop<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"k", Self::VT_K, false)?
                .visit_union::<MonoType, _>(
                    &"v_type",
                    Self::VT_V_TYPE,
                    &"v",
                    Self::VT_V,
                    false,
                    |key, v, pos| match key {
                        MonoType::Basic => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>(
                                "MonoType::Basic",
                                pos,
                            ),
                        MonoType::Var => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>(
                                "MonoType::Var",
                                pos,
                            ),
                        MonoType::Arr => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>(
                                "MonoType::Arr",
                                pos,
                            ),
                        MonoType::Record => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>(
                                "MonoType::Record",
                                pos,
                            ),
                        MonoType::Fun => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>(
                                "MonoType::Fun",
                                pos,
                            ),
                        MonoType::Dict => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>(
                                "MonoType::Dict",
                                pos,
                            ),
                        MonoType::Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>(
                                "MonoType::Vector",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PropArgs<'a> {
        pub k: Option<flatbuffers::WIPOffset<&'a str>>,
        pub v_type: MonoType,
        pub v: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for PropArgs<'a> {
        #[inline]
        fn default() -> Self {
            PropArgs {
                k: None,
                v_type: MonoType::NONE,
                v: None,
            }
        }
    }
    pub struct PropBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PropBuilder<'a, 'b> {
        #[inline]
        pub fn add_k(&mut self, k: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Prop::VT_K, k);
        }
        #[inline]
        pub fn add_v_type(&mut self, v_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(Prop::VT_V_TYPE, v_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_v(&mut self, v: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Prop::VT_V, v);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PropBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PropBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Prop<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Prop<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Prop");
            ds.field("k", &self.k());
            ds.field("v_type", &self.v_type());
            match self.v_type() {
                MonoType::Basic => {
                    if let Some(x) = self.v_as_basic() {
                        ds.field("v", &x)
                    } else {
                        ds.field(
                            "v",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.v_as_var() {
                        ds.field("v", &x)
                    } else {
                        ds.field(
                            "v",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.v_as_arr() {
                        ds.field("v", &x)
                    } else {
                        ds.field(
                            "v",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.v_as_record() {
                        ds.field("v", &x)
                    } else {
                        ds.field(
                            "v",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.v_as_fun() {
                        ds.field("v", &x)
                    } else {
                        ds.field(
                            "v",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.v_as_dict() {
                        ds.field("v", &x)
                    } else {
                        ds.field(
                            "v",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.v_as_vector() {
                        ds.field("v", &x)
                    } else {
                        ds.field(
                            "v",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("v", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum PolyTypeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PolyType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PolyType<'a> {
        type Inner = PolyType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> PolyType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PolyType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PolyTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<PolyType<'bldr>> {
            let mut builder = PolyTypeBuilder::new(_fbb);
            if let Some(x) = args.expr {
                builder.add_expr(x);
            }
            if let Some(x) = args.cons {
                builder.add_cons(x);
            }
            if let Some(x) = args.vars {
                builder.add_vars(x);
            }
            builder.add_expr_type(args.expr_type);
            builder.finish()
        }

        pub const VT_VARS: flatbuffers::VOffsetT = 4;
        pub const VT_CONS: flatbuffers::VOffsetT = 6;
        pub const VT_EXPR_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_EXPR: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn vars(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Var<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Var>>,
            >>(PolyType::VT_VARS, None)
        }
        #[inline]
        pub fn cons(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Constraint<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Constraint>>,
            >>(PolyType::VT_CONS, None)
        }
        #[inline]
        pub fn expr_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(PolyType::VT_EXPR_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn expr(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    PolyType::VT_EXPR,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_basic(&self) -> Option<Basic<'a>> {
            if self.expr_type() == MonoType::Basic {
                self.expr().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_var(&self) -> Option<Var<'a>> {
            if self.expr_type() == MonoType::Var {
                self.expr().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_arr(&self) -> Option<Arr<'a>> {
            if self.expr_type() == MonoType::Arr {
                self.expr().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_record(&self) -> Option<Record<'a>> {
            if self.expr_type() == MonoType::Record {
                self.expr().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_fun(&self) -> Option<Fun<'a>> {
            if self.expr_type() == MonoType::Fun {
                self.expr().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_dict(&self) -> Option<Dict<'a>> {
            if self.expr_type() == MonoType::Dict {
                self.expr().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_vector(&self) -> Option<Vector<'a>> {
            if self.expr_type() == MonoType::Vector {
                self.expr().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for PolyType<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Var>>,
                >>(&"vars", Self::VT_VARS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Constraint>>,
                >>(&"cons", Self::VT_CONS, false)?
                .visit_union::<MonoType, _>(
                    &"expr_type",
                    Self::VT_EXPR_TYPE,
                    &"expr",
                    Self::VT_EXPR,
                    false,
                    |key, v, pos| match key {
                        MonoType::Basic => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>(
                                "MonoType::Basic",
                                pos,
                            ),
                        MonoType::Var => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>(
                                "MonoType::Var",
                                pos,
                            ),
                        MonoType::Arr => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>(
                                "MonoType::Arr",
                                pos,
                            ),
                        MonoType::Record => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>(
                                "MonoType::Record",
                                pos,
                            ),
                        MonoType::Fun => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>(
                                "MonoType::Fun",
                                pos,
                            ),
                        MonoType::Dict => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>(
                                "MonoType::Dict",
                                pos,
                            ),
                        MonoType::Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>(
                                "MonoType::Vector",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PolyTypeArgs<'a> {
        pub vars: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Var<'a>>>>,
        >,
        pub cons: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Constraint<'a>>>,
            >,
        >,
        pub expr_type: MonoType,
        pub expr: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for PolyTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            PolyTypeArgs {
                vars: None,
                cons: None,
                expr_type: MonoType::NONE,
                expr: None,
            }
        }
    }
    pub struct PolyTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PolyTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_vars(
            &mut self,
            vars: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Var<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PolyType::VT_VARS, vars);
        }
        #[inline]
        pub fn add_cons(
            &mut self,
            cons: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Constraint<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PolyType::VT_CONS, cons);
        }
        #[inline]
        pub fn add_expr_type(&mut self, expr_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(PolyType::VT_EXPR_TYPE, expr_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_expr(&mut self, expr: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PolyType::VT_EXPR, expr);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PolyTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PolyTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PolyType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for PolyType<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("PolyType");
            ds.field("vars", &self.vars());
            ds.field("cons", &self.cons());
            ds.field("expr_type", &self.expr_type());
            match self.expr_type() {
                MonoType::Basic => {
                    if let Some(x) = self.expr_as_basic() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.expr_as_var() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.expr_as_arr() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.expr_as_record() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.expr_as_fun() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.expr_as_dict() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.expr_as_vector() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("expr", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum ConstraintOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Constraint<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Constraint<'a> {
        type Inner = Constraint<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Constraint<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Constraint { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ConstraintArgs<'args>,
        ) -> flatbuffers::WIPOffset<Constraint<'bldr>> {
            let mut builder = ConstraintBuilder::new(_fbb);
            if let Some(x) = args.tvar {
                builder.add_tvar(x);
            }
            builder.add_kind(args.kind);
            builder.finish()
        }

        pub const VT_TVAR: flatbuffers::VOffsetT = 4;
        pub const VT_KIND: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn tvar(&self) -> Option<Var<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Var>>(Constraint::VT_TVAR, None)
        }
        #[inline]
        pub fn kind(&self) -> Kind {
            self._tab
                .get::<Kind>(Constraint::VT_KIND, Some(Kind::Addable))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for Constraint<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Var>>(&"tvar", Self::VT_TVAR, false)?
                .visit_field::<Kind>(&"kind", Self::VT_KIND, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ConstraintArgs<'a> {
        pub tvar: Option<flatbuffers::WIPOffset<Var<'a>>>,
        pub kind: Kind,
    }
    impl<'a> Default for ConstraintArgs<'a> {
        #[inline]
        fn default() -> Self {
            ConstraintArgs {
                tvar: None,
                kind: Kind::Addable,
            }
        }
    }
    pub struct ConstraintBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ConstraintBuilder<'a, 'b> {
        #[inline]
        pub fn add_tvar(&mut self, tvar: flatbuffers::WIPOffset<Var<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Var>>(Constraint::VT_TVAR, tvar);
        }
        #[inline]
        pub fn add_kind(&mut self, kind: Kind) {
            self.fbb_
                .push_slot::<Kind>(Constraint::VT_KIND, kind, Kind::Addable);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConstraintBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ConstraintBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Constraint<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Constraint<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Constraint");
            ds.field("tvar", &self.tvar());
            ds.field("kind", &self.kind());
            ds.finish()
        }
    }
    pub enum PackageOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Package<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Package<'a> {
        type Inner = Package<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Package<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Package { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PackageArgs<'args>,
        ) -> flatbuffers::WIPOffset<Package<'bldr>> {
            let mut builder = PackageBuilder::new(_fbb);
            if let Some(x) = args.files {
                builder.add_files(x);
            }
            if let Some(x) = args.package {
                builder.add_package(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_PACKAGE: flatbuffers::VOffsetT = 6;
        pub const VT_FILES: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(Package::VT_LOC, None)
        }
        #[inline]
        pub fn package(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Package::VT_PACKAGE, None)
        }
        #[inline]
        pub fn files(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File>>,
            >>(Package::VT_FILES, None)
        }
    }

    impl flatbuffers::Verifiable for Package<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    &"package",
                    Self::VT_PACKAGE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<File>>,
                >>(&"files", Self::VT_FILES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PackageArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub package: Option<flatbuffers::WIPOffset<&'a str>>,
        pub files: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File<'a>>>>,
        >,
    }
    impl<'a> Default for PackageArgs<'a> {
        #[inline]
        fn default() -> Self {
            PackageArgs {
                loc: None,
                package: None,
                files: None,
            }
        }
    }
    pub struct PackageBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PackageBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(Package::VT_LOC, loc);
        }
        #[inline]
        pub fn add_package(&mut self, package: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_PACKAGE, package);
        }
        #[inline]
        pub fn add_files(
            &mut self,
            files: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<File<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_FILES, files);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PackageBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PackageBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Package<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Package<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Package");
            ds.field("loc", &self.loc());
            ds.field("package", &self.package());
            ds.field("files", &self.files());
            ds.finish()
        }
    }
    pub enum FileOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct File<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for File<'a> {
        type Inner = File<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> File<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            File { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FileArgs<'args>,
        ) -> flatbuffers::WIPOffset<File<'bldr>> {
            let mut builder = FileBuilder::new(_fbb);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.imports {
                builder.add_imports(x);
            }
            if let Some(x) = args.package {
                builder.add_package(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_PACKAGE: flatbuffers::VOffsetT = 6;
        pub const VT_IMPORTS: flatbuffers::VOffsetT = 8;
        pub const VT_BODY: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(File::VT_LOC, None)
        }
        #[inline]
        pub fn package(&self) -> Option<PackageClause<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<PackageClause>>(File::VT_PACKAGE, None)
        }
        #[inline]
        pub fn imports(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ImportDeclaration<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ImportDeclaration>>,
            >>(File::VT_IMPORTS, None)
        }
        #[inline]
        pub fn body(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement>>,
            >>(File::VT_BODY, None)
        }
    }

    impl flatbuffers::Verifiable for File<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<PackageClause>>(
                    &"package",
                    Self::VT_PACKAGE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ImportDeclaration>>,
                >>(&"imports", Self::VT_IMPORTS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WrappedStatement>>,
                >>(&"body", Self::VT_BODY, false)?
                .finish();
            Ok(())
        }
    }
    pub struct FileArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub package: Option<flatbuffers::WIPOffset<PackageClause<'a>>>,
        pub imports: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ImportDeclaration<'a>>>,
            >,
        >,
        pub body: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>,
            >,
        >,
    }
    impl<'a> Default for FileArgs<'a> {
        #[inline]
        fn default() -> Self {
            FileArgs {
                loc: None,
                package: None,
                imports: None,
                body: None,
            }
        }
    }
    pub struct FileBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FileBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(File::VT_LOC, loc);
        }
        #[inline]
        pub fn add_package(&mut self, package: flatbuffers::WIPOffset<PackageClause<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<PackageClause>>(
                    File::VT_PACKAGE,
                    package,
                );
        }
        #[inline]
        pub fn add_imports(
            &mut self,
            imports: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ImportDeclaration<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_IMPORTS, imports);
        }
        #[inline]
        pub fn add_body(
            &mut self,
            body: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<WrappedStatement<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_BODY, body);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FileBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FileBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<File<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for File<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("File");
            ds.field("loc", &self.loc());
            ds.field("package", &self.package());
            ds.field("imports", &self.imports());
            ds.field("body", &self.body());
            ds.finish()
        }
    }
    pub enum PackageClauseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PackageClause<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PackageClause<'a> {
        type Inner = PackageClause<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> PackageClause<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PackageClause { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PackageClauseArgs<'args>,
        ) -> flatbuffers::WIPOffset<PackageClause<'bldr>> {
            let mut builder = PackageClauseBuilder::new(_fbb);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(PackageClause::VT_LOC, None)
        }
        #[inline]
        pub fn name(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(PackageClause::VT_NAME, None)
        }
    }

    impl flatbuffers::Verifiable for PackageClause<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(
                    &"name",
                    Self::VT_NAME,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PackageClauseArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub name: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    }
    impl<'a> Default for PackageClauseArgs<'a> {
        #[inline]
        fn default() -> Self {
            PackageClauseArgs {
                loc: None,
                name: None,
            }
        }
    }
    pub struct PackageClauseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PackageClauseBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    PackageClause::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    PackageClause::VT_NAME,
                    name,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> PackageClauseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PackageClauseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PackageClause<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for PackageClause<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("PackageClause");
            ds.field("loc", &self.loc());
            ds.field("name", &self.name());
            ds.finish()
        }
    }
    pub enum ImportDeclarationOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ImportDeclaration<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ImportDeclaration<'a> {
        type Inner = ImportDeclaration<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ImportDeclaration<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ImportDeclaration { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ImportDeclarationArgs<'args>,
        ) -> flatbuffers::WIPOffset<ImportDeclaration<'bldr>> {
            let mut builder = ImportDeclarationBuilder::new(_fbb);
            if let Some(x) = args.path {
                builder.add_path(x);
            }
            if let Some(x) = args.alias {
                builder.add_alias(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ALIAS: flatbuffers::VOffsetT = 6;
        pub const VT_PATH: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    ImportDeclaration::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn alias(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(ImportDeclaration::VT_ALIAS, None)
        }
        #[inline]
        pub fn path(&self) -> Option<StringLiteral<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<StringLiteral>>(
                    ImportDeclaration::VT_PATH,
                    None,
                )
        }
    }

    impl flatbuffers::Verifiable for ImportDeclaration<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(
                    &"alias",
                    Self::VT_ALIAS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<StringLiteral>>(
                    &"path",
                    Self::VT_PATH,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ImportDeclarationArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub alias: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub path: Option<flatbuffers::WIPOffset<StringLiteral<'a>>>,
    }
    impl<'a> Default for ImportDeclarationArgs<'a> {
        #[inline]
        fn default() -> Self {
            ImportDeclarationArgs {
                loc: None,
                alias: None,
                path: None,
            }
        }
    }
    pub struct ImportDeclarationBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ImportDeclarationBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    ImportDeclaration::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_alias(&mut self, alias: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    ImportDeclaration::VT_ALIAS,
                    alias,
                );
        }
        #[inline]
        pub fn add_path(&mut self, path: flatbuffers::WIPOffset<StringLiteral<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<StringLiteral>>(
                    ImportDeclaration::VT_PATH,
                    path,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ImportDeclarationBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ImportDeclarationBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ImportDeclaration<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ImportDeclaration<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ImportDeclaration");
            ds.field("loc", &self.loc());
            ds.field("alias", &self.alias());
            ds.field("path", &self.path());
            ds.finish()
        }
    }
    pub enum SourceLocationOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SourceLocation<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SourceLocation<'a> {
        type Inner = SourceLocation<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> SourceLocation<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SourceLocation { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SourceLocationArgs<'args>,
        ) -> flatbuffers::WIPOffset<SourceLocation<'bldr>> {
            let mut builder = SourceLocationBuilder::new(_fbb);
            if let Some(x) = args.source {
                builder.add_source(x);
            }
            if let Some(x) = args.end {
                builder.add_end(x);
            }
            if let Some(x) = args.start {
                builder.add_start(x);
            }
            if let Some(x) = args.file {
                builder.add_file(x);
            }
            builder.finish()
        }

        pub const VT_FILE: flatbuffers::VOffsetT = 4;
        pub const VT_START: flatbuffers::VOffsetT = 6;
        pub const VT_END: flatbuffers::VOffsetT = 8;
        pub const VT_SOURCE: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn file(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SourceLocation::VT_FILE, None)
        }
        #[inline]
        pub fn start(&self) -> Option<&'a Position> {
            self._tab.get::<Position>(SourceLocation::VT_START, None)
        }
        #[inline]
        pub fn end(&self) -> Option<&'a Position> {
            self._tab.get::<Position>(SourceLocation::VT_END, None)
        }
        #[inline]
        pub fn source(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SourceLocation::VT_SOURCE, None)
        }
    }

    impl flatbuffers::Verifiable for SourceLocation<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"file", Self::VT_FILE, false)?
                .visit_field::<Position>(&"start", Self::VT_START, false)?
                .visit_field::<Position>(&"end", Self::VT_END, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    &"source",
                    Self::VT_SOURCE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct SourceLocationArgs<'a> {
        pub file: Option<flatbuffers::WIPOffset<&'a str>>,
        pub start: Option<&'a Position>,
        pub end: Option<&'a Position>,
        pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for SourceLocationArgs<'a> {
        #[inline]
        fn default() -> Self {
            SourceLocationArgs {
                file: None,
                start: None,
                end: None,
                source: None,
            }
        }
    }
    pub struct SourceLocationBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SourceLocationBuilder<'a, 'b> {
        #[inline]
        pub fn add_file(&mut self, file: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SourceLocation::VT_FILE, file);
        }
        #[inline]
        pub fn add_start(&mut self, start: &Position) {
            self.fbb_
                .push_slot_always::<&Position>(SourceLocation::VT_START, start);
        }
        #[inline]
        pub fn add_end(&mut self, end: &Position) {
            self.fbb_
                .push_slot_always::<&Position>(SourceLocation::VT_END, end);
        }
        #[inline]
        pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SourceLocation::VT_SOURCE, source);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SourceLocationBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SourceLocationBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SourceLocation<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for SourceLocation<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("SourceLocation");
            ds.field("file", &self.file());
            ds.field("start", &self.start());
            ds.field("end", &self.end());
            ds.field("source", &self.source());
            ds.finish()
        }
    }
    pub enum WrappedStatementOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct WrappedStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for WrappedStatement<'a> {
        type Inner = WrappedStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> WrappedStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            WrappedStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args WrappedStatementArgs,
        ) -> flatbuffers::WIPOffset<WrappedStatement<'bldr>> {
            let mut builder = WrappedStatementBuilder::new(_fbb);
            if let Some(x) = args.statement {
                builder.add_statement(x);
            }
            builder.add_statement_type(args.statement_type);
            builder.finish()
        }

        pub const VT_STATEMENT_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_STATEMENT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn statement_type(&self) -> Statement {
            self._tab
                .get::<Statement>(WrappedStatement::VT_STATEMENT_TYPE, Some(Statement::NONE))
                .unwrap()
        }
        #[inline]
        pub fn statement(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    WrappedStatement::VT_STATEMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_option_statement(&self) -> Option<OptionStatement<'a>> {
            if self.statement_type() == Statement::OptionStatement {
                self.statement().map(OptionStatement::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_builtin_statement(&self) -> Option<BuiltinStatement<'a>> {
            if self.statement_type() == Statement::BuiltinStatement {
                self.statement().map(BuiltinStatement::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_test_statement(&self) -> Option<TestStatement<'a>> {
            if self.statement_type() == Statement::TestStatement {
                self.statement().map(TestStatement::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_expression_statement(&self) -> Option<ExpressionStatement<'a>> {
            if self.statement_type() == Statement::ExpressionStatement {
                self.statement().map(ExpressionStatement::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_native_variable_assignment(
            &self,
        ) -> Option<NativeVariableAssignment<'a>> {
            if self.statement_type() == Statement::NativeVariableAssignment {
                self.statement()
                    .map(NativeVariableAssignment::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_member_assignment(&self) -> Option<MemberAssignment<'a>> {
            if self.statement_type() == Statement::MemberAssignment {
                self.statement().map(MemberAssignment::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_return_statement(&self) -> Option<ReturnStatement<'a>> {
            if self.statement_type() == Statement::ReturnStatement {
                self.statement().map(ReturnStatement::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for WrappedStatement<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_union::<Statement, _>(&"statement_type", Self::VT_STATEMENT_TYPE, &"statement", Self::VT_STATEMENT, false, |key, v, pos| {
        match key {
          Statement::OptionStatement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OptionStatement>>("Statement::OptionStatement", pos),
          Statement::BuiltinStatement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BuiltinStatement>>("Statement::BuiltinStatement", pos),
          Statement::TestStatement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TestStatement>>("Statement::TestStatement", pos),
          Statement::ExpressionStatement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExpressionStatement>>("Statement::ExpressionStatement", pos),
          Statement::NativeVariableAssignment => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NativeVariableAssignment>>("Statement::NativeVariableAssignment", pos),
          Statement::MemberAssignment => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberAssignment>>("Statement::MemberAssignment", pos),
          Statement::ReturnStatement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReturnStatement>>("Statement::ReturnStatement", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct WrappedStatementArgs {
        pub statement_type: Statement,
        pub statement: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for WrappedStatementArgs {
        #[inline]
        fn default() -> Self {
            WrappedStatementArgs {
                statement_type: Statement::NONE,
                statement: None,
            }
        }
    }
    pub struct WrappedStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> WrappedStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_statement_type(&mut self, statement_type: Statement) {
            self.fbb_.push_slot::<Statement>(
                WrappedStatement::VT_STATEMENT_TYPE,
                statement_type,
                Statement::NONE,
            );
        }
        #[inline]
        pub fn add_statement(
            &mut self,
            statement: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                WrappedStatement::VT_STATEMENT,
                statement,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> WrappedStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            WrappedStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<WrappedStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for WrappedStatement<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("WrappedStatement");
            ds.field("statement_type", &self.statement_type());
            match self.statement_type() {
                Statement::OptionStatement => {
                    if let Some(x) = self.statement_as_option_statement() {
                        ds.field("statement", &x)
                    } else {
                        ds.field(
                            "statement",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Statement::BuiltinStatement => {
                    if let Some(x) = self.statement_as_builtin_statement() {
                        ds.field("statement", &x)
                    } else {
                        ds.field(
                            "statement",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Statement::TestStatement => {
                    if let Some(x) = self.statement_as_test_statement() {
                        ds.field("statement", &x)
                    } else {
                        ds.field(
                            "statement",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Statement::ExpressionStatement => {
                    if let Some(x) = self.statement_as_expression_statement() {
                        ds.field("statement", &x)
                    } else {
                        ds.field(
                            "statement",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Statement::NativeVariableAssignment => {
                    if let Some(x) = self.statement_as_native_variable_assignment() {
                        ds.field("statement", &x)
                    } else {
                        ds.field(
                            "statement",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Statement::MemberAssignment => {
                    if let Some(x) = self.statement_as_member_assignment() {
                        ds.field("statement", &x)
                    } else {
                        ds.field(
                            "statement",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Statement::ReturnStatement => {
                    if let Some(x) = self.statement_as_return_statement() {
                        ds.field("statement", &x)
                    } else {
                        ds.field(
                            "statement",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("statement", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum OptionStatementOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct OptionStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for OptionStatement<'a> {
        type Inner = OptionStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> OptionStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            OptionStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args OptionStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<OptionStatement<'bldr>> {
            let mut builder = OptionStatementBuilder::new(_fbb);
            if let Some(x) = args.assignment {
                builder.add_assignment(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_assignment_type(args.assignment_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ASSIGNMENT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ASSIGNMENT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(OptionStatement::VT_LOC, None)
        }
        #[inline]
        pub fn assignment_type(&self) -> Assignment {
            self._tab
                .get::<Assignment>(OptionStatement::VT_ASSIGNMENT_TYPE, Some(Assignment::NONE))
                .unwrap()
        }
        #[inline]
        pub fn assignment(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    OptionStatement::VT_ASSIGNMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn assignment_as_member_assignment(&self) -> Option<MemberAssignment<'a>> {
            if self.assignment_type() == Assignment::MemberAssignment {
                self.assignment().map(MemberAssignment::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn assignment_as_native_variable_assignment(
            &self,
        ) -> Option<NativeVariableAssignment<'a>> {
            if self.assignment_type() == Assignment::NativeVariableAssignment {
                self.assignment()
                    .map(NativeVariableAssignment::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for OptionStatement<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(&"loc", Self::VT_LOC, false)?
     .visit_union::<Assignment, _>(&"assignment_type", Self::VT_ASSIGNMENT_TYPE, &"assignment", Self::VT_ASSIGNMENT, false, |key, v, pos| {
        match key {
          Assignment::MemberAssignment => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberAssignment>>("Assignment::MemberAssignment", pos),
          Assignment::NativeVariableAssignment => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NativeVariableAssignment>>("Assignment::NativeVariableAssignment", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct OptionStatementArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub assignment_type: Assignment,
        pub assignment: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for OptionStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            OptionStatementArgs {
                loc: None,
                assignment_type: Assignment::NONE,
                assignment: None,
            }
        }
    }
    pub struct OptionStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> OptionStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    OptionStatement::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_assignment_type(&mut self, assignment_type: Assignment) {
            self.fbb_.push_slot::<Assignment>(
                OptionStatement::VT_ASSIGNMENT_TYPE,
                assignment_type,
                Assignment::NONE,
            );
        }
        #[inline]
        pub fn add_assignment(
            &mut self,
            assignment: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                OptionStatement::VT_ASSIGNMENT,
                assignment,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> OptionStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            OptionStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<OptionStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for OptionStatement<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("OptionStatement");
            ds.field("loc", &self.loc());
            ds.field("assignment_type", &self.assignment_type());
            match self.assignment_type() {
                Assignment::MemberAssignment => {
                    if let Some(x) = self.assignment_as_member_assignment() {
                        ds.field("assignment", &x)
                    } else {
                        ds.field(
                            "assignment",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Assignment::NativeVariableAssignment => {
                    if let Some(x) = self.assignment_as_native_variable_assignment() {
                        ds.field("assignment", &x)
                    } else {
                        ds.field(
                            "assignment",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("assignment", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum BuiltinStatementOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BuiltinStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BuiltinStatement<'a> {
        type Inner = BuiltinStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> BuiltinStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BuiltinStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BuiltinStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<BuiltinStatement<'bldr>> {
            let mut builder = BuiltinStatementBuilder::new(_fbb);
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(BuiltinStatement::VT_LOC, None)
        }
        #[inline]
        pub fn id(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(BuiltinStatement::VT_ID, None)
        }
    }

    impl flatbuffers::Verifiable for BuiltinStatement<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(&"id", Self::VT_ID, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BuiltinStatementArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    }
    impl<'a> Default for BuiltinStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            BuiltinStatementArgs {
                loc: None,
                id: None,
            }
        }
    }
    pub struct BuiltinStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BuiltinStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    BuiltinStatement::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    BuiltinStatement::VT_ID,
                    id,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BuiltinStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BuiltinStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BuiltinStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for BuiltinStatement<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("BuiltinStatement");
            ds.field("loc", &self.loc());
            ds.field("id", &self.id());
            ds.finish()
        }
    }
    pub enum TestStatementOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TestStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TestStatement<'a> {
        type Inner = TestStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> TestStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TestStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TestStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<TestStatement<'bldr>> {
            let mut builder = TestStatementBuilder::new(_fbb);
            if let Some(x) = args.assignment {
                builder.add_assignment(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ASSIGNMENT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(TestStatement::VT_LOC, None)
        }
        #[inline]
        pub fn assignment(&self) -> Option<NativeVariableAssignment<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<NativeVariableAssignment>>(
                    TestStatement::VT_ASSIGNMENT,
                    None,
                )
        }
    }

    impl flatbuffers::Verifiable for TestStatement<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<NativeVariableAssignment>>(
                    &"assignment",
                    Self::VT_ASSIGNMENT,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TestStatementArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub assignment: Option<flatbuffers::WIPOffset<NativeVariableAssignment<'a>>>,
    }
    impl<'a> Default for TestStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            TestStatementArgs {
                loc: None,
                assignment: None,
            }
        }
    }
    pub struct TestStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TestStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    TestStatement::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_assignment(
            &mut self,
            assignment: flatbuffers::WIPOffset<NativeVariableAssignment<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<NativeVariableAssignment>>(
                    TestStatement::VT_ASSIGNMENT,
                    assignment,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TestStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TestStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TestStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for TestStatement<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("TestStatement");
            ds.field("loc", &self.loc());
            ds.field("assignment", &self.assignment());
            ds.finish()
        }
    }
    pub enum ExpressionStatementOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ExpressionStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ExpressionStatement<'a> {
        type Inner = ExpressionStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ExpressionStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ExpressionStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ExpressionStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<ExpressionStatement<'bldr>> {
            let mut builder = ExpressionStatementBuilder::new(_fbb);
            if let Some(x) = args.expression {
                builder.add_expression(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_expression_type(args.expression_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_EXPRESSION_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_EXPRESSION: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    ExpressionStatement::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn expression_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    ExpressionStatement::VT_EXPRESSION_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn expression(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ExpressionStatement::VT_EXPRESSION,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.expression_type() == Expression::StringExpression {
                self.expression().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.expression_type() == Expression::ArrayExpression {
                self.expression().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.expression_type() == Expression::DictExpression {
                self.expression().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.expression_type() == Expression::FunctionExpression {
                self.expression().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.expression_type() == Expression::BinaryExpression {
                self.expression().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.expression_type() == Expression::CallExpression {
                self.expression().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.expression_type() == Expression::ConditionalExpression {
                self.expression()
                    .map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.expression_type() == Expression::IdentifierExpression {
                self.expression().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.expression_type() == Expression::LogicalExpression {
                self.expression().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.expression_type() == Expression::MemberExpression {
                self.expression().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.expression_type() == Expression::IndexExpression {
                self.expression().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.expression_type() == Expression::ObjectExpression {
                self.expression().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.expression_type() == Expression::UnaryExpression {
                self.expression().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.expression_type() == Expression::BooleanLiteral {
                self.expression().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.expression_type() == Expression::DateTimeLiteral {
                self.expression().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.expression_type() == Expression::DurationLiteral {
                self.expression().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.expression_type() == Expression::FloatLiteral {
                self.expression().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.expression_type() == Expression::IntegerLiteral {
                self.expression().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.expression_type() == Expression::StringLiteral {
                self.expression().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.expression_type() == Expression::RegexpLiteral {
                self.expression().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.expression_type() == Expression::UnsignedIntegerLiteral {
                self.expression()
                    .map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ExpressionStatement<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(&"loc", Self::VT_LOC, false)?
     .visit_union::<Expression, _>(&"expression_type", Self::VT_EXPRESSION_TYPE, &"expression", Self::VT_EXPRESSION, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct ExpressionStatementArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub expression_type: Expression,
        pub expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ExpressionStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            ExpressionStatementArgs {
                loc: None,
                expression_type: Expression::NONE,
                expression: None,
            }
        }
    }
    pub struct ExpressionStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ExpressionStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    ExpressionStatement::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_expression_type(&mut self, expression_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ExpressionStatement::VT_EXPRESSION_TYPE,
                expression_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_expression(
            &mut self,
            expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ExpressionStatement::VT_EXPRESSION,
                expression,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ExpressionStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ExpressionStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ExpressionStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ExpressionStatement<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ExpressionStatement");
            ds.field("loc", &self.loc());
            ds.field("expression_type", &self.expression_type());
            match self.expression_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.expression_as_string_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.expression_as_array_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.expression_as_dict_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.expression_as_function_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.expression_as_binary_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.expression_as_call_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.expression_as_conditional_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.expression_as_identifier_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.expression_as_logical_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.expression_as_member_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.expression_as_index_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.expression_as_object_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.expression_as_unary_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.expression_as_boolean_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.expression_as_date_time_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.expression_as_duration_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.expression_as_float_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.expression_as_integer_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.expression_as_string_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.expression_as_regexp_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.expression_as_unsigned_integer_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("expression", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum ReturnStatementOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ReturnStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ReturnStatement<'a> {
        type Inner = ReturnStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ReturnStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ReturnStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ReturnStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<ReturnStatement<'bldr>> {
            let mut builder = ReturnStatementBuilder::new(_fbb);
            if let Some(x) = args.argument {
                builder.add_argument(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_argument_type(args.argument_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ARGUMENT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ARGUMENT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(ReturnStatement::VT_LOC, None)
        }
        #[inline]
        pub fn argument_type(&self) -> Expression {
            self._tab
                .get::<Expression>(ReturnStatement::VT_ARGUMENT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn argument(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ReturnStatement::VT_ARGUMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.argument_type() == Expression::StringExpression {
                self.argument().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.argument_type() == Expression::ArrayExpression {
                self.argument().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.argument_type() == Expression::DictExpression {
                self.argument().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.argument_type() == Expression::FunctionExpression {
                self.argument().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.argument_type() == Expression::BinaryExpression {
                self.argument().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.argument_type() == Expression::CallExpression {
                self.argument().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.argument_type() == Expression::ConditionalExpression {
                self.argument().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.argument_type() == Expression::IdentifierExpression {
                self.argument().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.argument_type() == Expression::LogicalExpression {
                self.argument().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.argument_type() == Expression::MemberExpression {
                self.argument().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.argument_type() == Expression::IndexExpression {
                self.argument().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.argument_type() == Expression::ObjectExpression {
                self.argument().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.argument_type() == Expression::UnaryExpression {
                self.argument().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.argument_type() == Expression::BooleanLiteral {
                self.argument().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.argument_type() == Expression::DateTimeLiteral {
                self.argument().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.argument_type() == Expression::DurationLiteral {
                self.argument().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.argument_type() == Expression::FloatLiteral {
                self.argument().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.argument_type() == Expression::IntegerLiteral {
                self.argument().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.argument_type() == Expression::StringLiteral {
                self.argument().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.argument_type() == Expression::RegexpLiteral {
                self.argument().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.argument_type() == Expression::UnsignedIntegerLiteral {
                self.argument().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ReturnStatement<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(&"loc", Self::VT_LOC, false)?
     .visit_union::<Expression, _>(&"argument_type", Self::VT_ARGUMENT_TYPE, &"argument", Self::VT_ARGUMENT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct ReturnStatementArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub argument_type: Expression,
        pub argument: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ReturnStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            ReturnStatementArgs {
                loc: None,
                argument_type: Expression::NONE,
                argument: None,
            }
        }
    }
    pub struct ReturnStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ReturnStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    ReturnStatement::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_argument_type(&mut self, argument_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ReturnStatement::VT_ARGUMENT_TYPE,
                argument_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_argument(
            &mut self,
            argument: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ReturnStatement::VT_ARGUMENT,
                argument,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ReturnStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ReturnStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ReturnStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ReturnStatement<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ReturnStatement");
            ds.field("loc", &self.loc());
            ds.field("argument_type", &self.argument_type());
            match self.argument_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.argument_as_string_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.argument_as_array_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.argument_as_dict_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.argument_as_function_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.argument_as_binary_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.argument_as_call_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.argument_as_conditional_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.argument_as_identifier_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.argument_as_logical_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.argument_as_member_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.argument_as_index_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.argument_as_object_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.argument_as_unary_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.argument_as_boolean_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.argument_as_date_time_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.argument_as_duration_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.argument_as_float_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.argument_as_integer_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.argument_as_string_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.argument_as_regexp_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.argument_as_unsigned_integer_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("argument", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum NativeVariableAssignmentOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NativeVariableAssignment<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NativeVariableAssignment<'a> {
        type Inner = NativeVariableAssignment<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> NativeVariableAssignment<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NativeVariableAssignment { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args NativeVariableAssignmentArgs<'args>,
        ) -> flatbuffers::WIPOffset<NativeVariableAssignment<'bldr>> {
            let mut builder = NativeVariableAssignmentBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.init_ {
                builder.add_init_(x);
            }
            if let Some(x) = args.identifier {
                builder.add_identifier(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_init__type(args.init__type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_IDENTIFIER: flatbuffers::VOffsetT = 6;
        pub const VT_INIT__TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_INIT_: flatbuffers::VOffsetT = 10;
        pub const VT_TYP: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    NativeVariableAssignment::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn identifier(&self) -> Option<Identifier<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(
                NativeVariableAssignment::VT_IDENTIFIER,
                None,
            )
        }
        #[inline]
        pub fn init__type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    NativeVariableAssignment::VT_INIT__TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn init_(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    NativeVariableAssignment::VT_INIT_,
                    None,
                )
        }
        #[inline]
        pub fn typ(&self) -> Option<PolyType<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<PolyType>>(
                NativeVariableAssignment::VT_TYP,
                None,
            )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.init__type() == Expression::StringExpression {
                self.init_().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.init__type() == Expression::ArrayExpression {
                self.init_().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.init__type() == Expression::DictExpression {
                self.init_().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.init__type() == Expression::FunctionExpression {
                self.init_().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.init__type() == Expression::BinaryExpression {
                self.init_().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.init__type() == Expression::CallExpression {
                self.init_().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.init__type() == Expression::ConditionalExpression {
                self.init_().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.init__type() == Expression::IdentifierExpression {
                self.init_().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.init__type() == Expression::LogicalExpression {
                self.init_().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.init__type() == Expression::MemberExpression {
                self.init_().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.init__type() == Expression::IndexExpression {
                self.init_().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.init__type() == Expression::ObjectExpression {
                self.init_().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.init__type() == Expression::UnaryExpression {
                self.init_().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.init__type() == Expression::BooleanLiteral {
                self.init_().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.init__type() == Expression::DateTimeLiteral {
                self.init_().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.init__type() == Expression::DurationLiteral {
                self.init_().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.init__type() == Expression::FloatLiteral {
                self.init_().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.init__type() == Expression::IntegerLiteral {
                self.init_().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.init__type() == Expression::StringLiteral {
                self.init_().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.init__type() == Expression::RegexpLiteral {
                self.init_().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.init__type() == Expression::UnsignedIntegerLiteral {
                self.init_().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for NativeVariableAssignment<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(&"loc", Self::VT_LOC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(&"identifier", Self::VT_IDENTIFIER, false)?
     .visit_union::<Expression, _>(&"init__type", Self::VT_INIT__TYPE, &"init_", Self::VT_INIT_, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<PolyType>>(&"typ", Self::VT_TYP, false)?
     .finish();
            Ok(())
        }
    }
    pub struct NativeVariableAssignmentArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub identifier: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub init__type: Expression,
        pub init_: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub typ: Option<flatbuffers::WIPOffset<PolyType<'a>>>,
    }
    impl<'a> Default for NativeVariableAssignmentArgs<'a> {
        #[inline]
        fn default() -> Self {
            NativeVariableAssignmentArgs {
                loc: None,
                identifier: None,
                init__type: Expression::NONE,
                init_: None,
                typ: None,
            }
        }
    }
    pub struct NativeVariableAssignmentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NativeVariableAssignmentBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    NativeVariableAssignment::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_identifier(&mut self, identifier: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    NativeVariableAssignment::VT_IDENTIFIER,
                    identifier,
                );
        }
        #[inline]
        pub fn add_init__type(&mut self, init__type: Expression) {
            self.fbb_.push_slot::<Expression>(
                NativeVariableAssignment::VT_INIT__TYPE,
                init__type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_init_(&mut self, init_: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NativeVariableAssignment::VT_INIT_,
                init_,
            );
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<PolyType<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<PolyType>>(
                    NativeVariableAssignment::VT_TYP,
                    typ,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> NativeVariableAssignmentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            NativeVariableAssignmentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NativeVariableAssignment<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for NativeVariableAssignment<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("NativeVariableAssignment");
            ds.field("loc", &self.loc());
            ds.field("identifier", &self.identifier());
            ds.field("init__type", &self.init__type());
            match self.init__type() {
                Expression::StringExpression => {
                    if let Some(x) = self.init__as_string_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.init__as_array_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.init__as_dict_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.init__as_function_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.init__as_binary_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.init__as_call_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.init__as_conditional_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.init__as_identifier_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.init__as_logical_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.init__as_member_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.init__as_index_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.init__as_object_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.init__as_unary_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.init__as_boolean_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.init__as_date_time_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.init__as_duration_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.init__as_float_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.init__as_integer_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.init__as_string_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.init__as_regexp_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.init__as_unsigned_integer_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("init_", &x)
                }
            };
            ds.field("typ", &self.typ());
            ds.finish()
        }
    }
    pub enum MemberAssignmentOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MemberAssignment<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MemberAssignment<'a> {
        type Inner = MemberAssignment<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> MemberAssignment<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MemberAssignment { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MemberAssignmentArgs<'args>,
        ) -> flatbuffers::WIPOffset<MemberAssignment<'bldr>> {
            let mut builder = MemberAssignmentBuilder::new(_fbb);
            if let Some(x) = args.init_ {
                builder.add_init_(x);
            }
            if let Some(x) = args.member {
                builder.add_member(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_init__type(args.init__type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_MEMBER: flatbuffers::VOffsetT = 6;
        pub const VT_INIT__TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_INIT_: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(MemberAssignment::VT_LOC, None)
        }
        #[inline]
        pub fn member(&self) -> Option<MemberExpression<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<MemberExpression>>(
                    MemberAssignment::VT_MEMBER,
                    None,
                )
        }
        #[inline]
        pub fn init__type(&self) -> Expression {
            self._tab
                .get::<Expression>(MemberAssignment::VT_INIT__TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn init_(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    MemberAssignment::VT_INIT_,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.init__type() == Expression::StringExpression {
                self.init_().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.init__type() == Expression::ArrayExpression {
                self.init_().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.init__type() == Expression::DictExpression {
                self.init_().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.init__type() == Expression::FunctionExpression {
                self.init_().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.init__type() == Expression::BinaryExpression {
                self.init_().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.init__type() == Expression::CallExpression {
                self.init_().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.init__type() == Expression::ConditionalExpression {
                self.init_().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.init__type() == Expression::IdentifierExpression {
                self.init_().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.init__type() == Expression::LogicalExpression {
                self.init_().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.init__type() == Expression::MemberExpression {
                self.init_().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.init__type() == Expression::IndexExpression {
                self.init_().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.init__type() == Expression::ObjectExpression {
                self.init_().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.init__type() == Expression::UnaryExpression {
                self.init_().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.init__type() == Expression::BooleanLiteral {
                self.init_().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.init__type() == Expression::DateTimeLiteral {
                self.init_().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.init__type() == Expression::DurationLiteral {
                self.init_().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.init__type() == Expression::FloatLiteral {
                self.init_().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.init__type() == Expression::IntegerLiteral {
                self.init_().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.init__type() == Expression::StringLiteral {
                self.init_().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.init__type() == Expression::RegexpLiteral {
                self.init_().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.init__type() == Expression::UnsignedIntegerLiteral {
                self.init_().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for MemberAssignment<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(&"loc", Self::VT_LOC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<MemberExpression>>(&"member", Self::VT_MEMBER, false)?
     .visit_union::<Expression, _>(&"init__type", Self::VT_INIT__TYPE, &"init_", Self::VT_INIT_, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct MemberAssignmentArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub member: Option<flatbuffers::WIPOffset<MemberExpression<'a>>>,
        pub init__type: Expression,
        pub init_: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for MemberAssignmentArgs<'a> {
        #[inline]
        fn default() -> Self {
            MemberAssignmentArgs {
                loc: None,
                member: None,
                init__type: Expression::NONE,
                init_: None,
            }
        }
    }
    pub struct MemberAssignmentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MemberAssignmentBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    MemberAssignment::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_member(&mut self, member: flatbuffers::WIPOffset<MemberExpression<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<MemberExpression>>(
                    MemberAssignment::VT_MEMBER,
                    member,
                );
        }
        #[inline]
        pub fn add_init__type(&mut self, init__type: Expression) {
            self.fbb_.push_slot::<Expression>(
                MemberAssignment::VT_INIT__TYPE,
                init__type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_init_(&mut self, init_: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MemberAssignment::VT_INIT_, init_);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MemberAssignmentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MemberAssignmentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MemberAssignment<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for MemberAssignment<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("MemberAssignment");
            ds.field("loc", &self.loc());
            ds.field("member", &self.member());
            ds.field("init__type", &self.init__type());
            match self.init__type() {
                Expression::StringExpression => {
                    if let Some(x) = self.init__as_string_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.init__as_array_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.init__as_dict_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.init__as_function_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.init__as_binary_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.init__as_call_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.init__as_conditional_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.init__as_identifier_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.init__as_logical_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.init__as_member_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.init__as_index_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.init__as_object_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.init__as_unary_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.init__as_boolean_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.init__as_date_time_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.init__as_duration_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.init__as_float_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.init__as_integer_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.init__as_string_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.init__as_regexp_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.init__as_unsigned_integer_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("init_", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum WrappedExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct WrappedExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for WrappedExpression<'a> {
        type Inner = WrappedExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> WrappedExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            WrappedExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args WrappedExpressionArgs,
        ) -> flatbuffers::WIPOffset<WrappedExpression<'bldr>> {
            let mut builder = WrappedExpressionBuilder::new(_fbb);
            if let Some(x) = args.expression {
                builder.add_expression(x);
            }
            builder.add_expression_type(args.expression_type);
            builder.finish()
        }

        pub const VT_EXPRESSION_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_EXPRESSION: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn expression_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    WrappedExpression::VT_EXPRESSION_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn expression(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    WrappedExpression::VT_EXPRESSION,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.expression_type() == Expression::StringExpression {
                self.expression().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.expression_type() == Expression::ArrayExpression {
                self.expression().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.expression_type() == Expression::DictExpression {
                self.expression().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.expression_type() == Expression::FunctionExpression {
                self.expression().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.expression_type() == Expression::BinaryExpression {
                self.expression().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.expression_type() == Expression::CallExpression {
                self.expression().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.expression_type() == Expression::ConditionalExpression {
                self.expression()
                    .map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.expression_type() == Expression::IdentifierExpression {
                self.expression().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.expression_type() == Expression::LogicalExpression {
                self.expression().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.expression_type() == Expression::MemberExpression {
                self.expression().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.expression_type() == Expression::IndexExpression {
                self.expression().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.expression_type() == Expression::ObjectExpression {
                self.expression().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.expression_type() == Expression::UnaryExpression {
                self.expression().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.expression_type() == Expression::BooleanLiteral {
                self.expression().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.expression_type() == Expression::DateTimeLiteral {
                self.expression().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.expression_type() == Expression::DurationLiteral {
                self.expression().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.expression_type() == Expression::FloatLiteral {
                self.expression().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.expression_type() == Expression::IntegerLiteral {
                self.expression().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.expression_type() == Expression::StringLiteral {
                self.expression().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.expression_type() == Expression::RegexpLiteral {
                self.expression().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.expression_type() == Expression::UnsignedIntegerLiteral {
                self.expression()
                    .map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for WrappedExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_union::<Expression, _>(&"expression_type", Self::VT_EXPRESSION_TYPE, &"expression", Self::VT_EXPRESSION, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct WrappedExpressionArgs {
        pub expression_type: Expression,
        pub expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for WrappedExpressionArgs {
        #[inline]
        fn default() -> Self {
            WrappedExpressionArgs {
                expression_type: Expression::NONE,
                expression: None,
            }
        }
    }
    pub struct WrappedExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> WrappedExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_expression_type(&mut self, expression_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                WrappedExpression::VT_EXPRESSION_TYPE,
                expression_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_expression(
            &mut self,
            expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                WrappedExpression::VT_EXPRESSION,
                expression,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> WrappedExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            WrappedExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<WrappedExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for WrappedExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("WrappedExpression");
            ds.field("expression_type", &self.expression_type());
            match self.expression_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.expression_as_string_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.expression_as_array_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.expression_as_dict_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.expression_as_function_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.expression_as_binary_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.expression_as_call_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.expression_as_conditional_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.expression_as_identifier_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.expression_as_logical_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.expression_as_member_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.expression_as_index_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.expression_as_object_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.expression_as_unary_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.expression_as_boolean_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.expression_as_date_time_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.expression_as_duration_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.expression_as_float_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.expression_as_integer_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.expression_as_string_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.expression_as_regexp_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.expression_as_unsigned_integer_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("expression", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum StringExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct StringExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StringExpression<'a> {
        type Inner = StringExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> StringExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StringExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StringExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<StringExpression<'bldr>> {
            let mut builder = StringExpressionBuilder::new(_fbb);
            if let Some(x) = args.parts {
                builder.add_parts(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_PARTS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(StringExpression::VT_LOC, None)
        }
        #[inline]
        pub fn parts(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringExpressionPart<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringExpressionPart>>,
            >>(StringExpression::VT_PARTS, None)
        }
    }

    impl flatbuffers::Verifiable for StringExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringExpressionPart>>,
                >>(&"parts", Self::VT_PARTS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct StringExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub parts: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringExpressionPart<'a>>>,
            >,
        >,
    }
    impl<'a> Default for StringExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            StringExpressionArgs {
                loc: None,
                parts: None,
            }
        }
    }
    pub struct StringExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StringExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    StringExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_parts(
            &mut self,
            parts: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<StringExpressionPart<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(StringExpression::VT_PARTS, parts);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> StringExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StringExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StringExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for StringExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("StringExpression");
            ds.field("loc", &self.loc());
            ds.field("parts", &self.parts());
            ds.finish()
        }
    }
    pub enum StringExpressionPartOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct StringExpressionPart<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StringExpressionPart<'a> {
        type Inner = StringExpressionPart<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> StringExpressionPart<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StringExpressionPart { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StringExpressionPartArgs<'args>,
        ) -> flatbuffers::WIPOffset<StringExpressionPart<'bldr>> {
            let mut builder = StringExpressionPartBuilder::new(_fbb);
            if let Some(x) = args.interpolated_expression {
                builder.add_interpolated_expression(x);
            }
            if let Some(x) = args.text_value {
                builder.add_text_value(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_interpolated_expression_type(args.interpolated_expression_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_TEXT_VALUE: flatbuffers::VOffsetT = 6;
        pub const VT_INTERPOLATED_EXPRESSION_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_INTERPOLATED_EXPRESSION: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    StringExpressionPart::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn text_value(&self) -> Option<&'a str> {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                StringExpressionPart::VT_TEXT_VALUE,
                None,
            )
        }
        #[inline]
        pub fn interpolated_expression_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    StringExpressionPart::VT_INTERPOLATED_EXPRESSION_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn interpolated_expression(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    StringExpressionPart::VT_INTERPOLATED_EXPRESSION,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.interpolated_expression_type() == Expression::StringExpression {
                self.interpolated_expression()
                    .map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.interpolated_expression_type() == Expression::ArrayExpression {
                self.interpolated_expression()
                    .map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.interpolated_expression_type() == Expression::DictExpression {
                self.interpolated_expression()
                    .map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_function_expression(
            &self,
        ) -> Option<FunctionExpression<'a>> {
            if self.interpolated_expression_type() == Expression::FunctionExpression {
                self.interpolated_expression()
                    .map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.interpolated_expression_type() == Expression::BinaryExpression {
                self.interpolated_expression()
                    .map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.interpolated_expression_type() == Expression::CallExpression {
                self.interpolated_expression()
                    .map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_conditional_expression(
            &self,
        ) -> Option<ConditionalExpression<'a>> {
            if self.interpolated_expression_type() == Expression::ConditionalExpression {
                self.interpolated_expression()
                    .map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_identifier_expression(
            &self,
        ) -> Option<IdentifierExpression<'a>> {
            if self.interpolated_expression_type() == Expression::IdentifierExpression {
                self.interpolated_expression()
                    .map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_logical_expression(
            &self,
        ) -> Option<LogicalExpression<'a>> {
            if self.interpolated_expression_type() == Expression::LogicalExpression {
                self.interpolated_expression()
                    .map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.interpolated_expression_type() == Expression::MemberExpression {
                self.interpolated_expression()
                    .map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.interpolated_expression_type() == Expression::IndexExpression {
                self.interpolated_expression()
                    .map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.interpolated_expression_type() == Expression::ObjectExpression {
                self.interpolated_expression()
                    .map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.interpolated_expression_type() == Expression::UnaryExpression {
                self.interpolated_expression()
                    .map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::BooleanLiteral {
                self.interpolated_expression()
                    .map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::DateTimeLiteral {
                self.interpolated_expression()
                    .map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::DurationLiteral {
                self.interpolated_expression()
                    .map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::FloatLiteral {
                self.interpolated_expression()
                    .map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::IntegerLiteral {
                self.interpolated_expression()
                    .map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::StringLiteral {
                self.interpolated_expression()
                    .map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::RegexpLiteral {
                self.interpolated_expression()
                    .map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_unsigned_integer_literal(
            &self,
        ) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::UnsignedIntegerLiteral {
                self.interpolated_expression()
                    .map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for StringExpressionPart<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(&"loc", Self::VT_LOC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"text_value", Self::VT_TEXT_VALUE, false)?
     .visit_union::<Expression, _>(&"interpolated_expression_type", Self::VT_INTERPOLATED_EXPRESSION_TYPE, &"interpolated_expression", Self::VT_INTERPOLATED_EXPRESSION, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct StringExpressionPartArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub text_value: Option<flatbuffers::WIPOffset<&'a str>>,
        pub interpolated_expression_type: Expression,
        pub interpolated_expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for StringExpressionPartArgs<'a> {
        #[inline]
        fn default() -> Self {
            StringExpressionPartArgs {
                loc: None,
                text_value: None,
                interpolated_expression_type: Expression::NONE,
                interpolated_expression: None,
            }
        }
    }
    pub struct StringExpressionPartBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StringExpressionPartBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    StringExpressionPart::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_text_value(&mut self, text_value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                StringExpressionPart::VT_TEXT_VALUE,
                text_value,
            );
        }
        #[inline]
        pub fn add_interpolated_expression_type(
            &mut self,
            interpolated_expression_type: Expression,
        ) {
            self.fbb_.push_slot::<Expression>(
                StringExpressionPart::VT_INTERPOLATED_EXPRESSION_TYPE,
                interpolated_expression_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_interpolated_expression(
            &mut self,
            interpolated_expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                StringExpressionPart::VT_INTERPOLATED_EXPRESSION,
                interpolated_expression,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> StringExpressionPartBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StringExpressionPartBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StringExpressionPart<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for StringExpressionPart<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("StringExpressionPart");
            ds.field("loc", &self.loc());
            ds.field("text_value", &self.text_value());
            ds.field(
                "interpolated_expression_type",
                &self.interpolated_expression_type(),
            );
            match self.interpolated_expression_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.interpolated_expression_as_string_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.interpolated_expression_as_array_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.interpolated_expression_as_dict_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.interpolated_expression_as_function_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.interpolated_expression_as_binary_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.interpolated_expression_as_call_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.interpolated_expression_as_conditional_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.interpolated_expression_as_identifier_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.interpolated_expression_as_logical_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.interpolated_expression_as_member_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.interpolated_expression_as_index_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.interpolated_expression_as_object_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.interpolated_expression_as_unary_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.interpolated_expression_as_boolean_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.interpolated_expression_as_date_time_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.interpolated_expression_as_duration_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.interpolated_expression_as_float_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.interpolated_expression_as_integer_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.interpolated_expression_as_string_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.interpolated_expression_as_regexp_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.interpolated_expression_as_unsigned_integer_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("interpolated_expression", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum ArrayExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ArrayExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ArrayExpression<'a> {
        type Inner = ArrayExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ArrayExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ArrayExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ArrayExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<ArrayExpression<'bldr>> {
            let mut builder = ArrayExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.elements {
                builder.add_elements(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ELEMENTS: flatbuffers::VOffsetT = 6;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_TYP: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(ArrayExpression::VT_LOC, None)
        }
        #[inline]
        pub fn elements(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedExpression<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedExpression>>,
            >>(ArrayExpression::VT_ELEMENTS, None)
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(ArrayExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ArrayExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_record(&self) -> Option<Record<'a>> {
            if self.typ_type() == MonoType::Record {
                self.typ().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_dict(&self) -> Option<Dict<'a>> {
            if self.typ_type() == MonoType::Dict {
                self.typ().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_vector(&self) -> Option<Vector<'a>> {
            if self.typ_type() == MonoType::Vector {
                self.typ().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ArrayExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WrappedExpression>>,
                >>(&"elements", Self::VT_ELEMENTS, false)?
                .visit_union::<MonoType, _>(
                    &"typ_type",
                    Self::VT_TYP_TYPE,
                    &"typ",
                    Self::VT_TYP,
                    false,
                    |key, v, pos| match key {
                        MonoType::Basic => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>(
                                "MonoType::Basic",
                                pos,
                            ),
                        MonoType::Var => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>(
                                "MonoType::Var",
                                pos,
                            ),
                        MonoType::Arr => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>(
                                "MonoType::Arr",
                                pos,
                            ),
                        MonoType::Record => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>(
                                "MonoType::Record",
                                pos,
                            ),
                        MonoType::Fun => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>(
                                "MonoType::Fun",
                                pos,
                            ),
                        MonoType::Dict => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>(
                                "MonoType::Dict",
                                pos,
                            ),
                        MonoType::Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>(
                                "MonoType::Vector",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ArrayExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub elements: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedExpression<'a>>>,
            >,
        >,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ArrayExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            ArrayExpressionArgs {
                loc: None,
                elements: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct ArrayExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ArrayExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    ArrayExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_elements(
            &mut self,
            elements: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<WrappedExpression<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ArrayExpression::VT_ELEMENTS,
                elements,
            );
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(ArrayExpression::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ArrayExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ArrayExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ArrayExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ArrayExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ArrayExpression");
            ds.field("loc", &self.loc());
            ds.field("elements", &self.elements());
            ds.field("typ_type", &self.typ_type());
            match self.typ_type() {
                MonoType::Basic => {
                    if let Some(x) = self.typ_as_basic() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.typ_as_var() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.typ_as_arr() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.typ_as_record() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.typ_as_fun() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.typ_as_dict() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.typ_as_vector() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("typ", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum DictExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DictExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DictExpression<'a> {
        type Inner = DictExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> DictExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DictExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DictExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<DictExpression<'bldr>> {
            let mut builder = DictExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.elements {
                builder.add_elements(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ELEMENTS: flatbuffers::VOffsetT = 6;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_TYP: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(DictExpression::VT_LOC, None)
        }
        #[inline]
        pub fn elements(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DictItem<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DictItem>>,
            >>(DictExpression::VT_ELEMENTS, None)
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(DictExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    DictExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_record(&self) -> Option<Record<'a>> {
            if self.typ_type() == MonoType::Record {
                self.typ().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_dict(&self) -> Option<Dict<'a>> {
            if self.typ_type() == MonoType::Dict {
                self.typ().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_vector(&self) -> Option<Vector<'a>> {
            if self.typ_type() == MonoType::Vector {
                self.typ().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for DictExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DictItem>>,
                >>(&"elements", Self::VT_ELEMENTS, false)?
                .visit_union::<MonoType, _>(
                    &"typ_type",
                    Self::VT_TYP_TYPE,
                    &"typ",
                    Self::VT_TYP,
                    false,
                    |key, v, pos| match key {
                        MonoType::Basic => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>(
                                "MonoType::Basic",
                                pos,
                            ),
                        MonoType::Var => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>(
                                "MonoType::Var",
                                pos,
                            ),
                        MonoType::Arr => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>(
                                "MonoType::Arr",
                                pos,
                            ),
                        MonoType::Record => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>(
                                "MonoType::Record",
                                pos,
                            ),
                        MonoType::Fun => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>(
                                "MonoType::Fun",
                                pos,
                            ),
                        MonoType::Dict => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>(
                                "MonoType::Dict",
                                pos,
                            ),
                        MonoType::Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>(
                                "MonoType::Vector",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct DictExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub elements: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DictItem<'a>>>,
            >,
        >,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for DictExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            DictExpressionArgs {
                loc: None,
                elements: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct DictExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DictExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    DictExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_elements(
            &mut self,
            elements: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DictItem<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                DictExpression::VT_ELEMENTS,
                elements,
            );
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(DictExpression::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DictExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DictExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DictExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DictExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for DictExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("DictExpression");
            ds.field("loc", &self.loc());
            ds.field("elements", &self.elements());
            ds.field("typ_type", &self.typ_type());
            match self.typ_type() {
                MonoType::Basic => {
                    if let Some(x) = self.typ_as_basic() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.typ_as_var() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.typ_as_arr() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.typ_as_record() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.typ_as_fun() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.typ_as_dict() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.typ_as_vector() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("typ", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum DictItemOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DictItem<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DictItem<'a> {
        type Inner = DictItem<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> DictItem<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DictItem { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DictItemArgs,
        ) -> flatbuffers::WIPOffset<DictItem<'bldr>> {
            let mut builder = DictItemBuilder::new(_fbb);
            if let Some(x) = args.val {
                builder.add_val(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.add_val_type(args.val_type);
            builder.add_key_type(args.key_type);
            builder.finish()
        }

        pub const VT_KEY_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_KEY: flatbuffers::VOffsetT = 6;
        pub const VT_VAL_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_VAL: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn key_type(&self) -> Expression {
            self._tab
                .get::<Expression>(DictItem::VT_KEY_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn key(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DictItem::VT_KEY, None)
        }
        #[inline]
        pub fn val_type(&self) -> Expression {
            self._tab
                .get::<Expression>(DictItem::VT_VAL_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn val(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DictItem::VT_VAL, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.key_type() == Expression::StringExpression {
                self.key().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.key_type() == Expression::ArrayExpression {
                self.key().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.key_type() == Expression::DictExpression {
                self.key().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.key_type() == Expression::FunctionExpression {
                self.key().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.key_type() == Expression::BinaryExpression {
                self.key().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.key_type() == Expression::CallExpression {
                self.key().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.key_type() == Expression::ConditionalExpression {
                self.key().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.key_type() == Expression::IdentifierExpression {
                self.key().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.key_type() == Expression::LogicalExpression {
                self.key().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.key_type() == Expression::MemberExpression {
                self.key().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.key_type() == Expression::IndexExpression {
                self.key().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.key_type() == Expression::ObjectExpression {
                self.key().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.key_type() == Expression::UnaryExpression {
                self.key().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.key_type() == Expression::BooleanLiteral {
                self.key().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.key_type() == Expression::DateTimeLiteral {
                self.key().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.key_type() == Expression::DurationLiteral {
                self.key().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.key_type() == Expression::FloatLiteral {
                self.key().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.key_type() == Expression::IntegerLiteral {
                self.key().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.key_type() == Expression::StringLiteral {
                self.key().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.key_type() == Expression::RegexpLiteral {
                self.key().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.key_type() == Expression::UnsignedIntegerLiteral {
                self.key().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.val_type() == Expression::StringExpression {
                self.val().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.val_type() == Expression::ArrayExpression {
                self.val().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.val_type() == Expression::DictExpression {
                self.val().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.val_type() == Expression::FunctionExpression {
                self.val().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.val_type() == Expression::BinaryExpression {
                self.val().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.val_type() == Expression::CallExpression {
                self.val().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.val_type() == Expression::ConditionalExpression {
                self.val().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.val_type() == Expression::IdentifierExpression {
                self.val().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.val_type() == Expression::LogicalExpression {
                self.val().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.val_type() == Expression::MemberExpression {
                self.val().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.val_type() == Expression::IndexExpression {
                self.val().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.val_type() == Expression::ObjectExpression {
                self.val().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.val_type() == Expression::UnaryExpression {
                self.val().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.val_type() == Expression::BooleanLiteral {
                self.val().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.val_type() == Expression::DateTimeLiteral {
                self.val().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.val_type() == Expression::DurationLiteral {
                self.val().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.val_type() == Expression::FloatLiteral {
                self.val().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.val_type() == Expression::IntegerLiteral {
                self.val().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.val_type() == Expression::StringLiteral {
                self.val().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.val_type() == Expression::RegexpLiteral {
                self.val().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.val_type() == Expression::UnsignedIntegerLiteral {
                self.val().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for DictItem<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_union::<Expression, _>(&"key_type", Self::VT_KEY_TYPE, &"key", Self::VT_KEY, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Expression, _>(&"val_type", Self::VT_VAL_TYPE, &"val", Self::VT_VAL, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct DictItemArgs {
        pub key_type: Expression,
        pub key: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub val_type: Expression,
        pub val: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for DictItemArgs {
        #[inline]
        fn default() -> Self {
            DictItemArgs {
                key_type: Expression::NONE,
                key: None,
                val_type: Expression::NONE,
                val: None,
            }
        }
    }
    pub struct DictItemBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DictItemBuilder<'a, 'b> {
        #[inline]
        pub fn add_key_type(&mut self, key_type: Expression) {
            self.fbb_
                .push_slot::<Expression>(DictItem::VT_KEY_TYPE, key_type, Expression::NONE);
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DictItem::VT_KEY, key);
        }
        #[inline]
        pub fn add_val_type(&mut self, val_type: Expression) {
            self.fbb_
                .push_slot::<Expression>(DictItem::VT_VAL_TYPE, val_type, Expression::NONE);
        }
        #[inline]
        pub fn add_val(&mut self, val: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DictItem::VT_VAL, val);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DictItemBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DictItemBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DictItem<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for DictItem<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("DictItem");
            ds.field("key_type", &self.key_type());
            match self.key_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.key_as_string_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.key_as_array_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.key_as_dict_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.key_as_function_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.key_as_binary_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.key_as_call_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.key_as_conditional_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.key_as_identifier_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.key_as_logical_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.key_as_member_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.key_as_index_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.key_as_object_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.key_as_unary_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.key_as_boolean_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.key_as_date_time_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.key_as_duration_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.key_as_float_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.key_as_integer_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.key_as_string_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.key_as_regexp_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.key_as_unsigned_integer_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("key", &x)
                }
            };
            ds.field("val_type", &self.val_type());
            match self.val_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.val_as_string_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.val_as_array_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.val_as_dict_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.val_as_function_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.val_as_binary_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.val_as_call_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.val_as_conditional_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.val_as_identifier_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.val_as_logical_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.val_as_member_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.val_as_index_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.val_as_object_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.val_as_unary_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.val_as_boolean_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.val_as_date_time_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.val_as_duration_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.val_as_float_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.val_as_integer_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.val_as_string_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.val_as_regexp_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.val_as_unsigned_integer_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("val", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum FunctionExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FunctionExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FunctionExpression<'a> {
        type Inner = FunctionExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> FunctionExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FunctionExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FunctionExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<FunctionExpression<'bldr>> {
            let mut builder = FunctionExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.params {
                builder.add_params(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_PARAMS: flatbuffers::VOffsetT = 6;
        pub const VT_BODY: flatbuffers::VOffsetT = 8;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_TYP: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    FunctionExpression::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn params(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctionParameter<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctionParameter>>,
            >>(FunctionExpression::VT_PARAMS, None)
        }
        #[inline]
        pub fn body(&self) -> Option<Block<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Block>>(FunctionExpression::VT_BODY, None)
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(FunctionExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    FunctionExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_record(&self) -> Option<Record<'a>> {
            if self.typ_type() == MonoType::Record {
                self.typ().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_dict(&self) -> Option<Dict<'a>> {
            if self.typ_type() == MonoType::Dict {
                self.typ().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_vector(&self) -> Option<Vector<'a>> {
            if self.typ_type() == MonoType::Vector {
                self.typ().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for FunctionExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FunctionParameter>>,
                >>(&"params", Self::VT_PARAMS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Block>>(&"body", Self::VT_BODY, false)?
                .visit_union::<MonoType, _>(
                    &"typ_type",
                    Self::VT_TYP_TYPE,
                    &"typ",
                    Self::VT_TYP,
                    false,
                    |key, v, pos| match key {
                        MonoType::Basic => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>(
                                "MonoType::Basic",
                                pos,
                            ),
                        MonoType::Var => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>(
                                "MonoType::Var",
                                pos,
                            ),
                        MonoType::Arr => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>(
                                "MonoType::Arr",
                                pos,
                            ),
                        MonoType::Record => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>(
                                "MonoType::Record",
                                pos,
                            ),
                        MonoType::Fun => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>(
                                "MonoType::Fun",
                                pos,
                            ),
                        MonoType::Dict => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>(
                                "MonoType::Dict",
                                pos,
                            ),
                        MonoType::Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>(
                                "MonoType::Vector",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct FunctionExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub params: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctionParameter<'a>>>,
            >,
        >,
        pub body: Option<flatbuffers::WIPOffset<Block<'a>>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for FunctionExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            FunctionExpressionArgs {
                loc: None,
                params: None,
                body: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct FunctionExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FunctionExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    FunctionExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_params(
            &mut self,
            params: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<FunctionParameter<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                FunctionExpression::VT_PARAMS,
                params,
            );
        }
        #[inline]
        pub fn add_body(&mut self, body: flatbuffers::WIPOffset<Block<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Block>>(
                FunctionExpression::VT_BODY,
                body,
            );
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                FunctionExpression::VT_TYP_TYPE,
                typ_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FunctionExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FunctionExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FunctionExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for FunctionExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("FunctionExpression");
            ds.field("loc", &self.loc());
            ds.field("params", &self.params());
            ds.field("body", &self.body());
            ds.field("typ_type", &self.typ_type());
            match self.typ_type() {
                MonoType::Basic => {
                    if let Some(x) = self.typ_as_basic() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.typ_as_var() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.typ_as_arr() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.typ_as_record() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.typ_as_fun() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.typ_as_dict() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.typ_as_vector() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("typ", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum FunctionParameterOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FunctionParameter<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FunctionParameter<'a> {
        type Inner = FunctionParameter<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> FunctionParameter<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FunctionParameter { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FunctionParameterArgs<'args>,
        ) -> flatbuffers::WIPOffset<FunctionParameter<'bldr>> {
            let mut builder = FunctionParameterBuilder::new(_fbb);
            if let Some(x) = args.default {
                builder.add_default(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_default_type(args.default_type);
            builder.add_is_pipe(args.is_pipe);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_IS_PIPE: flatbuffers::VOffsetT = 6;
        pub const VT_KEY: flatbuffers::VOffsetT = 8;
        pub const VT_DEFAULT_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_DEFAULT: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    FunctionParameter::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn is_pipe(&self) -> bool {
            self._tab
                .get::<bool>(FunctionParameter::VT_IS_PIPE, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn key(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(FunctionParameter::VT_KEY, None)
        }
        #[inline]
        pub fn default_type(&self) -> Expression {
            self._tab
                .get::<Expression>(FunctionParameter::VT_DEFAULT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn default(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    FunctionParameter::VT_DEFAULT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.default_type() == Expression::StringExpression {
                self.default().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.default_type() == Expression::ArrayExpression {
                self.default().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.default_type() == Expression::DictExpression {
                self.default().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.default_type() == Expression::FunctionExpression {
                self.default().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.default_type() == Expression::BinaryExpression {
                self.default().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.default_type() == Expression::CallExpression {
                self.default().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.default_type() == Expression::ConditionalExpression {
                self.default().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.default_type() == Expression::IdentifierExpression {
                self.default().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.default_type() == Expression::LogicalExpression {
                self.default().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.default_type() == Expression::MemberExpression {
                self.default().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.default_type() == Expression::IndexExpression {
                self.default().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.default_type() == Expression::ObjectExpression {
                self.default().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.default_type() == Expression::UnaryExpression {
                self.default().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.default_type() == Expression::BooleanLiteral {
                self.default().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.default_type() == Expression::DateTimeLiteral {
                self.default().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.default_type() == Expression::DurationLiteral {
                self.default().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.default_type() == Expression::FloatLiteral {
                self.default().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.default_type() == Expression::IntegerLiteral {
                self.default().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.default_type() == Expression::StringLiteral {
                self.default().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.default_type() == Expression::RegexpLiteral {
                self.default().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.default_type() == Expression::UnsignedIntegerLiteral {
                self.default().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for FunctionParameter<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(&"loc", Self::VT_LOC, false)?
     .visit_field::<bool>(&"is_pipe", Self::VT_IS_PIPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(&"key", Self::VT_KEY, false)?
     .visit_union::<Expression, _>(&"default_type", Self::VT_DEFAULT_TYPE, &"default", Self::VT_DEFAULT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct FunctionParameterArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub is_pipe: bool,
        pub key: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub default_type: Expression,
        pub default: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for FunctionParameterArgs<'a> {
        #[inline]
        fn default() -> Self {
            FunctionParameterArgs {
                loc: None,
                is_pipe: false,
                key: None,
                default_type: Expression::NONE,
                default: None,
            }
        }
    }
    pub struct FunctionParameterBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FunctionParameterBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    FunctionParameter::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_is_pipe(&mut self, is_pipe: bool) {
            self.fbb_
                .push_slot::<bool>(FunctionParameter::VT_IS_PIPE, is_pipe, false);
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    FunctionParameter::VT_KEY,
                    key,
                );
        }
        #[inline]
        pub fn add_default_type(&mut self, default_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                FunctionParameter::VT_DEFAULT_TYPE,
                default_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_default(
            &mut self,
            default: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                FunctionParameter::VT_DEFAULT,
                default,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FunctionParameterBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FunctionParameterBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FunctionParameter<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for FunctionParameter<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("FunctionParameter");
            ds.field("loc", &self.loc());
            ds.field("is_pipe", &self.is_pipe());
            ds.field("key", &self.key());
            ds.field("default_type", &self.default_type());
            match self.default_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.default_as_string_expression() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.default_as_array_expression() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.default_as_dict_expression() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.default_as_function_expression() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.default_as_binary_expression() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.default_as_call_expression() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.default_as_conditional_expression() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.default_as_identifier_expression() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.default_as_logical_expression() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.default_as_member_expression() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.default_as_index_expression() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.default_as_object_expression() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.default_as_unary_expression() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.default_as_boolean_literal() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.default_as_date_time_literal() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.default_as_duration_literal() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.default_as_float_literal() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.default_as_integer_literal() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.default_as_string_literal() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.default_as_regexp_literal() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.default_as_unsigned_integer_literal() {
                        ds.field("default", &x)
                    } else {
                        ds.field(
                            "default",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("default", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum BlockOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Block<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Block<'a> {
        type Inner = Block<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Block<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Block { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BlockArgs<'args>,
        ) -> flatbuffers::WIPOffset<Block<'bldr>> {
            let mut builder = BlockBuilder::new(_fbb);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_BODY: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(Block::VT_LOC, None)
        }
        #[inline]
        pub fn body(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement>>,
            >>(Block::VT_BODY, None)
        }
    }

    impl flatbuffers::Verifiable for Block<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WrappedStatement>>,
                >>(&"body", Self::VT_BODY, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BlockArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub body: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>,
            >,
        >,
    }
    impl<'a> Default for BlockArgs<'a> {
        #[inline]
        fn default() -> Self {
            BlockArgs {
                loc: None,
                body: None,
            }
        }
    }
    pub struct BlockBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BlockBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(Block::VT_LOC, loc);
        }
        #[inline]
        pub fn add_body(
            &mut self,
            body: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<WrappedStatement<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_BODY, body);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BlockBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Block<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Block<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Block");
            ds.field("loc", &self.loc());
            ds.field("body", &self.body());
            ds.finish()
        }
    }
    pub enum BinaryExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BinaryExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BinaryExpression<'a> {
        type Inner = BinaryExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> BinaryExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BinaryExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BinaryExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<BinaryExpression<'bldr>> {
            let mut builder = BinaryExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.right {
                builder.add_right(x);
            }
            if let Some(x) = args.left {
                builder.add_left(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.add_right_type(args.right_type);
            builder.add_left_type(args.left_type);
            builder.add_operator(args.operator);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_OPERATOR: flatbuffers::VOffsetT = 6;
        pub const VT_LEFT_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_LEFT: flatbuffers::VOffsetT = 10;
        pub const VT_RIGHT_TYPE: flatbuffers::VOffsetT = 12;
        pub const VT_RIGHT: flatbuffers::VOffsetT = 14;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 16;
        pub const VT_TYP: flatbuffers::VOffsetT = 18;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(BinaryExpression::VT_LOC, None)
        }
        #[inline]
        pub fn operator(&self) -> Operator {
            self._tab
                .get::<Operator>(
                    BinaryExpression::VT_OPERATOR,
                    Some(Operator::MultiplicationOperator),
                )
                .unwrap()
        }
        #[inline]
        pub fn left_type(&self) -> Expression {
            self._tab
                .get::<Expression>(BinaryExpression::VT_LEFT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn left(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    BinaryExpression::VT_LEFT,
                    None,
                )
        }
        #[inline]
        pub fn right_type(&self) -> Expression {
            self._tab
                .get::<Expression>(BinaryExpression::VT_RIGHT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn right(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    BinaryExpression::VT_RIGHT,
                    None,
                )
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(BinaryExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    BinaryExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.left_type() == Expression::StringExpression {
                self.left().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.left_type() == Expression::ArrayExpression {
                self.left().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.left_type() == Expression::DictExpression {
                self.left().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.left_type() == Expression::FunctionExpression {
                self.left().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.left_type() == Expression::BinaryExpression {
                self.left().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.left_type() == Expression::CallExpression {
                self.left().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.left_type() == Expression::ConditionalExpression {
                self.left().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.left_type() == Expression::IdentifierExpression {
                self.left().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.left_type() == Expression::LogicalExpression {
                self.left().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.left_type() == Expression::MemberExpression {
                self.left().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.left_type() == Expression::IndexExpression {
                self.left().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.left_type() == Expression::ObjectExpression {
                self.left().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.left_type() == Expression::UnaryExpression {
                self.left().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.left_type() == Expression::BooleanLiteral {
                self.left().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.left_type() == Expression::DateTimeLiteral {
                self.left().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.left_type() == Expression::DurationLiteral {
                self.left().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.left_type() == Expression::FloatLiteral {
                self.left().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.left_type() == Expression::IntegerLiteral {
                self.left().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.left_type() == Expression::StringLiteral {
                self.left().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.left_type() == Expression::RegexpLiteral {
                self.left().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.left_type() == Expression::UnsignedIntegerLiteral {
                self.left().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.right_type() == Expression::StringExpression {
                self.right().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.right_type() == Expression::ArrayExpression {
                self.right().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.right_type() == Expression::DictExpression {
                self.right().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.right_type() == Expression::FunctionExpression {
                self.right().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.right_type() == Expression::BinaryExpression {
                self.right().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.right_type() == Expression::CallExpression {
                self.right().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.right_type() == Expression::ConditionalExpression {
                self.right().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.right_type() == Expression::IdentifierExpression {
                self.right().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.right_type() == Expression::LogicalExpression {
                self.right().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.right_type() == Expression::MemberExpression {
                self.right().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.right_type() == Expression::IndexExpression {
                self.right().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.right_type() == Expression::ObjectExpression {
                self.right().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.right_type() == Expression::UnaryExpression {
                self.right().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.right_type() == Expression::BooleanLiteral {
                self.right().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.right_type() == Expression::DateTimeLiteral {
                self.right().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.right_type() == Expression::DurationLiteral {
                self.right().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.right_type() == Expression::FloatLiteral {
                self.right().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.right_type() == Expression::IntegerLiteral {
                self.right().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.right_type() == Expression::StringLiteral {
                self.right().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.right_type() == Expression::RegexpLiteral {
                self.right().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.right_type() == Expression::UnsignedIntegerLiteral {
                self.right().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_record(&self) -> Option<Record<'a>> {
            if self.typ_type() == MonoType::Record {
                self.typ().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_dict(&self) -> Option<Dict<'a>> {
            if self.typ_type() == MonoType::Dict {
                self.typ().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_vector(&self) -> Option<Vector<'a>> {
            if self.typ_type() == MonoType::Vector {
                self.typ().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for BinaryExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(&"loc", Self::VT_LOC, false)?
     .visit_field::<Operator>(&"operator", Self::VT_OPERATOR, false)?
     .visit_union::<Expression, _>(&"left_type", Self::VT_LEFT_TYPE, &"left", Self::VT_LEFT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Expression, _>(&"right_type", Self::VT_RIGHT_TYPE, &"right", Self::VT_RIGHT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<MonoType, _>(&"typ_type", Self::VT_TYP_TYPE, &"typ", Self::VT_TYP, false, |key, v, pos| {
        match key {
          MonoType::Basic => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>("MonoType::Basic", pos),
          MonoType::Var => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>("MonoType::Var", pos),
          MonoType::Arr => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>("MonoType::Arr", pos),
          MonoType::Record => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>("MonoType::Record", pos),
          MonoType::Fun => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>("MonoType::Fun", pos),
          MonoType::Dict => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>("MonoType::Dict", pos),
          MonoType::Vector => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>("MonoType::Vector", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct BinaryExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub operator: Operator,
        pub left_type: Expression,
        pub left: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub right_type: Expression,
        pub right: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for BinaryExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            BinaryExpressionArgs {
                loc: None,
                operator: Operator::MultiplicationOperator,
                left_type: Expression::NONE,
                left: None,
                right_type: Expression::NONE,
                right: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct BinaryExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BinaryExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    BinaryExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_operator(&mut self, operator: Operator) {
            self.fbb_.push_slot::<Operator>(
                BinaryExpression::VT_OPERATOR,
                operator,
                Operator::MultiplicationOperator,
            );
        }
        #[inline]
        pub fn add_left_type(&mut self, left_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                BinaryExpression::VT_LEFT_TYPE,
                left_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_left(&mut self, left: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryExpression::VT_LEFT, left);
        }
        #[inline]
        pub fn add_right_type(&mut self, right_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                BinaryExpression::VT_RIGHT_TYPE,
                right_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_right(&mut self, right: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryExpression::VT_RIGHT, right);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                BinaryExpression::VT_TYP_TYPE,
                typ_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BinaryExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BinaryExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BinaryExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for BinaryExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("BinaryExpression");
            ds.field("loc", &self.loc());
            ds.field("operator", &self.operator());
            ds.field("left_type", &self.left_type());
            match self.left_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.left_as_string_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.left_as_array_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.left_as_dict_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.left_as_function_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.left_as_binary_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.left_as_call_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.left_as_conditional_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.left_as_identifier_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.left_as_logical_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.left_as_member_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.left_as_index_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.left_as_object_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.left_as_unary_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.left_as_boolean_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.left_as_date_time_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.left_as_duration_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.left_as_float_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.left_as_integer_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.left_as_string_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.left_as_regexp_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.left_as_unsigned_integer_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("left", &x)
                }
            };
            ds.field("right_type", &self.right_type());
            match self.right_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.right_as_string_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.right_as_array_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.right_as_dict_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.right_as_function_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.right_as_binary_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.right_as_call_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.right_as_conditional_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.right_as_identifier_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.right_as_logical_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.right_as_member_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.right_as_index_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.right_as_object_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.right_as_unary_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.right_as_boolean_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.right_as_date_time_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.right_as_duration_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.right_as_float_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.right_as_integer_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.right_as_string_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.right_as_regexp_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.right_as_unsigned_integer_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("right", &x)
                }
            };
            ds.field("typ_type", &self.typ_type());
            match self.typ_type() {
                MonoType::Basic => {
                    if let Some(x) = self.typ_as_basic() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.typ_as_var() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.typ_as_arr() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.typ_as_record() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.typ_as_fun() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.typ_as_dict() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.typ_as_vector() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("typ", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum CallExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CallExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CallExpression<'a> {
        type Inner = CallExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> CallExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CallExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CallExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<CallExpression<'bldr>> {
            let mut builder = CallExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.pipe {
                builder.add_pipe(x);
            }
            if let Some(x) = args.arguments {
                builder.add_arguments(x);
            }
            if let Some(x) = args.callee {
                builder.add_callee(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.add_pipe_type(args.pipe_type);
            builder.add_callee_type(args.callee_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_CALLEE_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_CALLEE: flatbuffers::VOffsetT = 8;
        pub const VT_ARGUMENTS: flatbuffers::VOffsetT = 10;
        pub const VT_PIPE_TYPE: flatbuffers::VOffsetT = 12;
        pub const VT_PIPE: flatbuffers::VOffsetT = 14;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 16;
        pub const VT_TYP: flatbuffers::VOffsetT = 18;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(CallExpression::VT_LOC, None)
        }
        #[inline]
        pub fn callee_type(&self) -> Expression {
            self._tab
                .get::<Expression>(CallExpression::VT_CALLEE_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn callee(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    CallExpression::VT_CALLEE,
                    None,
                )
        }
        #[inline]
        pub fn arguments(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>,
            >>(CallExpression::VT_ARGUMENTS, None)
        }
        #[inline]
        pub fn pipe_type(&self) -> Expression {
            self._tab
                .get::<Expression>(CallExpression::VT_PIPE_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn pipe(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    CallExpression::VT_PIPE,
                    None,
                )
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(CallExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    CallExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.callee_type() == Expression::StringExpression {
                self.callee().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.callee_type() == Expression::ArrayExpression {
                self.callee().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.callee_type() == Expression::DictExpression {
                self.callee().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.callee_type() == Expression::FunctionExpression {
                self.callee().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.callee_type() == Expression::BinaryExpression {
                self.callee().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.callee_type() == Expression::CallExpression {
                self.callee().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.callee_type() == Expression::ConditionalExpression {
                self.callee().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.callee_type() == Expression::IdentifierExpression {
                self.callee().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.callee_type() == Expression::LogicalExpression {
                self.callee().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.callee_type() == Expression::MemberExpression {
                self.callee().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.callee_type() == Expression::IndexExpression {
                self.callee().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.callee_type() == Expression::ObjectExpression {
                self.callee().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.callee_type() == Expression::UnaryExpression {
                self.callee().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.callee_type() == Expression::BooleanLiteral {
                self.callee().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.callee_type() == Expression::DateTimeLiteral {
                self.callee().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.callee_type() == Expression::DurationLiteral {
                self.callee().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.callee_type() == Expression::FloatLiteral {
                self.callee().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.callee_type() == Expression::IntegerLiteral {
                self.callee().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.callee_type() == Expression::StringLiteral {
                self.callee().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.callee_type() == Expression::RegexpLiteral {
                self.callee().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.callee_type() == Expression::UnsignedIntegerLiteral {
                self.callee().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.pipe_type() == Expression::StringExpression {
                self.pipe().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.pipe_type() == Expression::ArrayExpression {
                self.pipe().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.pipe_type() == Expression::DictExpression {
                self.pipe().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.pipe_type() == Expression::FunctionExpression {
                self.pipe().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.pipe_type() == Expression::BinaryExpression {
                self.pipe().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.pipe_type() == Expression::CallExpression {
                self.pipe().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.pipe_type() == Expression::ConditionalExpression {
                self.pipe().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.pipe_type() == Expression::IdentifierExpression {
                self.pipe().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.pipe_type() == Expression::LogicalExpression {
                self.pipe().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.pipe_type() == Expression::MemberExpression {
                self.pipe().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.pipe_type() == Expression::IndexExpression {
                self.pipe().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.pipe_type() == Expression::ObjectExpression {
                self.pipe().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.pipe_type() == Expression::UnaryExpression {
                self.pipe().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.pipe_type() == Expression::BooleanLiteral {
                self.pipe().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.pipe_type() == Expression::DateTimeLiteral {
                self.pipe().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.pipe_type() == Expression::DurationLiteral {
                self.pipe().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.pipe_type() == Expression::FloatLiteral {
                self.pipe().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.pipe_type() == Expression::IntegerLiteral {
                self.pipe().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.pipe_type() == Expression::StringLiteral {
                self.pipe().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.pipe_type() == Expression::RegexpLiteral {
                self.pipe().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.pipe_type() == Expression::UnsignedIntegerLiteral {
                self.pipe().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_record(&self) -> Option<Record<'a>> {
            if self.typ_type() == MonoType::Record {
                self.typ().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_dict(&self) -> Option<Dict<'a>> {
            if self.typ_type() == MonoType::Dict {
                self.typ().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_vector(&self) -> Option<Vector<'a>> {
            if self.typ_type() == MonoType::Vector {
                self.typ().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for CallExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(&"loc", Self::VT_LOC, false)?
     .visit_union::<Expression, _>(&"callee_type", Self::VT_CALLEE_TYPE, &"callee", Self::VT_CALLEE, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>(&"arguments", Self::VT_ARGUMENTS, false)?
     .visit_union::<Expression, _>(&"pipe_type", Self::VT_PIPE_TYPE, &"pipe", Self::VT_PIPE, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<MonoType, _>(&"typ_type", Self::VT_TYP_TYPE, &"typ", Self::VT_TYP, false, |key, v, pos| {
        match key {
          MonoType::Basic => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>("MonoType::Basic", pos),
          MonoType::Var => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>("MonoType::Var", pos),
          MonoType::Arr => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>("MonoType::Arr", pos),
          MonoType::Record => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>("MonoType::Record", pos),
          MonoType::Fun => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>("MonoType::Fun", pos),
          MonoType::Dict => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>("MonoType::Dict", pos),
          MonoType::Vector => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>("MonoType::Vector", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct CallExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub callee_type: Expression,
        pub callee: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub arguments: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>,
            >,
        >,
        pub pipe_type: Expression,
        pub pipe: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for CallExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            CallExpressionArgs {
                loc: None,
                callee_type: Expression::NONE,
                callee: None,
                arguments: None,
                pipe_type: Expression::NONE,
                pipe: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct CallExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CallExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    CallExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_callee_type(&mut self, callee_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                CallExpression::VT_CALLEE_TYPE,
                callee_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_callee(&mut self, callee: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CallExpression::VT_CALLEE, callee);
        }
        #[inline]
        pub fn add_arguments(
            &mut self,
            arguments: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Property<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                CallExpression::VT_ARGUMENTS,
                arguments,
            );
        }
        #[inline]
        pub fn add_pipe_type(&mut self, pipe_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                CallExpression::VT_PIPE_TYPE,
                pipe_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_pipe(&mut self, pipe: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CallExpression::VT_PIPE, pipe);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(CallExpression::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CallExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CallExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CallExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CallExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for CallExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("CallExpression");
            ds.field("loc", &self.loc());
            ds.field("callee_type", &self.callee_type());
            match self.callee_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.callee_as_string_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.callee_as_array_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.callee_as_dict_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.callee_as_function_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.callee_as_binary_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.callee_as_call_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.callee_as_conditional_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.callee_as_identifier_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.callee_as_logical_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.callee_as_member_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.callee_as_index_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.callee_as_object_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.callee_as_unary_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.callee_as_boolean_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.callee_as_date_time_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.callee_as_duration_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.callee_as_float_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.callee_as_integer_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.callee_as_string_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.callee_as_regexp_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.callee_as_unsigned_integer_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("callee", &x)
                }
            };
            ds.field("arguments", &self.arguments());
            ds.field("pipe_type", &self.pipe_type());
            match self.pipe_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.pipe_as_string_expression() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.pipe_as_array_expression() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.pipe_as_dict_expression() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.pipe_as_function_expression() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.pipe_as_binary_expression() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.pipe_as_call_expression() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.pipe_as_conditional_expression() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.pipe_as_identifier_expression() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.pipe_as_logical_expression() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.pipe_as_member_expression() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.pipe_as_index_expression() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.pipe_as_object_expression() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.pipe_as_unary_expression() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.pipe_as_boolean_literal() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.pipe_as_date_time_literal() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.pipe_as_duration_literal() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.pipe_as_float_literal() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.pipe_as_integer_literal() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.pipe_as_string_literal() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.pipe_as_regexp_literal() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.pipe_as_unsigned_integer_literal() {
                        ds.field("pipe", &x)
                    } else {
                        ds.field(
                            "pipe",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("pipe", &x)
                }
            };
            ds.field("typ_type", &self.typ_type());
            match self.typ_type() {
                MonoType::Basic => {
                    if let Some(x) = self.typ_as_basic() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.typ_as_var() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.typ_as_arr() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.typ_as_record() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.typ_as_fun() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.typ_as_dict() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.typ_as_vector() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("typ", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum ConditionalExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ConditionalExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ConditionalExpression<'a> {
        type Inner = ConditionalExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ConditionalExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ConditionalExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ConditionalExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<ConditionalExpression<'bldr>> {
            let mut builder = ConditionalExpressionBuilder::new(_fbb);
            if let Some(x) = args.consequent {
                builder.add_consequent(x);
            }
            if let Some(x) = args.alternate {
                builder.add_alternate(x);
            }
            if let Some(x) = args.test {
                builder.add_test(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_consequent_type(args.consequent_type);
            builder.add_alternate_type(args.alternate_type);
            builder.add_test_type(args.test_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_TEST_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_TEST: flatbuffers::VOffsetT = 8;
        pub const VT_ALTERNATE_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_ALTERNATE: flatbuffers::VOffsetT = 12;
        pub const VT_CONSEQUENT_TYPE: flatbuffers::VOffsetT = 14;
        pub const VT_CONSEQUENT: flatbuffers::VOffsetT = 16;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    ConditionalExpression::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn test_type(&self) -> Expression {
            self._tab
                .get::<Expression>(ConditionalExpression::VT_TEST_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn test(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConditionalExpression::VT_TEST,
                    None,
                )
        }
        #[inline]
        pub fn alternate_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    ConditionalExpression::VT_ALTERNATE_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn alternate(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConditionalExpression::VT_ALTERNATE,
                    None,
                )
        }
        #[inline]
        pub fn consequent_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    ConditionalExpression::VT_CONSEQUENT_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn consequent(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConditionalExpression::VT_CONSEQUENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.test_type() == Expression::StringExpression {
                self.test().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.test_type() == Expression::ArrayExpression {
                self.test().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.test_type() == Expression::DictExpression {
                self.test().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.test_type() == Expression::FunctionExpression {
                self.test().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.test_type() == Expression::BinaryExpression {
                self.test().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.test_type() == Expression::CallExpression {
                self.test().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.test_type() == Expression::ConditionalExpression {
                self.test().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.test_type() == Expression::IdentifierExpression {
                self.test().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.test_type() == Expression::LogicalExpression {
                self.test().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.test_type() == Expression::MemberExpression {
                self.test().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.test_type() == Expression::IndexExpression {
                self.test().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.test_type() == Expression::ObjectExpression {
                self.test().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.test_type() == Expression::UnaryExpression {
                self.test().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.test_type() == Expression::BooleanLiteral {
                self.test().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.test_type() == Expression::DateTimeLiteral {
                self.test().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.test_type() == Expression::DurationLiteral {
                self.test().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.test_type() == Expression::FloatLiteral {
                self.test().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.test_type() == Expression::IntegerLiteral {
                self.test().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.test_type() == Expression::StringLiteral {
                self.test().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.test_type() == Expression::RegexpLiteral {
                self.test().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.test_type() == Expression::UnsignedIntegerLiteral {
                self.test().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.alternate_type() == Expression::StringExpression {
                self.alternate().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.alternate_type() == Expression::ArrayExpression {
                self.alternate().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.alternate_type() == Expression::DictExpression {
                self.alternate().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.alternate_type() == Expression::FunctionExpression {
                self.alternate().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.alternate_type() == Expression::BinaryExpression {
                self.alternate().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.alternate_type() == Expression::CallExpression {
                self.alternate().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.alternate_type() == Expression::ConditionalExpression {
                self.alternate().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.alternate_type() == Expression::IdentifierExpression {
                self.alternate().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.alternate_type() == Expression::LogicalExpression {
                self.alternate().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.alternate_type() == Expression::MemberExpression {
                self.alternate().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.alternate_type() == Expression::IndexExpression {
                self.alternate().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.alternate_type() == Expression::ObjectExpression {
                self.alternate().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.alternate_type() == Expression::UnaryExpression {
                self.alternate().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.alternate_type() == Expression::BooleanLiteral {
                self.alternate().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.alternate_type() == Expression::DateTimeLiteral {
                self.alternate().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.alternate_type() == Expression::DurationLiteral {
                self.alternate().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.alternate_type() == Expression::FloatLiteral {
                self.alternate().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.alternate_type() == Expression::IntegerLiteral {
                self.alternate().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.alternate_type() == Expression::StringLiteral {
                self.alternate().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.alternate_type() == Expression::RegexpLiteral {
                self.alternate().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.alternate_type() == Expression::UnsignedIntegerLiteral {
                self.alternate()
                    .map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.consequent_type() == Expression::StringExpression {
                self.consequent().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.consequent_type() == Expression::ArrayExpression {
                self.consequent().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.consequent_type() == Expression::DictExpression {
                self.consequent().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.consequent_type() == Expression::FunctionExpression {
                self.consequent().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.consequent_type() == Expression::BinaryExpression {
                self.consequent().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.consequent_type() == Expression::CallExpression {
                self.consequent().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.consequent_type() == Expression::ConditionalExpression {
                self.consequent()
                    .map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.consequent_type() == Expression::IdentifierExpression {
                self.consequent().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.consequent_type() == Expression::LogicalExpression {
                self.consequent().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.consequent_type() == Expression::MemberExpression {
                self.consequent().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.consequent_type() == Expression::IndexExpression {
                self.consequent().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.consequent_type() == Expression::ObjectExpression {
                self.consequent().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.consequent_type() == Expression::UnaryExpression {
                self.consequent().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.consequent_type() == Expression::BooleanLiteral {
                self.consequent().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.consequent_type() == Expression::DateTimeLiteral {
                self.consequent().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.consequent_type() == Expression::DurationLiteral {
                self.consequent().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.consequent_type() == Expression::FloatLiteral {
                self.consequent().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.consequent_type() == Expression::IntegerLiteral {
                self.consequent().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.consequent_type() == Expression::StringLiteral {
                self.consequent().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.consequent_type() == Expression::RegexpLiteral {
                self.consequent().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.consequent_type() == Expression::UnsignedIntegerLiteral {
                self.consequent()
                    .map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ConditionalExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(&"loc", Self::VT_LOC, false)?
     .visit_union::<Expression, _>(&"test_type", Self::VT_TEST_TYPE, &"test", Self::VT_TEST, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Expression, _>(&"alternate_type", Self::VT_ALTERNATE_TYPE, &"alternate", Self::VT_ALTERNATE, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Expression, _>(&"consequent_type", Self::VT_CONSEQUENT_TYPE, &"consequent", Self::VT_CONSEQUENT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct ConditionalExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub test_type: Expression,
        pub test: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub alternate_type: Expression,
        pub alternate: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub consequent_type: Expression,
        pub consequent: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ConditionalExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            ConditionalExpressionArgs {
                loc: None,
                test_type: Expression::NONE,
                test: None,
                alternate_type: Expression::NONE,
                alternate: None,
                consequent_type: Expression::NONE,
                consequent: None,
            }
        }
    }
    pub struct ConditionalExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ConditionalExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    ConditionalExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_test_type(&mut self, test_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ConditionalExpression::VT_TEST_TYPE,
                test_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_test(&mut self, test: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ConditionalExpression::VT_TEST,
                test,
            );
        }
        #[inline]
        pub fn add_alternate_type(&mut self, alternate_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ConditionalExpression::VT_ALTERNATE_TYPE,
                alternate_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_alternate(
            &mut self,
            alternate: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ConditionalExpression::VT_ALTERNATE,
                alternate,
            );
        }
        #[inline]
        pub fn add_consequent_type(&mut self, consequent_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ConditionalExpression::VT_CONSEQUENT_TYPE,
                consequent_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_consequent(
            &mut self,
            consequent: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ConditionalExpression::VT_CONSEQUENT,
                consequent,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ConditionalExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ConditionalExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ConditionalExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ConditionalExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ConditionalExpression");
            ds.field("loc", &self.loc());
            ds.field("test_type", &self.test_type());
            match self.test_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.test_as_string_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.test_as_array_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.test_as_dict_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.test_as_function_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.test_as_binary_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.test_as_call_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.test_as_conditional_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.test_as_identifier_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.test_as_logical_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.test_as_member_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.test_as_index_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.test_as_object_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.test_as_unary_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.test_as_boolean_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.test_as_date_time_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.test_as_duration_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.test_as_float_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.test_as_integer_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.test_as_string_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.test_as_regexp_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.test_as_unsigned_integer_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("test", &x)
                }
            };
            ds.field("alternate_type", &self.alternate_type());
            match self.alternate_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.alternate_as_string_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.alternate_as_array_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.alternate_as_dict_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.alternate_as_function_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.alternate_as_binary_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.alternate_as_call_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.alternate_as_conditional_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.alternate_as_identifier_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.alternate_as_logical_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.alternate_as_member_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.alternate_as_index_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.alternate_as_object_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.alternate_as_unary_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.alternate_as_boolean_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.alternate_as_date_time_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.alternate_as_duration_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.alternate_as_float_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.alternate_as_integer_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.alternate_as_string_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.alternate_as_regexp_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.alternate_as_unsigned_integer_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("alternate", &x)
                }
            };
            ds.field("consequent_type", &self.consequent_type());
            match self.consequent_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.consequent_as_string_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.consequent_as_array_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.consequent_as_dict_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.consequent_as_function_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.consequent_as_binary_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.consequent_as_call_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.consequent_as_conditional_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.consequent_as_identifier_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.consequent_as_logical_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.consequent_as_member_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.consequent_as_index_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.consequent_as_object_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.consequent_as_unary_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.consequent_as_boolean_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.consequent_as_date_time_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.consequent_as_duration_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.consequent_as_float_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.consequent_as_integer_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.consequent_as_string_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.consequent_as_regexp_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.consequent_as_unsigned_integer_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("consequent", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum LogicalExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LogicalExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LogicalExpression<'a> {
        type Inner = LogicalExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> LogicalExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LogicalExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LogicalExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<LogicalExpression<'bldr>> {
            let mut builder = LogicalExpressionBuilder::new(_fbb);
            if let Some(x) = args.right {
                builder.add_right(x);
            }
            if let Some(x) = args.left {
                builder.add_left(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_right_type(args.right_type);
            builder.add_left_type(args.left_type);
            builder.add_operator(args.operator);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_OPERATOR: flatbuffers::VOffsetT = 6;
        pub const VT_LEFT_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_LEFT: flatbuffers::VOffsetT = 10;
        pub const VT_RIGHT_TYPE: flatbuffers::VOffsetT = 12;
        pub const VT_RIGHT: flatbuffers::VOffsetT = 14;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    LogicalExpression::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn operator(&self) -> LogicalOperator {
            self._tab
                .get::<LogicalOperator>(
                    LogicalExpression::VT_OPERATOR,
                    Some(LogicalOperator::AndOperator),
                )
                .unwrap()
        }
        #[inline]
        pub fn left_type(&self) -> Expression {
            self._tab
                .get::<Expression>(LogicalExpression::VT_LEFT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn left(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    LogicalExpression::VT_LEFT,
                    None,
                )
        }
        #[inline]
        pub fn right_type(&self) -> Expression {
            self._tab
                .get::<Expression>(LogicalExpression::VT_RIGHT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn right(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    LogicalExpression::VT_RIGHT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.left_type() == Expression::StringExpression {
                self.left().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.left_type() == Expression::ArrayExpression {
                self.left().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.left_type() == Expression::DictExpression {
                self.left().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.left_type() == Expression::FunctionExpression {
                self.left().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.left_type() == Expression::BinaryExpression {
                self.left().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.left_type() == Expression::CallExpression {
                self.left().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.left_type() == Expression::ConditionalExpression {
                self.left().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.left_type() == Expression::IdentifierExpression {
                self.left().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.left_type() == Expression::LogicalExpression {
                self.left().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.left_type() == Expression::MemberExpression {
                self.left().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.left_type() == Expression::IndexExpression {
                self.left().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.left_type() == Expression::ObjectExpression {
                self.left().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.left_type() == Expression::UnaryExpression {
                self.left().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.left_type() == Expression::BooleanLiteral {
                self.left().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.left_type() == Expression::DateTimeLiteral {
                self.left().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.left_type() == Expression::DurationLiteral {
                self.left().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.left_type() == Expression::FloatLiteral {
                self.left().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.left_type() == Expression::IntegerLiteral {
                self.left().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.left_type() == Expression::StringLiteral {
                self.left().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.left_type() == Expression::RegexpLiteral {
                self.left().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.left_type() == Expression::UnsignedIntegerLiteral {
                self.left().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.right_type() == Expression::StringExpression {
                self.right().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.right_type() == Expression::ArrayExpression {
                self.right().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.right_type() == Expression::DictExpression {
                self.right().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.right_type() == Expression::FunctionExpression {
                self.right().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.right_type() == Expression::BinaryExpression {
                self.right().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.right_type() == Expression::CallExpression {
                self.right().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.right_type() == Expression::ConditionalExpression {
                self.right().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.right_type() == Expression::IdentifierExpression {
                self.right().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.right_type() == Expression::LogicalExpression {
                self.right().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.right_type() == Expression::MemberExpression {
                self.right().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.right_type() == Expression::IndexExpression {
                self.right().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.right_type() == Expression::ObjectExpression {
                self.right().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.right_type() == Expression::UnaryExpression {
                self.right().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.right_type() == Expression::BooleanLiteral {
                self.right().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.right_type() == Expression::DateTimeLiteral {
                self.right().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.right_type() == Expression::DurationLiteral {
                self.right().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.right_type() == Expression::FloatLiteral {
                self.right().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.right_type() == Expression::IntegerLiteral {
                self.right().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.right_type() == Expression::StringLiteral {
                self.right().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.right_type() == Expression::RegexpLiteral {
                self.right().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.right_type() == Expression::UnsignedIntegerLiteral {
                self.right().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for LogicalExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(&"loc", Self::VT_LOC, false)?
     .visit_field::<LogicalOperator>(&"operator", Self::VT_OPERATOR, false)?
     .visit_union::<Expression, _>(&"left_type", Self::VT_LEFT_TYPE, &"left", Self::VT_LEFT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Expression, _>(&"right_type", Self::VT_RIGHT_TYPE, &"right", Self::VT_RIGHT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct LogicalExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub operator: LogicalOperator,
        pub left_type: Expression,
        pub left: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub right_type: Expression,
        pub right: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for LogicalExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            LogicalExpressionArgs {
                loc: None,
                operator: LogicalOperator::AndOperator,
                left_type: Expression::NONE,
                left: None,
                right_type: Expression::NONE,
                right: None,
            }
        }
    }
    pub struct LogicalExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LogicalExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    LogicalExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_operator(&mut self, operator: LogicalOperator) {
            self.fbb_.push_slot::<LogicalOperator>(
                LogicalExpression::VT_OPERATOR,
                operator,
                LogicalOperator::AndOperator,
            );
        }
        #[inline]
        pub fn add_left_type(&mut self, left_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                LogicalExpression::VT_LEFT_TYPE,
                left_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_left(&mut self, left: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(LogicalExpression::VT_LEFT, left);
        }
        #[inline]
        pub fn add_right_type(&mut self, right_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                LogicalExpression::VT_RIGHT_TYPE,
                right_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_right(&mut self, right: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(LogicalExpression::VT_RIGHT, right);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LogicalExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LogicalExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LogicalExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for LogicalExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("LogicalExpression");
            ds.field("loc", &self.loc());
            ds.field("operator", &self.operator());
            ds.field("left_type", &self.left_type());
            match self.left_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.left_as_string_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.left_as_array_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.left_as_dict_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.left_as_function_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.left_as_binary_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.left_as_call_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.left_as_conditional_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.left_as_identifier_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.left_as_logical_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.left_as_member_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.left_as_index_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.left_as_object_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.left_as_unary_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.left_as_boolean_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.left_as_date_time_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.left_as_duration_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.left_as_float_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.left_as_integer_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.left_as_string_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.left_as_regexp_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.left_as_unsigned_integer_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("left", &x)
                }
            };
            ds.field("right_type", &self.right_type());
            match self.right_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.right_as_string_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.right_as_array_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.right_as_dict_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.right_as_function_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.right_as_binary_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.right_as_call_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.right_as_conditional_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.right_as_identifier_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.right_as_logical_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.right_as_member_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.right_as_index_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.right_as_object_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.right_as_unary_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.right_as_boolean_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.right_as_date_time_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.right_as_duration_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.right_as_float_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.right_as_integer_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.right_as_string_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.right_as_regexp_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.right_as_unsigned_integer_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("right", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum MemberExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MemberExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MemberExpression<'a> {
        type Inner = MemberExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> MemberExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MemberExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MemberExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<MemberExpression<'bldr>> {
            let mut builder = MemberExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.property {
                builder.add_property(x);
            }
            if let Some(x) = args.object {
                builder.add_object(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.add_object_type(args.object_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_OBJECT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_OBJECT: flatbuffers::VOffsetT = 8;
        pub const VT_PROPERTY: flatbuffers::VOffsetT = 10;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 12;
        pub const VT_TYP: flatbuffers::VOffsetT = 14;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(MemberExpression::VT_LOC, None)
        }
        #[inline]
        pub fn object_type(&self) -> Expression {
            self._tab
                .get::<Expression>(MemberExpression::VT_OBJECT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn object(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    MemberExpression::VT_OBJECT,
                    None,
                )
        }
        #[inline]
        pub fn property(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(MemberExpression::VT_PROPERTY, None)
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(MemberExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    MemberExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.object_type() == Expression::StringExpression {
                self.object().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.object_type() == Expression::ArrayExpression {
                self.object().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.object_type() == Expression::DictExpression {
                self.object().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.object_type() == Expression::FunctionExpression {
                self.object().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.object_type() == Expression::BinaryExpression {
                self.object().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.object_type() == Expression::CallExpression {
                self.object().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.object_type() == Expression::ConditionalExpression {
                self.object().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.object_type() == Expression::IdentifierExpression {
                self.object().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.object_type() == Expression::LogicalExpression {
                self.object().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.object_type() == Expression::MemberExpression {
                self.object().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.object_type() == Expression::IndexExpression {
                self.object().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.object_type() == Expression::ObjectExpression {
                self.object().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.object_type() == Expression::UnaryExpression {
                self.object().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.object_type() == Expression::BooleanLiteral {
                self.object().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.object_type() == Expression::DateTimeLiteral {
                self.object().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.object_type() == Expression::DurationLiteral {
                self.object().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.object_type() == Expression::FloatLiteral {
                self.object().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.object_type() == Expression::IntegerLiteral {
                self.object().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.object_type() == Expression::StringLiteral {
                self.object().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.object_type() == Expression::RegexpLiteral {
                self.object().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.object_type() == Expression::UnsignedIntegerLiteral {
                self.object().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_record(&self) -> Option<Record<'a>> {
            if self.typ_type() == MonoType::Record {
                self.typ().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_dict(&self) -> Option<Dict<'a>> {
            if self.typ_type() == MonoType::Dict {
                self.typ().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_vector(&self) -> Option<Vector<'a>> {
            if self.typ_type() == MonoType::Vector {
                self.typ().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for MemberExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(&"loc", Self::VT_LOC, false)?
     .visit_union::<Expression, _>(&"object_type", Self::VT_OBJECT_TYPE, &"object", Self::VT_OBJECT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"property", Self::VT_PROPERTY, false)?
     .visit_union::<MonoType, _>(&"typ_type", Self::VT_TYP_TYPE, &"typ", Self::VT_TYP, false, |key, v, pos| {
        match key {
          MonoType::Basic => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>("MonoType::Basic", pos),
          MonoType::Var => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>("MonoType::Var", pos),
          MonoType::Arr => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>("MonoType::Arr", pos),
          MonoType::Record => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>("MonoType::Record", pos),
          MonoType::Fun => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>("MonoType::Fun", pos),
          MonoType::Dict => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>("MonoType::Dict", pos),
          MonoType::Vector => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>("MonoType::Vector", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct MemberExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub object_type: Expression,
        pub object: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub property: Option<flatbuffers::WIPOffset<&'a str>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for MemberExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            MemberExpressionArgs {
                loc: None,
                object_type: Expression::NONE,
                object: None,
                property: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct MemberExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MemberExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    MemberExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_object_type(&mut self, object_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                MemberExpression::VT_OBJECT_TYPE,
                object_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_object(&mut self, object: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MemberExpression::VT_OBJECT, object);
        }
        #[inline]
        pub fn add_property(&mut self, property: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MemberExpression::VT_PROPERTY,
                property,
            );
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                MemberExpression::VT_TYP_TYPE,
                typ_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MemberExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MemberExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MemberExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MemberExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for MemberExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("MemberExpression");
            ds.field("loc", &self.loc());
            ds.field("object_type", &self.object_type());
            match self.object_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.object_as_string_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.object_as_array_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.object_as_dict_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.object_as_function_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.object_as_binary_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.object_as_call_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.object_as_conditional_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.object_as_identifier_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.object_as_logical_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.object_as_member_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.object_as_index_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.object_as_object_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.object_as_unary_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.object_as_boolean_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.object_as_date_time_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.object_as_duration_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.object_as_float_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.object_as_integer_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.object_as_string_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.object_as_regexp_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.object_as_unsigned_integer_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("object", &x)
                }
            };
            ds.field("property", &self.property());
            ds.field("typ_type", &self.typ_type());
            match self.typ_type() {
                MonoType::Basic => {
                    if let Some(x) = self.typ_as_basic() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.typ_as_var() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.typ_as_arr() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.typ_as_record() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.typ_as_fun() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.typ_as_dict() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.typ_as_vector() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("typ", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum IndexExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct IndexExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for IndexExpression<'a> {
        type Inner = IndexExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> IndexExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            IndexExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IndexExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<IndexExpression<'bldr>> {
            let mut builder = IndexExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.index {
                builder.add_index(x);
            }
            if let Some(x) = args.array {
                builder.add_array(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.add_index_type(args.index_type);
            builder.add_array_type(args.array_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ARRAY_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ARRAY: flatbuffers::VOffsetT = 8;
        pub const VT_INDEX_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_INDEX: flatbuffers::VOffsetT = 12;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 14;
        pub const VT_TYP: flatbuffers::VOffsetT = 16;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(IndexExpression::VT_LOC, None)
        }
        #[inline]
        pub fn array_type(&self) -> Expression {
            self._tab
                .get::<Expression>(IndexExpression::VT_ARRAY_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn array(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    IndexExpression::VT_ARRAY,
                    None,
                )
        }
        #[inline]
        pub fn index_type(&self) -> Expression {
            self._tab
                .get::<Expression>(IndexExpression::VT_INDEX_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn index(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    IndexExpression::VT_INDEX,
                    None,
                )
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(IndexExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    IndexExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.array_type() == Expression::StringExpression {
                self.array().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.array_type() == Expression::ArrayExpression {
                self.array().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.array_type() == Expression::DictExpression {
                self.array().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.array_type() == Expression::FunctionExpression {
                self.array().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.array_type() == Expression::BinaryExpression {
                self.array().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.array_type() == Expression::CallExpression {
                self.array().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.array_type() == Expression::ConditionalExpression {
                self.array().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.array_type() == Expression::IdentifierExpression {
                self.array().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.array_type() == Expression::LogicalExpression {
                self.array().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.array_type() == Expression::MemberExpression {
                self.array().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.array_type() == Expression::IndexExpression {
                self.array().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.array_type() == Expression::ObjectExpression {
                self.array().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.array_type() == Expression::UnaryExpression {
                self.array().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.array_type() == Expression::BooleanLiteral {
                self.array().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.array_type() == Expression::DateTimeLiteral {
                self.array().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.array_type() == Expression::DurationLiteral {
                self.array().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.array_type() == Expression::FloatLiteral {
                self.array().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.array_type() == Expression::IntegerLiteral {
                self.array().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.array_type() == Expression::StringLiteral {
                self.array().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.array_type() == Expression::RegexpLiteral {
                self.array().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.array_type() == Expression::UnsignedIntegerLiteral {
                self.array().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.index_type() == Expression::StringExpression {
                self.index().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.index_type() == Expression::ArrayExpression {
                self.index().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.index_type() == Expression::DictExpression {
                self.index().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.index_type() == Expression::FunctionExpression {
                self.index().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.index_type() == Expression::BinaryExpression {
                self.index().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.index_type() == Expression::CallExpression {
                self.index().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.index_type() == Expression::ConditionalExpression {
                self.index().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.index_type() == Expression::IdentifierExpression {
                self.index().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.index_type() == Expression::LogicalExpression {
                self.index().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.index_type() == Expression::MemberExpression {
                self.index().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.index_type() == Expression::IndexExpression {
                self.index().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.index_type() == Expression::ObjectExpression {
                self.index().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.index_type() == Expression::UnaryExpression {
                self.index().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.index_type() == Expression::BooleanLiteral {
                self.index().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.index_type() == Expression::DateTimeLiteral {
                self.index().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.index_type() == Expression::DurationLiteral {
                self.index().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.index_type() == Expression::FloatLiteral {
                self.index().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.index_type() == Expression::IntegerLiteral {
                self.index().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.index_type() == Expression::StringLiteral {
                self.index().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.index_type() == Expression::RegexpLiteral {
                self.index().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.index_type() == Expression::UnsignedIntegerLiteral {
                self.index().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_record(&self) -> Option<Record<'a>> {
            if self.typ_type() == MonoType::Record {
                self.typ().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_dict(&self) -> Option<Dict<'a>> {
            if self.typ_type() == MonoType::Dict {
                self.typ().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_vector(&self) -> Option<Vector<'a>> {
            if self.typ_type() == MonoType::Vector {
                self.typ().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for IndexExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(&"loc", Self::VT_LOC, false)?
     .visit_union::<Expression, _>(&"array_type", Self::VT_ARRAY_TYPE, &"array", Self::VT_ARRAY, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Expression, _>(&"index_type", Self::VT_INDEX_TYPE, &"index", Self::VT_INDEX, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<MonoType, _>(&"typ_type", Self::VT_TYP_TYPE, &"typ", Self::VT_TYP, false, |key, v, pos| {
        match key {
          MonoType::Basic => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>("MonoType::Basic", pos),
          MonoType::Var => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>("MonoType::Var", pos),
          MonoType::Arr => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>("MonoType::Arr", pos),
          MonoType::Record => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>("MonoType::Record", pos),
          MonoType::Fun => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>("MonoType::Fun", pos),
          MonoType::Dict => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>("MonoType::Dict", pos),
          MonoType::Vector => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>("MonoType::Vector", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct IndexExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub array_type: Expression,
        pub array: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub index_type: Expression,
        pub index: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for IndexExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            IndexExpressionArgs {
                loc: None,
                array_type: Expression::NONE,
                array: None,
                index_type: Expression::NONE,
                index: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct IndexExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IndexExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    IndexExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_array_type(&mut self, array_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                IndexExpression::VT_ARRAY_TYPE,
                array_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_array(&mut self, array: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IndexExpression::VT_ARRAY, array);
        }
        #[inline]
        pub fn add_index_type(&mut self, index_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                IndexExpression::VT_INDEX_TYPE,
                index_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_index(&mut self, index: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IndexExpression::VT_INDEX, index);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(IndexExpression::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IndexExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> IndexExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IndexExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<IndexExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for IndexExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("IndexExpression");
            ds.field("loc", &self.loc());
            ds.field("array_type", &self.array_type());
            match self.array_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.array_as_string_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.array_as_array_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.array_as_dict_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.array_as_function_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.array_as_binary_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.array_as_call_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.array_as_conditional_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.array_as_identifier_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.array_as_logical_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.array_as_member_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.array_as_index_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.array_as_object_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.array_as_unary_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.array_as_boolean_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.array_as_date_time_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.array_as_duration_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.array_as_float_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.array_as_integer_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.array_as_string_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.array_as_regexp_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.array_as_unsigned_integer_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("array", &x)
                }
            };
            ds.field("index_type", &self.index_type());
            match self.index_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.index_as_string_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.index_as_array_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.index_as_dict_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.index_as_function_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.index_as_binary_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.index_as_call_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.index_as_conditional_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.index_as_identifier_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.index_as_logical_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.index_as_member_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.index_as_index_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.index_as_object_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.index_as_unary_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.index_as_boolean_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.index_as_date_time_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.index_as_duration_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.index_as_float_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.index_as_integer_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.index_as_string_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.index_as_regexp_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.index_as_unsigned_integer_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("index", &x)
                }
            };
            ds.field("typ_type", &self.typ_type());
            match self.typ_type() {
                MonoType::Basic => {
                    if let Some(x) = self.typ_as_basic() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.typ_as_var() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.typ_as_arr() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.typ_as_record() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.typ_as_fun() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.typ_as_dict() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.typ_as_vector() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("typ", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum ObjectExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ObjectExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ObjectExpression<'a> {
        type Inner = ObjectExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ObjectExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ObjectExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ObjectExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<ObjectExpression<'bldr>> {
            let mut builder = ObjectExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.properties {
                builder.add_properties(x);
            }
            if let Some(x) = args.with {
                builder.add_with(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_WITH: flatbuffers::VOffsetT = 6;
        pub const VT_PROPERTIES: flatbuffers::VOffsetT = 8;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_TYP: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(ObjectExpression::VT_LOC, None)
        }
        #[inline]
        pub fn with(&self) -> Option<IdentifierExpression<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<IdentifierExpression>>(
                    ObjectExpression::VT_WITH,
                    None,
                )
        }
        #[inline]
        pub fn properties(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>,
            >>(ObjectExpression::VT_PROPERTIES, None)
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(ObjectExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ObjectExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_record(&self) -> Option<Record<'a>> {
            if self.typ_type() == MonoType::Record {
                self.typ().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_dict(&self) -> Option<Dict<'a>> {
            if self.typ_type() == MonoType::Dict {
                self.typ().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_vector(&self) -> Option<Vector<'a>> {
            if self.typ_type() == MonoType::Vector {
                self.typ().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ObjectExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<IdentifierExpression>>(
                    &"with",
                    Self::VT_WITH,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>,
                >>(&"properties", Self::VT_PROPERTIES, false)?
                .visit_union::<MonoType, _>(
                    &"typ_type",
                    Self::VT_TYP_TYPE,
                    &"typ",
                    Self::VT_TYP,
                    false,
                    |key, v, pos| match key {
                        MonoType::Basic => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>(
                                "MonoType::Basic",
                                pos,
                            ),
                        MonoType::Var => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>(
                                "MonoType::Var",
                                pos,
                            ),
                        MonoType::Arr => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>(
                                "MonoType::Arr",
                                pos,
                            ),
                        MonoType::Record => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>(
                                "MonoType::Record",
                                pos,
                            ),
                        MonoType::Fun => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>(
                                "MonoType::Fun",
                                pos,
                            ),
                        MonoType::Dict => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>(
                                "MonoType::Dict",
                                pos,
                            ),
                        MonoType::Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>(
                                "MonoType::Vector",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ObjectExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub with: Option<flatbuffers::WIPOffset<IdentifierExpression<'a>>>,
        pub properties: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>,
            >,
        >,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ObjectExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            ObjectExpressionArgs {
                loc: None,
                with: None,
                properties: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct ObjectExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ObjectExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    ObjectExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_with(&mut self, with: flatbuffers::WIPOffset<IdentifierExpression<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<IdentifierExpression>>(
                    ObjectExpression::VT_WITH,
                    with,
                );
        }
        #[inline]
        pub fn add_properties(
            &mut self,
            properties: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Property<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ObjectExpression::VT_PROPERTIES,
                properties,
            );
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                ObjectExpression::VT_TYP_TYPE,
                typ_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ObjectExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ObjectExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ObjectExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ObjectExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ObjectExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ObjectExpression");
            ds.field("loc", &self.loc());
            ds.field("with", &self.with());
            ds.field("properties", &self.properties());
            ds.field("typ_type", &self.typ_type());
            match self.typ_type() {
                MonoType::Basic => {
                    if let Some(x) = self.typ_as_basic() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.typ_as_var() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.typ_as_arr() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.typ_as_record() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.typ_as_fun() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.typ_as_dict() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.typ_as_vector() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("typ", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum UnaryExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UnaryExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnaryExpression<'a> {
        type Inner = UnaryExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> UnaryExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnaryExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UnaryExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<UnaryExpression<'bldr>> {
            let mut builder = UnaryExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.argument {
                builder.add_argument(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.add_argument_type(args.argument_type);
            builder.add_operator(args.operator);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_OPERATOR: flatbuffers::VOffsetT = 6;
        pub const VT_ARGUMENT_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_ARGUMENT: flatbuffers::VOffsetT = 10;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 12;
        pub const VT_TYP: flatbuffers::VOffsetT = 14;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(UnaryExpression::VT_LOC, None)
        }
        #[inline]
        pub fn operator(&self) -> Operator {
            self._tab
                .get::<Operator>(
                    UnaryExpression::VT_OPERATOR,
                    Some(Operator::MultiplicationOperator),
                )
                .unwrap()
        }
        #[inline]
        pub fn argument_type(&self) -> Expression {
            self._tab
                .get::<Expression>(UnaryExpression::VT_ARGUMENT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn argument(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    UnaryExpression::VT_ARGUMENT,
                    None,
                )
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(UnaryExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    UnaryExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.argument_type() == Expression::StringExpression {
                self.argument().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.argument_type() == Expression::ArrayExpression {
                self.argument().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.argument_type() == Expression::DictExpression {
                self.argument().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.argument_type() == Expression::FunctionExpression {
                self.argument().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.argument_type() == Expression::BinaryExpression {
                self.argument().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.argument_type() == Expression::CallExpression {
                self.argument().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.argument_type() == Expression::ConditionalExpression {
                self.argument().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.argument_type() == Expression::IdentifierExpression {
                self.argument().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.argument_type() == Expression::LogicalExpression {
                self.argument().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.argument_type() == Expression::MemberExpression {
                self.argument().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.argument_type() == Expression::IndexExpression {
                self.argument().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.argument_type() == Expression::ObjectExpression {
                self.argument().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.argument_type() == Expression::UnaryExpression {
                self.argument().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.argument_type() == Expression::BooleanLiteral {
                self.argument().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.argument_type() == Expression::DateTimeLiteral {
                self.argument().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.argument_type() == Expression::DurationLiteral {
                self.argument().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.argument_type() == Expression::FloatLiteral {
                self.argument().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.argument_type() == Expression::IntegerLiteral {
                self.argument().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.argument_type() == Expression::StringLiteral {
                self.argument().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.argument_type() == Expression::RegexpLiteral {
                self.argument().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.argument_type() == Expression::UnsignedIntegerLiteral {
                self.argument().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_record(&self) -> Option<Record<'a>> {
            if self.typ_type() == MonoType::Record {
                self.typ().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_dict(&self) -> Option<Dict<'a>> {
            if self.typ_type() == MonoType::Dict {
                self.typ().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_vector(&self) -> Option<Vector<'a>> {
            if self.typ_type() == MonoType::Vector {
                self.typ().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for UnaryExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(&"loc", Self::VT_LOC, false)?
     .visit_field::<Operator>(&"operator", Self::VT_OPERATOR, false)?
     .visit_union::<Expression, _>(&"argument_type", Self::VT_ARGUMENT_TYPE, &"argument", Self::VT_ARGUMENT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<MonoType, _>(&"typ_type", Self::VT_TYP_TYPE, &"typ", Self::VT_TYP, false, |key, v, pos| {
        match key {
          MonoType::Basic => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>("MonoType::Basic", pos),
          MonoType::Var => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>("MonoType::Var", pos),
          MonoType::Arr => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>("MonoType::Arr", pos),
          MonoType::Record => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>("MonoType::Record", pos),
          MonoType::Fun => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>("MonoType::Fun", pos),
          MonoType::Dict => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>("MonoType::Dict", pos),
          MonoType::Vector => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>("MonoType::Vector", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct UnaryExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub operator: Operator,
        pub argument_type: Expression,
        pub argument: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for UnaryExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            UnaryExpressionArgs {
                loc: None,
                operator: Operator::MultiplicationOperator,
                argument_type: Expression::NONE,
                argument: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct UnaryExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UnaryExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    UnaryExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_operator(&mut self, operator: Operator) {
            self.fbb_.push_slot::<Operator>(
                UnaryExpression::VT_OPERATOR,
                operator,
                Operator::MultiplicationOperator,
            );
        }
        #[inline]
        pub fn add_argument_type(&mut self, argument_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                UnaryExpression::VT_ARGUMENT_TYPE,
                argument_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_argument(
            &mut self,
            argument: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UnaryExpression::VT_ARGUMENT,
                argument,
            );
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(UnaryExpression::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UnaryExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UnaryExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UnaryExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnaryExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for UnaryExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("UnaryExpression");
            ds.field("loc", &self.loc());
            ds.field("operator", &self.operator());
            ds.field("argument_type", &self.argument_type());
            match self.argument_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.argument_as_string_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.argument_as_array_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.argument_as_dict_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.argument_as_function_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.argument_as_binary_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.argument_as_call_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.argument_as_conditional_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.argument_as_identifier_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.argument_as_logical_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.argument_as_member_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.argument_as_index_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.argument_as_object_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.argument_as_unary_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.argument_as_boolean_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.argument_as_date_time_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.argument_as_duration_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.argument_as_float_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.argument_as_integer_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.argument_as_string_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.argument_as_regexp_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.argument_as_unsigned_integer_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("argument", &x)
                }
            };
            ds.field("typ_type", &self.typ_type());
            match self.typ_type() {
                MonoType::Basic => {
                    if let Some(x) = self.typ_as_basic() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.typ_as_var() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.typ_as_arr() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.typ_as_record() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.typ_as_fun() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.typ_as_dict() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.typ_as_vector() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("typ", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum PropertyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Property<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Property<'a> {
        type Inner = Property<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Property<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Property { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PropertyArgs<'args>,
        ) -> flatbuffers::WIPOffset<Property<'bldr>> {
            let mut builder = PropertyBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_value_type(args.value_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_KEY: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_VALUE: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(Property::VT_LOC, None)
        }
        #[inline]
        pub fn key(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(Property::VT_KEY, None)
        }
        #[inline]
        pub fn value_type(&self) -> Expression {
            self._tab
                .get::<Expression>(Property::VT_VALUE_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    Property::VT_VALUE,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.value_type() == Expression::StringExpression {
                self.value().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.value_type() == Expression::ArrayExpression {
                self.value().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.value_type() == Expression::DictExpression {
                self.value().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.value_type() == Expression::FunctionExpression {
                self.value().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.value_type() == Expression::BinaryExpression {
                self.value().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.value_type() == Expression::CallExpression {
                self.value().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.value_type() == Expression::ConditionalExpression {
                self.value().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.value_type() == Expression::IdentifierExpression {
                self.value().map(IdentifierExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.value_type() == Expression::LogicalExpression {
                self.value().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.value_type() == Expression::MemberExpression {
                self.value().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.value_type() == Expression::IndexExpression {
                self.value().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.value_type() == Expression::ObjectExpression {
                self.value().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.value_type() == Expression::UnaryExpression {
                self.value().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.value_type() == Expression::BooleanLiteral {
                self.value().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.value_type() == Expression::DateTimeLiteral {
                self.value().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.value_type() == Expression::DurationLiteral {
                self.value().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.value_type() == Expression::FloatLiteral {
                self.value().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.value_type() == Expression::IntegerLiteral {
                self.value().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.value_type() == Expression::StringLiteral {
                self.value().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.value_type() == Expression::RegexpLiteral {
                self.value().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.value_type() == Expression::UnsignedIntegerLiteral {
                self.value().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for Property<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(&"loc", Self::VT_LOC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(&"key", Self::VT_KEY, false)?
     .visit_union::<Expression, _>(&"value_type", Self::VT_VALUE_TYPE, &"value", Self::VT_VALUE, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::IdentifierExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IdentifierExpression>>("Expression::IdentifierExpression", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct PropertyArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub key: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub value_type: Expression,
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for PropertyArgs<'a> {
        #[inline]
        fn default() -> Self {
            PropertyArgs {
                loc: None,
                key: None,
                value_type: Expression::NONE,
                value: None,
            }
        }
    }
    pub struct PropertyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PropertyBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(Property::VT_LOC, loc);
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(Property::VT_KEY, key);
        }
        #[inline]
        pub fn add_value_type(&mut self, value_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                Property::VT_VALUE_TYPE,
                value_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Property::VT_VALUE, value);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PropertyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PropertyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Property<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Property<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Property");
            ds.field("loc", &self.loc());
            ds.field("key", &self.key());
            ds.field("value_type", &self.value_type());
            match self.value_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.value_as_string_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.value_as_array_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.value_as_dict_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.value_as_function_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.value_as_binary_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.value_as_call_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.value_as_conditional_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IdentifierExpression => {
                    if let Some(x) = self.value_as_identifier_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.value_as_logical_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.value_as_member_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.value_as_index_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.value_as_object_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.value_as_unary_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.value_as_boolean_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.value_as_date_time_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.value_as_duration_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.value_as_float_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.value_as_integer_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.value_as_string_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.value_as_regexp_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.value_as_unsigned_integer_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("value", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum IdentifierExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct IdentifierExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for IdentifierExpression<'a> {
        type Inner = IdentifierExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> IdentifierExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            IdentifierExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IdentifierExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<IdentifierExpression<'bldr>> {
            let mut builder = IdentifierExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_TYP: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    IdentifierExpression::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(IdentifierExpression::VT_NAME, None)
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(IdentifierExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    IdentifierExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(Basic::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(Var::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(Arr::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_record(&self) -> Option<Record<'a>> {
            if self.typ_type() == MonoType::Record {
                self.typ().map(Record::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(Fun::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_dict(&self) -> Option<Dict<'a>> {
            if self.typ_type() == MonoType::Dict {
                self.typ().map(Dict::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_vector(&self) -> Option<Vector<'a>> {
            if self.typ_type() == MonoType::Vector {
                self.typ().map(Vector::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for IdentifierExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
                .visit_union::<MonoType, _>(
                    &"typ_type",
                    Self::VT_TYP_TYPE,
                    &"typ",
                    Self::VT_TYP,
                    false,
                    |key, v, pos| match key {
                        MonoType::Basic => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Basic>>(
                                "MonoType::Basic",
                                pos,
                            ),
                        MonoType::Var => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>(
                                "MonoType::Var",
                                pos,
                            ),
                        MonoType::Arr => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Arr>>(
                                "MonoType::Arr",
                                pos,
                            ),
                        MonoType::Record => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Record>>(
                                "MonoType::Record",
                                pos,
                            ),
                        MonoType::Fun => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Fun>>(
                                "MonoType::Fun",
                                pos,
                            ),
                        MonoType::Dict => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Dict>>(
                                "MonoType::Dict",
                                pos,
                            ),
                        MonoType::Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Vector>>(
                                "MonoType::Vector",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct IdentifierExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for IdentifierExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            IdentifierExpressionArgs {
                loc: None,
                name: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct IdentifierExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IdentifierExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    IdentifierExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IdentifierExpression::VT_NAME, name);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                IdentifierExpression::VT_TYP_TYPE,
                typ_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IdentifierExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> IdentifierExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IdentifierExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<IdentifierExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for IdentifierExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("IdentifierExpression");
            ds.field("loc", &self.loc());
            ds.field("name", &self.name());
            ds.field("typ_type", &self.typ_type());
            match self.typ_type() {
                MonoType::Basic => {
                    if let Some(x) = self.typ_as_basic() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Var => {
                    if let Some(x) = self.typ_as_var() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Arr => {
                    if let Some(x) = self.typ_as_arr() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Record => {
                    if let Some(x) = self.typ_as_record() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Fun => {
                    if let Some(x) = self.typ_as_fun() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Dict => {
                    if let Some(x) = self.typ_as_dict() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::Vector => {
                    if let Some(x) = self.typ_as_vector() {
                        ds.field("typ", &x)
                    } else {
                        ds.field(
                            "typ",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("typ", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum IdentifierOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Identifier<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Identifier<'a> {
        type Inner = Identifier<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Identifier<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Identifier { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IdentifierArgs<'args>,
        ) -> flatbuffers::WIPOffset<Identifier<'bldr>> {
            let mut builder = IdentifierBuilder::new(_fbb);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(Identifier::VT_LOC, None)
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Identifier::VT_NAME, None)
        }
    }

    impl flatbuffers::Verifiable for Identifier<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
                .finish();
            Ok(())
        }
    }
    pub struct IdentifierArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for IdentifierArgs<'a> {
        #[inline]
        fn default() -> Self {
            IdentifierArgs {
                loc: None,
                name: None,
            }
        }
    }
    pub struct IdentifierBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IdentifierBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    Identifier::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Identifier::VT_NAME, name);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IdentifierBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IdentifierBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Identifier<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Identifier<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Identifier");
            ds.field("loc", &self.loc());
            ds.field("name", &self.name());
            ds.finish()
        }
    }
    pub enum BooleanLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BooleanLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BooleanLiteral<'a> {
        type Inner = BooleanLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> BooleanLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BooleanLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BooleanLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<BooleanLiteral<'bldr>> {
            let mut builder = BooleanLiteralBuilder::new(_fbb);
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_value(args.value);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(BooleanLiteral::VT_LOC, None)
        }
        #[inline]
        pub fn value(&self) -> bool {
            self._tab
                .get::<bool>(BooleanLiteral::VT_VALUE, Some(false))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for BooleanLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<bool>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BooleanLiteralArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub value: bool,
    }
    impl<'a> Default for BooleanLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            BooleanLiteralArgs {
                loc: None,
                value: false,
            }
        }
    }
    pub struct BooleanLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BooleanLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    BooleanLiteral::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: bool) {
            self.fbb_
                .push_slot::<bool>(BooleanLiteral::VT_VALUE, value, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BooleanLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BooleanLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BooleanLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for BooleanLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("BooleanLiteral");
            ds.field("loc", &self.loc());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum DateTimeLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DateTimeLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DateTimeLiteral<'a> {
        type Inner = DateTimeLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> DateTimeLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DateTimeLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DateTimeLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<DateTimeLiteral<'bldr>> {
            let mut builder = DateTimeLiteralBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(DateTimeLiteral::VT_LOC, None)
        }
        #[inline]
        pub fn value(&self) -> Option<Time<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Time>>(DateTimeLiteral::VT_VALUE, None)
        }
    }

    impl flatbuffers::Verifiable for DateTimeLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Time>>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DateTimeLiteralArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub value: Option<flatbuffers::WIPOffset<Time<'a>>>,
    }
    impl<'a> Default for DateTimeLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            DateTimeLiteralArgs {
                loc: None,
                value: None,
            }
        }
    }
    pub struct DateTimeLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DateTimeLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    DateTimeLiteral::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<Time<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Time>>(DateTimeLiteral::VT_VALUE, value);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DateTimeLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DateTimeLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DateTimeLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for DateTimeLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("DateTimeLiteral");
            ds.field("loc", &self.loc());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum TimeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Time<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Time<'a> {
        type Inner = Time<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Time<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Time { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TimeArgs,
        ) -> flatbuffers::WIPOffset<Time<'bldr>> {
            let mut builder = TimeBuilder::new(_fbb);
            builder.add_secs(args.secs);
            builder.add_offset(args.offset);
            builder.add_nsecs(args.nsecs);
            builder.finish()
        }

        pub const VT_SECS: flatbuffers::VOffsetT = 4;
        pub const VT_NSECS: flatbuffers::VOffsetT = 6;
        pub const VT_OFFSET: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn secs(&self) -> i64 {
            self._tab.get::<i64>(Time::VT_SECS, Some(0)).unwrap()
        }
        #[inline]
        pub fn nsecs(&self) -> u32 {
            self._tab.get::<u32>(Time::VT_NSECS, Some(0)).unwrap()
        }
        #[inline]
        pub fn offset(&self) -> i32 {
            self._tab.get::<i32>(Time::VT_OFFSET, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for Time<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i64>(&"secs", Self::VT_SECS, false)?
                .visit_field::<u32>(&"nsecs", Self::VT_NSECS, false)?
                .visit_field::<i32>(&"offset", Self::VT_OFFSET, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TimeArgs {
        pub secs: i64,
        pub nsecs: u32,
        pub offset: i32,
    }
    impl<'a> Default for TimeArgs {
        #[inline]
        fn default() -> Self {
            TimeArgs {
                secs: 0,
                nsecs: 0,
                offset: 0,
            }
        }
    }
    pub struct TimeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TimeBuilder<'a, 'b> {
        #[inline]
        pub fn add_secs(&mut self, secs: i64) {
            self.fbb_.push_slot::<i64>(Time::VT_SECS, secs, 0);
        }
        #[inline]
        pub fn add_nsecs(&mut self, nsecs: u32) {
            self.fbb_.push_slot::<u32>(Time::VT_NSECS, nsecs, 0);
        }
        #[inline]
        pub fn add_offset(&mut self, offset: i32) {
            self.fbb_.push_slot::<i32>(Time::VT_OFFSET, offset, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TimeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TimeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Time<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Time<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Time");
            ds.field("secs", &self.secs());
            ds.field("nsecs", &self.nsecs());
            ds.field("offset", &self.offset());
            ds.finish()
        }
    }
    pub enum DurationOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Duration<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Duration<'a> {
        type Inner = Duration<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Duration<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Duration { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DurationArgs,
        ) -> flatbuffers::WIPOffset<Duration<'bldr>> {
            let mut builder = DurationBuilder::new(_fbb);
            builder.add_nanoseconds(args.nanoseconds);
            builder.add_months(args.months);
            builder.add_negative(args.negative);
            builder.finish()
        }

        pub const VT_MONTHS: flatbuffers::VOffsetT = 4;
        pub const VT_NANOSECONDS: flatbuffers::VOffsetT = 6;
        pub const VT_NEGATIVE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn months(&self) -> i64 {
            self._tab.get::<i64>(Duration::VT_MONTHS, Some(0)).unwrap()
        }
        #[inline]
        pub fn nanoseconds(&self) -> i64 {
            self._tab
                .get::<i64>(Duration::VT_NANOSECONDS, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn negative(&self) -> bool {
            self._tab
                .get::<bool>(Duration::VT_NEGATIVE, Some(false))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for Duration<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i64>(&"months", Self::VT_MONTHS, false)?
                .visit_field::<i64>(&"nanoseconds", Self::VT_NANOSECONDS, false)?
                .visit_field::<bool>(&"negative", Self::VT_NEGATIVE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DurationArgs {
        pub months: i64,
        pub nanoseconds: i64,
        pub negative: bool,
    }
    impl<'a> Default for DurationArgs {
        #[inline]
        fn default() -> Self {
            DurationArgs {
                months: 0,
                nanoseconds: 0,
                negative: false,
            }
        }
    }
    pub struct DurationBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DurationBuilder<'a, 'b> {
        #[inline]
        pub fn add_months(&mut self, months: i64) {
            self.fbb_.push_slot::<i64>(Duration::VT_MONTHS, months, 0);
        }
        #[inline]
        pub fn add_nanoseconds(&mut self, nanoseconds: i64) {
            self.fbb_
                .push_slot::<i64>(Duration::VT_NANOSECONDS, nanoseconds, 0);
        }
        #[inline]
        pub fn add_negative(&mut self, negative: bool) {
            self.fbb_
                .push_slot::<bool>(Duration::VT_NEGATIVE, negative, false);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DurationBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DurationBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Duration<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Duration<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Duration");
            ds.field("months", &self.months());
            ds.field("nanoseconds", &self.nanoseconds());
            ds.field("negative", &self.negative());
            ds.finish()
        }
    }
    pub enum DurationLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DurationLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DurationLiteral<'a> {
        type Inner = DurationLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> DurationLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DurationLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DurationLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<DurationLiteral<'bldr>> {
            let mut builder = DurationLiteralBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(DurationLiteral::VT_LOC, None)
        }
        #[inline]
        pub fn value(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Duration<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Duration>>,
            >>(DurationLiteral::VT_VALUE, None)
        }
    }

    impl flatbuffers::Verifiable for DurationLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Duration>>,
                >>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DurationLiteralArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub value: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Duration<'a>>>,
            >,
        >,
    }
    impl<'a> Default for DurationLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            DurationLiteralArgs {
                loc: None,
                value: None,
            }
        }
    }
    pub struct DurationLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DurationLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    DurationLiteral::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_value(
            &mut self,
            value: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Duration<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DurationLiteral::VT_VALUE, value);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DurationLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DurationLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DurationLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for DurationLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("DurationLiteral");
            ds.field("loc", &self.loc());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum IntegerLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct IntegerLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for IntegerLiteral<'a> {
        type Inner = IntegerLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> IntegerLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            IntegerLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IntegerLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<IntegerLiteral<'bldr>> {
            let mut builder = IntegerLiteralBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(IntegerLiteral::VT_LOC, None)
        }
        #[inline]
        pub fn value(&self) -> i64 {
            self._tab
                .get::<i64>(IntegerLiteral::VT_VALUE, Some(0))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for IntegerLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<i64>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct IntegerLiteralArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub value: i64,
    }
    impl<'a> Default for IntegerLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            IntegerLiteralArgs {
                loc: None,
                value: 0,
            }
        }
    }
    pub struct IntegerLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IntegerLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    IntegerLiteral::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: i64) {
            self.fbb_
                .push_slot::<i64>(IntegerLiteral::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> IntegerLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IntegerLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<IntegerLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for IntegerLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("IntegerLiteral");
            ds.field("loc", &self.loc());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum FloatLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FloatLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FloatLiteral<'a> {
        type Inner = FloatLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> FloatLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FloatLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FloatLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<FloatLiteral<'bldr>> {
            let mut builder = FloatLiteralBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(FloatLiteral::VT_LOC, None)
        }
        #[inline]
        pub fn value(&self) -> f64 {
            self._tab
                .get::<f64>(FloatLiteral::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for FloatLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<f64>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct FloatLiteralArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub value: f64,
    }
    impl<'a> Default for FloatLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            FloatLiteralArgs {
                loc: None,
                value: 0.0,
            }
        }
    }
    pub struct FloatLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FloatLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    FloatLiteral::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: f64) {
            self.fbb_
                .push_slot::<f64>(FloatLiteral::VT_VALUE, value, 0.0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FloatLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FloatLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FloatLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for FloatLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("FloatLiteral");
            ds.field("loc", &self.loc());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum RegexpLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RegexpLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RegexpLiteral<'a> {
        type Inner = RegexpLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> RegexpLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RegexpLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RegexpLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<RegexpLiteral<'bldr>> {
            let mut builder = RegexpLiteralBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(RegexpLiteral::VT_LOC, None)
        }
        #[inline]
        pub fn value(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(RegexpLiteral::VT_VALUE, None)
        }
    }

    impl flatbuffers::Verifiable for RegexpLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RegexpLiteralArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for RegexpLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            RegexpLiteralArgs {
                loc: None,
                value: None,
            }
        }
    }
    pub struct RegexpLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RegexpLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    RegexpLiteral::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(RegexpLiteral::VT_VALUE, value);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> RegexpLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RegexpLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RegexpLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for RegexpLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("RegexpLiteral");
            ds.field("loc", &self.loc());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum StringLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct StringLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StringLiteral<'a> {
        type Inner = StringLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> StringLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StringLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StringLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<StringLiteral<'bldr>> {
            let mut builder = StringLiteralBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(StringLiteral::VT_LOC, None)
        }
        #[inline]
        pub fn value(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(StringLiteral::VT_VALUE, None)
        }
    }

    impl flatbuffers::Verifiable for StringLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct StringLiteralArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for StringLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            StringLiteralArgs {
                loc: None,
                value: None,
            }
        }
    }
    pub struct StringLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StringLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    StringLiteral::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(StringLiteral::VT_VALUE, value);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> StringLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StringLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StringLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for StringLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("StringLiteral");
            ds.field("loc", &self.loc());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum UnsignedIntegerLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UnsignedIntegerLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnsignedIntegerLiteral<'a> {
        type Inner = UnsignedIntegerLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> UnsignedIntegerLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnsignedIntegerLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UnsignedIntegerLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<UnsignedIntegerLiteral<'bldr>> {
            let mut builder = UnsignedIntegerLiteralBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    UnsignedIntegerLiteral::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn value(&self) -> u64 {
            self._tab
                .get::<u64>(UnsignedIntegerLiteral::VT_VALUE, Some(0))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for UnsignedIntegerLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<u64>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UnsignedIntegerLiteralArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub value: u64,
    }
    impl<'a> Default for UnsignedIntegerLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            UnsignedIntegerLiteralArgs {
                loc: None,
                value: 0,
            }
        }
    }
    pub struct UnsignedIntegerLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UnsignedIntegerLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    UnsignedIntegerLiteral::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_
                .push_slot::<u64>(UnsignedIntegerLiteral::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UnsignedIntegerLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UnsignedIntegerLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnsignedIntegerLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for UnsignedIntegerLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("UnsignedIntegerLiteral");
            ds.field("loc", &self.loc());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    #[inline]
    #[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
    pub fn get_root_as_package<'a>(buf: &'a [u8]) -> Package<'a> {
        unsafe { flatbuffers::root_unchecked::<Package<'a>>(buf) }
    }

    #[inline]
    #[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
    pub fn get_size_prefixed_root_as_package<'a>(buf: &'a [u8]) -> Package<'a> {
        unsafe { flatbuffers::size_prefixed_root_unchecked::<Package<'a>>(buf) }
    }

    #[inline]
    /// Verifies that a buffer of bytes contains a `Package`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_package_unchecked`.
    pub fn root_as_package(buf: &[u8]) -> Result<Package, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<Package>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `Package` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_package_unchecked`.
    pub fn size_prefixed_root_as_package(
        buf: &[u8],
    ) -> Result<Package, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<Package>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `Package` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_package_unchecked`.
    pub fn root_as_package_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Package<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<Package<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `Package` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_package_unchecked`.
    pub fn size_prefixed_root_as_package_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Package<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<Package<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a Package and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `Package`.
    pub unsafe fn root_as_package_unchecked(buf: &[u8]) -> Package {
        flatbuffers::root_unchecked::<Package>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed Package and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `Package`.
    pub unsafe fn size_prefixed_root_as_package_unchecked(buf: &[u8]) -> Package {
        flatbuffers::size_prefixed_root_unchecked::<Package>(buf)
    }
    #[inline]
    pub fn finish_package_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Package<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_package_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Package<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod fbsemantic

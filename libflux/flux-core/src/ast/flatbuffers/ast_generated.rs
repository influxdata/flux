// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod fbast {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_MONO_TYPE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_MONO_TYPE: u8 = 6;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_MONO_TYPE: [MonoType; 7] = [
        MonoType::NONE,
        MonoType::NamedType,
        MonoType::TvarType,
        MonoType::ArrayType,
        MonoType::DictType,
        MonoType::RecordType,
        MonoType::FunctionType,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct MonoType(pub u8);
    #[allow(non_upper_case_globals)]
    impl MonoType {
        pub const NONE: Self = Self(0);
        pub const NamedType: Self = Self(1);
        pub const TvarType: Self = Self(2);
        pub const ArrayType: Self = Self(3);
        pub const DictType: Self = Self(4);
        pub const RecordType: Self = Self(5);
        pub const FunctionType: Self = Self(6);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 6;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::NamedType,
            Self::TvarType,
            Self::ArrayType,
            Self::DictType,
            Self::RecordType,
            Self::FunctionType,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::NamedType => Some("NamedType"),
                Self::TvarType => Some("TvarType"),
                Self::ArrayType => Some("ArrayType"),
                Self::DictType => Some("DictType"),
                Self::RecordType => Some("RecordType"),
                Self::FunctionType => Some("FunctionType"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for MonoType {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for MonoType {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for MonoType {
        type Output = MonoType;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for MonoType {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for MonoType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for MonoType {}
    pub struct MonoTypeUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_PARAMETER_KIND: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_PARAMETER_KIND: i8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_PARAMETER_KIND: [ParameterKind; 3] = [
        ParameterKind::Required,
        ParameterKind::Optional,
        ParameterKind::Pipe,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ParameterKind(pub i8);
    #[allow(non_upper_case_globals)]
    impl ParameterKind {
        pub const Required: Self = Self(0);
        pub const Optional: Self = Self(1);
        pub const Pipe: Self = Self(2);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[Self::Required, Self::Optional, Self::Pipe];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Required => Some("Required"),
                Self::Optional => Some("Optional"),
                Self::Pipe => Some("Pipe"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for ParameterKind {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ParameterKind {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for ParameterKind {
        type Output = ParameterKind;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for ParameterKind {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = i8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = i8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ParameterKind {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ParameterKind {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_STATEMENT: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_STATEMENT: u8 = 9;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_STATEMENT: [Statement; 10] = [
        Statement::NONE,
        Statement::BadStatement,
        Statement::VariableAssignment,
        Statement::MemberAssignment,
        Statement::ExpressionStatement,
        Statement::ReturnStatement,
        Statement::OptionStatement,
        Statement::BuiltinStatement,
        Statement::TestStatement,
        Statement::TestCaseStatement,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct Statement(pub u8);
    #[allow(non_upper_case_globals)]
    impl Statement {
        pub const NONE: Self = Self(0);
        pub const BadStatement: Self = Self(1);
        pub const VariableAssignment: Self = Self(2);
        pub const MemberAssignment: Self = Self(3);
        pub const ExpressionStatement: Self = Self(4);
        pub const ReturnStatement: Self = Self(5);
        pub const OptionStatement: Self = Self(6);
        pub const BuiltinStatement: Self = Self(7);
        pub const TestStatement: Self = Self(8);
        pub const TestCaseStatement: Self = Self(9);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 9;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::BadStatement,
            Self::VariableAssignment,
            Self::MemberAssignment,
            Self::ExpressionStatement,
            Self::ReturnStatement,
            Self::OptionStatement,
            Self::BuiltinStatement,
            Self::TestStatement,
            Self::TestCaseStatement,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::BadStatement => Some("BadStatement"),
                Self::VariableAssignment => Some("VariableAssignment"),
                Self::MemberAssignment => Some("MemberAssignment"),
                Self::ExpressionStatement => Some("ExpressionStatement"),
                Self::ReturnStatement => Some("ReturnStatement"),
                Self::OptionStatement => Some("OptionStatement"),
                Self::BuiltinStatement => Some("BuiltinStatement"),
                Self::TestStatement => Some("TestStatement"),
                Self::TestCaseStatement => Some("TestCaseStatement"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for Statement {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for Statement {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for Statement {
        type Output = Statement;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for Statement {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for Statement {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Statement {}
    pub struct StatementUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_ASSIGNMENT: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_ASSIGNMENT: u8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_ASSIGNMENT: [Assignment; 3] = [
        Assignment::NONE,
        Assignment::MemberAssignment,
        Assignment::VariableAssignment,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct Assignment(pub u8);
    #[allow(non_upper_case_globals)]
    impl Assignment {
        pub const NONE: Self = Self(0);
        pub const MemberAssignment: Self = Self(1);
        pub const VariableAssignment: Self = Self(2);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 2;
        pub const ENUM_VALUES: &'static [Self] =
            &[Self::NONE, Self::MemberAssignment, Self::VariableAssignment];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::MemberAssignment => Some("MemberAssignment"),
                Self::VariableAssignment => Some("VariableAssignment"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for Assignment {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for Assignment {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for Assignment {
        type Output = Assignment;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for Assignment {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for Assignment {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Assignment {}
    pub struct AssignmentUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_EXPRESSION: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_EXPRESSION: u8 = 25;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_EXPRESSION: [Expression; 26] = [
        Expression::NONE,
        Expression::StringExpression,
        Expression::ParenExpression,
        Expression::ArrayExpression,
        Expression::DictExpression,
        Expression::FunctionExpression,
        Expression::BinaryExpression,
        Expression::BooleanLiteral,
        Expression::CallExpression,
        Expression::ConditionalExpression,
        Expression::DateTimeLiteral,
        Expression::DurationLiteral,
        Expression::FloatLiteral,
        Expression::Identifier,
        Expression::IntegerLiteral,
        Expression::LogicalExpression,
        Expression::MemberExpression,
        Expression::IndexExpression,
        Expression::ObjectExpression,
        Expression::PipeExpression,
        Expression::PipeLiteral,
        Expression::RegexpLiteral,
        Expression::StringLiteral,
        Expression::UnaryExpression,
        Expression::UnsignedIntegerLiteral,
        Expression::BadExpression,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct Expression(pub u8);
    #[allow(non_upper_case_globals)]
    impl Expression {
        pub const NONE: Self = Self(0);
        pub const StringExpression: Self = Self(1);
        pub const ParenExpression: Self = Self(2);
        pub const ArrayExpression: Self = Self(3);
        pub const DictExpression: Self = Self(4);
        pub const FunctionExpression: Self = Self(5);
        pub const BinaryExpression: Self = Self(6);
        pub const BooleanLiteral: Self = Self(7);
        pub const CallExpression: Self = Self(8);
        pub const ConditionalExpression: Self = Self(9);
        pub const DateTimeLiteral: Self = Self(10);
        pub const DurationLiteral: Self = Self(11);
        pub const FloatLiteral: Self = Self(12);
        pub const Identifier: Self = Self(13);
        pub const IntegerLiteral: Self = Self(14);
        pub const LogicalExpression: Self = Self(15);
        pub const MemberExpression: Self = Self(16);
        pub const IndexExpression: Self = Self(17);
        pub const ObjectExpression: Self = Self(18);
        pub const PipeExpression: Self = Self(19);
        pub const PipeLiteral: Self = Self(20);
        pub const RegexpLiteral: Self = Self(21);
        pub const StringLiteral: Self = Self(22);
        pub const UnaryExpression: Self = Self(23);
        pub const UnsignedIntegerLiteral: Self = Self(24);
        pub const BadExpression: Self = Self(25);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 25;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::StringExpression,
            Self::ParenExpression,
            Self::ArrayExpression,
            Self::DictExpression,
            Self::FunctionExpression,
            Self::BinaryExpression,
            Self::BooleanLiteral,
            Self::CallExpression,
            Self::ConditionalExpression,
            Self::DateTimeLiteral,
            Self::DurationLiteral,
            Self::FloatLiteral,
            Self::Identifier,
            Self::IntegerLiteral,
            Self::LogicalExpression,
            Self::MemberExpression,
            Self::IndexExpression,
            Self::ObjectExpression,
            Self::PipeExpression,
            Self::PipeLiteral,
            Self::RegexpLiteral,
            Self::StringLiteral,
            Self::UnaryExpression,
            Self::UnsignedIntegerLiteral,
            Self::BadExpression,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::StringExpression => Some("StringExpression"),
                Self::ParenExpression => Some("ParenExpression"),
                Self::ArrayExpression => Some("ArrayExpression"),
                Self::DictExpression => Some("DictExpression"),
                Self::FunctionExpression => Some("FunctionExpression"),
                Self::BinaryExpression => Some("BinaryExpression"),
                Self::BooleanLiteral => Some("BooleanLiteral"),
                Self::CallExpression => Some("CallExpression"),
                Self::ConditionalExpression => Some("ConditionalExpression"),
                Self::DateTimeLiteral => Some("DateTimeLiteral"),
                Self::DurationLiteral => Some("DurationLiteral"),
                Self::FloatLiteral => Some("FloatLiteral"),
                Self::Identifier => Some("Identifier"),
                Self::IntegerLiteral => Some("IntegerLiteral"),
                Self::LogicalExpression => Some("LogicalExpression"),
                Self::MemberExpression => Some("MemberExpression"),
                Self::IndexExpression => Some("IndexExpression"),
                Self::ObjectExpression => Some("ObjectExpression"),
                Self::PipeExpression => Some("PipeExpression"),
                Self::PipeLiteral => Some("PipeLiteral"),
                Self::RegexpLiteral => Some("RegexpLiteral"),
                Self::StringLiteral => Some("StringLiteral"),
                Self::UnaryExpression => Some("UnaryExpression"),
                Self::UnsignedIntegerLiteral => Some("UnsignedIntegerLiteral"),
                Self::BadExpression => Some("BadExpression"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for Expression {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for Expression {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for Expression {
        type Output = Expression;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for Expression {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for Expression {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Expression {}
    pub struct ExpressionUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_OPERATOR: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_OPERATOR: i8 = 20;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_OPERATOR: [Operator; 21] = [
        Operator::InvalidOperator,
        Operator::MultiplicationOperator,
        Operator::DivisionOperator,
        Operator::ModuloOperator,
        Operator::PowerOperator,
        Operator::AdditionOperator,
        Operator::SubtractionOperator,
        Operator::LessThanEqualOperator,
        Operator::LessThanOperator,
        Operator::GreaterThanEqualOperator,
        Operator::GreaterThanOperator,
        Operator::StartsWithOperator,
        Operator::InOperator,
        Operator::NotOperator,
        Operator::ExistsOperator,
        Operator::NotEmptyOperator,
        Operator::EmptyOperator,
        Operator::EqualOperator,
        Operator::NotEqualOperator,
        Operator::RegexpMatchOperator,
        Operator::NotRegexpMatchOperator,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct Operator(pub i8);
    #[allow(non_upper_case_globals)]
    impl Operator {
        pub const InvalidOperator: Self = Self(0);
        pub const MultiplicationOperator: Self = Self(1);
        pub const DivisionOperator: Self = Self(2);
        pub const ModuloOperator: Self = Self(3);
        pub const PowerOperator: Self = Self(4);
        pub const AdditionOperator: Self = Self(5);
        pub const SubtractionOperator: Self = Self(6);
        pub const LessThanEqualOperator: Self = Self(7);
        pub const LessThanOperator: Self = Self(8);
        pub const GreaterThanEqualOperator: Self = Self(9);
        pub const GreaterThanOperator: Self = Self(10);
        pub const StartsWithOperator: Self = Self(11);
        pub const InOperator: Self = Self(12);
        pub const NotOperator: Self = Self(13);
        pub const ExistsOperator: Self = Self(14);
        pub const NotEmptyOperator: Self = Self(15);
        pub const EmptyOperator: Self = Self(16);
        pub const EqualOperator: Self = Self(17);
        pub const NotEqualOperator: Self = Self(18);
        pub const RegexpMatchOperator: Self = Self(19);
        pub const NotRegexpMatchOperator: Self = Self(20);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 20;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::InvalidOperator,
            Self::MultiplicationOperator,
            Self::DivisionOperator,
            Self::ModuloOperator,
            Self::PowerOperator,
            Self::AdditionOperator,
            Self::SubtractionOperator,
            Self::LessThanEqualOperator,
            Self::LessThanOperator,
            Self::GreaterThanEqualOperator,
            Self::GreaterThanOperator,
            Self::StartsWithOperator,
            Self::InOperator,
            Self::NotOperator,
            Self::ExistsOperator,
            Self::NotEmptyOperator,
            Self::EmptyOperator,
            Self::EqualOperator,
            Self::NotEqualOperator,
            Self::RegexpMatchOperator,
            Self::NotRegexpMatchOperator,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::InvalidOperator => Some("InvalidOperator"),
                Self::MultiplicationOperator => Some("MultiplicationOperator"),
                Self::DivisionOperator => Some("DivisionOperator"),
                Self::ModuloOperator => Some("ModuloOperator"),
                Self::PowerOperator => Some("PowerOperator"),
                Self::AdditionOperator => Some("AdditionOperator"),
                Self::SubtractionOperator => Some("SubtractionOperator"),
                Self::LessThanEqualOperator => Some("LessThanEqualOperator"),
                Self::LessThanOperator => Some("LessThanOperator"),
                Self::GreaterThanEqualOperator => Some("GreaterThanEqualOperator"),
                Self::GreaterThanOperator => Some("GreaterThanOperator"),
                Self::StartsWithOperator => Some("StartsWithOperator"),
                Self::InOperator => Some("InOperator"),
                Self::NotOperator => Some("NotOperator"),
                Self::ExistsOperator => Some("ExistsOperator"),
                Self::NotEmptyOperator => Some("NotEmptyOperator"),
                Self::EmptyOperator => Some("EmptyOperator"),
                Self::EqualOperator => Some("EqualOperator"),
                Self::NotEqualOperator => Some("NotEqualOperator"),
                Self::RegexpMatchOperator => Some("RegexpMatchOperator"),
                Self::NotRegexpMatchOperator => Some("NotRegexpMatchOperator"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for Operator {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for Operator {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for Operator {
        type Output = Operator;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for Operator {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = i8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = i8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for Operator {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Operator {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_LOGICAL_OPERATOR: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_LOGICAL_OPERATOR: i8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_LOGICAL_OPERATOR: [LogicalOperator; 2] =
        [LogicalOperator::AndOperator, LogicalOperator::OrOperator];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct LogicalOperator(pub i8);
    #[allow(non_upper_case_globals)]
    impl LogicalOperator {
        pub const AndOperator: Self = Self(0);
        pub const OrOperator: Self = Self(1);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::AndOperator, Self::OrOperator];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::AndOperator => Some("AndOperator"),
                Self::OrOperator => Some("OrOperator"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for LogicalOperator {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for LogicalOperator {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for LogicalOperator {
        type Output = LogicalOperator;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for LogicalOperator {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = i8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = i8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for LogicalOperator {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for LogicalOperator {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_TIME_UNIT: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_TIME_UNIT: i8 = 9;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_TIME_UNIT: [TimeUnit; 10] = [
        TimeUnit::y,
        TimeUnit::mo,
        TimeUnit::w,
        TimeUnit::d,
        TimeUnit::h,
        TimeUnit::m,
        TimeUnit::s,
        TimeUnit::ms,
        TimeUnit::us,
        TimeUnit::ns,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct TimeUnit(pub i8);
    #[allow(non_upper_case_globals)]
    impl TimeUnit {
        pub const y: Self = Self(0);
        pub const mo: Self = Self(1);
        pub const w: Self = Self(2);
        pub const d: Self = Self(3);
        pub const h: Self = Self(4);
        pub const m: Self = Self(5);
        pub const s: Self = Self(6);
        pub const ms: Self = Self(7);
        pub const us: Self = Self(8);
        pub const ns: Self = Self(9);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 9;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::y,
            Self::mo,
            Self::w,
            Self::d,
            Self::h,
            Self::m,
            Self::s,
            Self::ms,
            Self::us,
            Self::ns,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::y => Some("y"),
                Self::mo => Some("mo"),
                Self::w => Some("w"),
                Self::d => Some("d"),
                Self::h => Some("h"),
                Self::m => Some("m"),
                Self::s => Some("s"),
                Self::ms => Some("ms"),
                Self::us => Some("us"),
                Self::ns => Some("ns"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for TimeUnit {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for TimeUnit {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for TimeUnit {
        type Output = TimeUnit;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for TimeUnit {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = i8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = i8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for TimeUnit {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for TimeUnit {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_EXPRESSION_OR_BLOCK: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_EXPRESSION_OR_BLOCK: u8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_EXPRESSION_OR_BLOCK: [ExpressionOrBlock; 3] = [
        ExpressionOrBlock::NONE,
        ExpressionOrBlock::Block,
        ExpressionOrBlock::WrappedExpression,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ExpressionOrBlock(pub u8);
    #[allow(non_upper_case_globals)]
    impl ExpressionOrBlock {
        pub const NONE: Self = Self(0);
        pub const Block: Self = Self(1);
        pub const WrappedExpression: Self = Self(2);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 2;
        pub const ENUM_VALUES: &'static [Self] =
            &[Self::NONE, Self::Block, Self::WrappedExpression];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::Block => Some("Block"),
                Self::WrappedExpression => Some("WrappedExpression"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for ExpressionOrBlock {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ExpressionOrBlock {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for ExpressionOrBlock {
        type Output = ExpressionOrBlock;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for ExpressionOrBlock {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ExpressionOrBlock {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ExpressionOrBlock {}
    pub struct ExpressionOrBlockUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_PROPERTY_KEY: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_PROPERTY_KEY: u8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_PROPERTY_KEY: [PropertyKey; 3] = [
        PropertyKey::NONE,
        PropertyKey::Identifier,
        PropertyKey::StringLiteral,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct PropertyKey(pub u8);
    #[allow(non_upper_case_globals)]
    impl PropertyKey {
        pub const NONE: Self = Self(0);
        pub const Identifier: Self = Self(1);
        pub const StringLiteral: Self = Self(2);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 2;
        pub const ENUM_VALUES: &'static [Self] =
            &[Self::NONE, Self::Identifier, Self::StringLiteral];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::Identifier => Some("Identifier"),
                Self::StringLiteral => Some("StringLiteral"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for PropertyKey {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for PropertyKey {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for PropertyKey {
        type Output = PropertyKey;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for PropertyKey {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for PropertyKey {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for PropertyKey {}
    pub struct PropertyKeyUnionTableOffset {}

    // struct Position, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Position(pub [u8; 8]);
    impl Default for Position {
        fn default() -> Self {
            Self([0; 8])
        }
    }
    impl std::fmt::Debug for Position {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("Position")
                .field("line", &self.line())
                .field("column", &self.column())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Position {}
    impl flatbuffers::SafeSliceAccess for Position {}
    impl<'a> flatbuffers::Follow<'a> for Position {
        type Inner = &'a Position;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Position>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Position {
        type Inner = &'a Position;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Position>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Position {
        type Output = Position;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(self as *const Position as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }
    impl<'b> flatbuffers::Push for &'b Position {
        type Output = Position;

        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(*self as *const Position as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for Position {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }
    impl<'a> Position {
        #[allow(clippy::too_many_arguments)]
        pub fn new(line: i32, column: i32) -> Self {
            let mut s = Self([0; 8]);
            s.set_line(line);
            s.set_column(column);
            s
        }

        pub fn line(&self) -> i32 {
            let mut mem = core::mem::MaybeUninit::<i32>::uninit();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<i32>(),
                );
                mem.assume_init()
            }
            .from_little_endian()
        }

        pub fn set_line(&mut self, x: i32) {
            let x_le = x.to_little_endian();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const i32 as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<i32>(),
                );
            }
        }

        pub fn column(&self) -> i32 {
            let mut mem = core::mem::MaybeUninit::<i32>::uninit();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<i32>(),
                );
                mem.assume_init()
            }
            .from_little_endian()
        }

        pub fn set_column(&mut self, x: i32) {
            let x_le = x.to_little_endian();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const i32 as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<i32>(),
                );
            }
        }
    }

    pub enum NamedTypeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NamedType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NamedType<'a> {
        type Inner = NamedType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> NamedType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NamedType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args NamedTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<NamedType<'bldr>> {
            let mut builder = NamedTypeBuilder::new(_fbb);
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(NamedType::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn id(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(NamedType::VT_ID, None)
        }
    }

    impl flatbuffers::Verifiable for NamedType<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(&"id", Self::VT_ID, false)?
                .finish();
            Ok(())
        }
    }
    pub struct NamedTypeArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    }
    impl<'a> Default for NamedTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            NamedTypeArgs {
                base_node: None,
                id: None,
            }
        }
    }
    pub struct NamedTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NamedTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    NamedType::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(NamedType::VT_ID, id);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NamedTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            NamedTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NamedType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for NamedType<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("NamedType");
            ds.field("base_node", &self.base_node());
            ds.field("id", &self.id());
            ds.finish()
        }
    }
    pub enum TvarTypeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TvarType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TvarType<'a> {
        type Inner = TvarType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> TvarType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TvarType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TvarTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<TvarType<'bldr>> {
            let mut builder = TvarTypeBuilder::new(_fbb);
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(TvarType::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn id(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(TvarType::VT_ID, None)
        }
    }

    impl flatbuffers::Verifiable for TvarType<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(&"id", Self::VT_ID, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TvarTypeArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    }
    impl<'a> Default for TvarTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            TvarTypeArgs {
                base_node: None,
                id: None,
            }
        }
    }
    pub struct TvarTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TvarTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    TvarType::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(TvarType::VT_ID, id);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TvarTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TvarTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TvarType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for TvarType<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("TvarType");
            ds.field("base_node", &self.base_node());
            ds.field("id", &self.id());
            ds.finish()
        }
    }
    pub enum ArrayTypeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ArrayType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ArrayType<'a> {
        type Inner = ArrayType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ArrayType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ArrayType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ArrayTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<ArrayType<'bldr>> {
            let mut builder = ArrayTypeBuilder::new(_fbb);
            if let Some(x) = args.element {
                builder.add_element(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_element_type(args.element_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ELEMENT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ELEMENT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(ArrayType::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn element_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(ArrayType::VT_ELEMENT_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn element(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ArrayType::VT_ELEMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn element_as_named_type(&self) -> Option<NamedType<'a>> {
            if self.element_type() == MonoType::NamedType {
                self.element().map(NamedType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn element_as_tvar_type(&self) -> Option<TvarType<'a>> {
            if self.element_type() == MonoType::TvarType {
                self.element().map(TvarType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn element_as_array_type(&self) -> Option<ArrayType<'a>> {
            if self.element_type() == MonoType::ArrayType {
                self.element().map(ArrayType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn element_as_dict_type(&self) -> Option<DictType<'a>> {
            if self.element_type() == MonoType::DictType {
                self.element().map(DictType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn element_as_record_type(&self) -> Option<RecordType<'a>> {
            if self.element_type() == MonoType::RecordType {
                self.element().map(RecordType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn element_as_function_type(&self) -> Option<FunctionType<'a>> {
            if self.element_type() == MonoType::FunctionType {
                self.element().map(FunctionType::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ArrayType<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_union::<MonoType, _>(
                    &"element_type",
                    Self::VT_ELEMENT_TYPE,
                    &"element",
                    Self::VT_ELEMENT,
                    false,
                    |key, v, pos| match key {
                        MonoType::NamedType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<NamedType>>(
                                "MonoType::NamedType",
                                pos,
                            ),
                        MonoType::TvarType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<TvarType>>(
                                "MonoType::TvarType",
                                pos,
                            ),
                        MonoType::ArrayType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayType>>(
                                "MonoType::ArrayType",
                                pos,
                            ),
                        MonoType::DictType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<DictType>>(
                                "MonoType::DictType",
                                pos,
                            ),
                        MonoType::RecordType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<RecordType>>(
                                "MonoType::RecordType",
                                pos,
                            ),
                        MonoType::FunctionType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionType>>(
                                "MonoType::FunctionType",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ArrayTypeArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub element_type: MonoType,
        pub element: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ArrayTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            ArrayTypeArgs {
                base_node: None,
                element_type: MonoType::NONE,
                element: None,
            }
        }
    }
    pub struct ArrayTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ArrayTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ArrayType::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_element_type(&mut self, element_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                ArrayType::VT_ELEMENT_TYPE,
                element_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_element(
            &mut self,
            element: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayType::VT_ELEMENT, element);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrayTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ArrayTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ArrayType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ArrayType<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ArrayType");
            ds.field("base_node", &self.base_node());
            ds.field("element_type", &self.element_type());
            match self.element_type() {
                MonoType::NamedType => {
                    if let Some(x) = self.element_as_named_type() {
                        ds.field("element", &x)
                    } else {
                        ds.field(
                            "element",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::TvarType => {
                    if let Some(x) = self.element_as_tvar_type() {
                        ds.field("element", &x)
                    } else {
                        ds.field(
                            "element",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::ArrayType => {
                    if let Some(x) = self.element_as_array_type() {
                        ds.field("element", &x)
                    } else {
                        ds.field(
                            "element",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::DictType => {
                    if let Some(x) = self.element_as_dict_type() {
                        ds.field("element", &x)
                    } else {
                        ds.field(
                            "element",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::RecordType => {
                    if let Some(x) = self.element_as_record_type() {
                        ds.field("element", &x)
                    } else {
                        ds.field(
                            "element",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::FunctionType => {
                    if let Some(x) = self.element_as_function_type() {
                        ds.field("element", &x)
                    } else {
                        ds.field(
                            "element",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("element", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum DictTypeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DictType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DictType<'a> {
        type Inner = DictType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> DictType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DictType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DictTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<DictType<'bldr>> {
            let mut builder = DictTypeBuilder::new(_fbb);
            if let Some(x) = args.val {
                builder.add_val(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_val_type(args.val_type);
            builder.add_key_type(args.key_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_KEY_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_KEY: flatbuffers::VOffsetT = 8;
        pub const VT_VAL_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_VAL: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(DictType::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn key_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(DictType::VT_KEY_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn key(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DictType::VT_KEY, None)
        }
        #[inline]
        pub fn val_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(DictType::VT_VAL_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn val(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DictType::VT_VAL, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_named_type(&self) -> Option<NamedType<'a>> {
            if self.key_type() == MonoType::NamedType {
                self.key().map(NamedType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_tvar_type(&self) -> Option<TvarType<'a>> {
            if self.key_type() == MonoType::TvarType {
                self.key().map(TvarType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_array_type(&self) -> Option<ArrayType<'a>> {
            if self.key_type() == MonoType::ArrayType {
                self.key().map(ArrayType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_dict_type(&self) -> Option<DictType<'a>> {
            if self.key_type() == MonoType::DictType {
                self.key().map(DictType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_record_type(&self) -> Option<RecordType<'a>> {
            if self.key_type() == MonoType::RecordType {
                self.key().map(RecordType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_function_type(&self) -> Option<FunctionType<'a>> {
            if self.key_type() == MonoType::FunctionType {
                self.key().map(FunctionType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_named_type(&self) -> Option<NamedType<'a>> {
            if self.val_type() == MonoType::NamedType {
                self.val().map(NamedType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_tvar_type(&self) -> Option<TvarType<'a>> {
            if self.val_type() == MonoType::TvarType {
                self.val().map(TvarType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_array_type(&self) -> Option<ArrayType<'a>> {
            if self.val_type() == MonoType::ArrayType {
                self.val().map(ArrayType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_dict_type(&self) -> Option<DictType<'a>> {
            if self.val_type() == MonoType::DictType {
                self.val().map(DictType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_record_type(&self) -> Option<RecordType<'a>> {
            if self.val_type() == MonoType::RecordType {
                self.val().map(RecordType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_function_type(&self) -> Option<FunctionType<'a>> {
            if self.val_type() == MonoType::FunctionType {
                self.val().map(FunctionType::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for DictType<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_union::<MonoType, _>(
                    &"key_type",
                    Self::VT_KEY_TYPE,
                    &"key",
                    Self::VT_KEY,
                    false,
                    |key, v, pos| match key {
                        MonoType::NamedType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<NamedType>>(
                                "MonoType::NamedType",
                                pos,
                            ),
                        MonoType::TvarType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<TvarType>>(
                                "MonoType::TvarType",
                                pos,
                            ),
                        MonoType::ArrayType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayType>>(
                                "MonoType::ArrayType",
                                pos,
                            ),
                        MonoType::DictType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<DictType>>(
                                "MonoType::DictType",
                                pos,
                            ),
                        MonoType::RecordType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<RecordType>>(
                                "MonoType::RecordType",
                                pos,
                            ),
                        MonoType::FunctionType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionType>>(
                                "MonoType::FunctionType",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .visit_union::<MonoType, _>(
                    &"val_type",
                    Self::VT_VAL_TYPE,
                    &"val",
                    Self::VT_VAL,
                    false,
                    |key, v, pos| match key {
                        MonoType::NamedType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<NamedType>>(
                                "MonoType::NamedType",
                                pos,
                            ),
                        MonoType::TvarType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<TvarType>>(
                                "MonoType::TvarType",
                                pos,
                            ),
                        MonoType::ArrayType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayType>>(
                                "MonoType::ArrayType",
                                pos,
                            ),
                        MonoType::DictType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<DictType>>(
                                "MonoType::DictType",
                                pos,
                            ),
                        MonoType::RecordType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<RecordType>>(
                                "MonoType::RecordType",
                                pos,
                            ),
                        MonoType::FunctionType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionType>>(
                                "MonoType::FunctionType",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct DictTypeArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub key_type: MonoType,
        pub key: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub val_type: MonoType,
        pub val: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for DictTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            DictTypeArgs {
                base_node: None,
                key_type: MonoType::NONE,
                key: None,
                val_type: MonoType::NONE,
                val: None,
            }
        }
    }
    pub struct DictTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DictTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    DictType::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_key_type(&mut self, key_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(DictType::VT_KEY_TYPE, key_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DictType::VT_KEY, key);
        }
        #[inline]
        pub fn add_val_type(&mut self, val_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(DictType::VT_VAL_TYPE, val_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_val(&mut self, val: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DictType::VT_VAL, val);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DictTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DictTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DictType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for DictType<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("DictType");
            ds.field("base_node", &self.base_node());
            ds.field("key_type", &self.key_type());
            match self.key_type() {
                MonoType::NamedType => {
                    if let Some(x) = self.key_as_named_type() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::TvarType => {
                    if let Some(x) = self.key_as_tvar_type() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::ArrayType => {
                    if let Some(x) = self.key_as_array_type() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::DictType => {
                    if let Some(x) = self.key_as_dict_type() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::RecordType => {
                    if let Some(x) = self.key_as_record_type() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::FunctionType => {
                    if let Some(x) = self.key_as_function_type() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("key", &x)
                }
            };
            ds.field("val_type", &self.val_type());
            match self.val_type() {
                MonoType::NamedType => {
                    if let Some(x) = self.val_as_named_type() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::TvarType => {
                    if let Some(x) = self.val_as_tvar_type() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::ArrayType => {
                    if let Some(x) = self.val_as_array_type() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::DictType => {
                    if let Some(x) = self.val_as_dict_type() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::RecordType => {
                    if let Some(x) = self.val_as_record_type() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::FunctionType => {
                    if let Some(x) = self.val_as_function_type() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("val", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum PropertyTypeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PropertyType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PropertyType<'a> {
        type Inner = PropertyType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> PropertyType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PropertyType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PropertyTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<PropertyType<'bldr>> {
            let mut builder = PropertyTypeBuilder::new(_fbb);
            if let Some(x) = args.monotype {
                builder.add_monotype(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_monotype_type(args.monotype_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;
        pub const VT_MONOTYPE_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_MONOTYPE: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(PropertyType::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn id(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(PropertyType::VT_ID, None)
        }
        #[inline]
        pub fn monotype_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(PropertyType::VT_MONOTYPE_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn monotype(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    PropertyType::VT_MONOTYPE,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_named_type(&self) -> Option<NamedType<'a>> {
            if self.monotype_type() == MonoType::NamedType {
                self.monotype().map(NamedType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_tvar_type(&self) -> Option<TvarType<'a>> {
            if self.monotype_type() == MonoType::TvarType {
                self.monotype().map(TvarType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_array_type(&self) -> Option<ArrayType<'a>> {
            if self.monotype_type() == MonoType::ArrayType {
                self.monotype().map(ArrayType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_dict_type(&self) -> Option<DictType<'a>> {
            if self.monotype_type() == MonoType::DictType {
                self.monotype().map(DictType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_record_type(&self) -> Option<RecordType<'a>> {
            if self.monotype_type() == MonoType::RecordType {
                self.monotype().map(RecordType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_function_type(&self) -> Option<FunctionType<'a>> {
            if self.monotype_type() == MonoType::FunctionType {
                self.monotype().map(FunctionType::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for PropertyType<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(&"id", Self::VT_ID, false)?
                .visit_union::<MonoType, _>(
                    &"monotype_type",
                    Self::VT_MONOTYPE_TYPE,
                    &"monotype",
                    Self::VT_MONOTYPE,
                    false,
                    |key, v, pos| match key {
                        MonoType::NamedType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<NamedType>>(
                                "MonoType::NamedType",
                                pos,
                            ),
                        MonoType::TvarType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<TvarType>>(
                                "MonoType::TvarType",
                                pos,
                            ),
                        MonoType::ArrayType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayType>>(
                                "MonoType::ArrayType",
                                pos,
                            ),
                        MonoType::DictType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<DictType>>(
                                "MonoType::DictType",
                                pos,
                            ),
                        MonoType::RecordType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<RecordType>>(
                                "MonoType::RecordType",
                                pos,
                            ),
                        MonoType::FunctionType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionType>>(
                                "MonoType::FunctionType",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PropertyTypeArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub monotype_type: MonoType,
        pub monotype: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for PropertyTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            PropertyTypeArgs {
                base_node: None,
                id: None,
                monotype_type: MonoType::NONE,
                monotype: None,
            }
        }
    }
    pub struct PropertyTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PropertyTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    PropertyType::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(PropertyType::VT_ID, id);
        }
        #[inline]
        pub fn add_monotype_type(&mut self, monotype_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                PropertyType::VT_MONOTYPE_TYPE,
                monotype_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_monotype(
            &mut self,
            monotype: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PropertyType::VT_MONOTYPE, monotype);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> PropertyTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PropertyTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PropertyType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for PropertyType<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("PropertyType");
            ds.field("base_node", &self.base_node());
            ds.field("id", &self.id());
            ds.field("monotype_type", &self.monotype_type());
            match self.monotype_type() {
                MonoType::NamedType => {
                    if let Some(x) = self.monotype_as_named_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::TvarType => {
                    if let Some(x) = self.monotype_as_tvar_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::ArrayType => {
                    if let Some(x) = self.monotype_as_array_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::DictType => {
                    if let Some(x) = self.monotype_as_dict_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::RecordType => {
                    if let Some(x) = self.monotype_as_record_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::FunctionType => {
                    if let Some(x) = self.monotype_as_function_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("monotype", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum RecordTypeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RecordType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RecordType<'a> {
        type Inner = RecordType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> RecordType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RecordType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RecordTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<RecordType<'bldr>> {
            let mut builder = RecordTypeBuilder::new(_fbb);
            if let Some(x) = args.tvar {
                builder.add_tvar(x);
            }
            if let Some(x) = args.properties {
                builder.add_properties(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_PROPERTIES: flatbuffers::VOffsetT = 6;
        pub const VT_TVAR: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(RecordType::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn properties(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PropertyType<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PropertyType>>,
            >>(RecordType::VT_PROPERTIES, None)
        }
        #[inline]
        pub fn tvar(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(RecordType::VT_TVAR, None)
        }
    }

    impl flatbuffers::Verifiable for RecordType<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PropertyType>>,
                >>(&"properties", Self::VT_PROPERTIES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(
                    &"tvar",
                    Self::VT_TVAR,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct RecordTypeArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub properties: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PropertyType<'a>>>,
            >,
        >,
        pub tvar: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    }
    impl<'a> Default for RecordTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            RecordTypeArgs {
                base_node: None,
                properties: None,
                tvar: None,
            }
        }
    }
    pub struct RecordTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RecordTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    RecordType::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_properties(
            &mut self,
            properties: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PropertyType<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                RecordType::VT_PROPERTIES,
                properties,
            );
        }
        #[inline]
        pub fn add_tvar(&mut self, tvar: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(RecordType::VT_TVAR, tvar);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RecordTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RecordTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RecordType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for RecordType<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("RecordType");
            ds.field("base_node", &self.base_node());
            ds.field("properties", &self.properties());
            ds.field("tvar", &self.tvar());
            ds.finish()
        }
    }
    pub enum ParameterTypeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ParameterType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ParameterType<'a> {
        type Inner = ParameterType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ParameterType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ParameterType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ParameterTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<ParameterType<'bldr>> {
            let mut builder = ParameterTypeBuilder::new(_fbb);
            if let Some(x) = args.monotype {
                builder.add_monotype(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_kind(args.kind);
            builder.add_monotype_type(args.monotype_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;
        pub const VT_MONOTYPE_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_MONOTYPE: flatbuffers::VOffsetT = 10;
        pub const VT_KIND: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(ParameterType::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn id(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(ParameterType::VT_ID, None)
        }
        #[inline]
        pub fn monotype_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(ParameterType::VT_MONOTYPE_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn monotype(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ParameterType::VT_MONOTYPE,
                    None,
                )
        }
        #[inline]
        pub fn kind(&self) -> ParameterKind {
            self._tab
                .get::<ParameterKind>(ParameterType::VT_KIND, Some(ParameterKind::Required))
                .unwrap()
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_named_type(&self) -> Option<NamedType<'a>> {
            if self.monotype_type() == MonoType::NamedType {
                self.monotype().map(NamedType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_tvar_type(&self) -> Option<TvarType<'a>> {
            if self.monotype_type() == MonoType::TvarType {
                self.monotype().map(TvarType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_array_type(&self) -> Option<ArrayType<'a>> {
            if self.monotype_type() == MonoType::ArrayType {
                self.monotype().map(ArrayType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_dict_type(&self) -> Option<DictType<'a>> {
            if self.monotype_type() == MonoType::DictType {
                self.monotype().map(DictType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_record_type(&self) -> Option<RecordType<'a>> {
            if self.monotype_type() == MonoType::RecordType {
                self.monotype().map(RecordType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_function_type(&self) -> Option<FunctionType<'a>> {
            if self.monotype_type() == MonoType::FunctionType {
                self.monotype().map(FunctionType::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ParameterType<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(&"id", Self::VT_ID, false)?
                .visit_union::<MonoType, _>(
                    &"monotype_type",
                    Self::VT_MONOTYPE_TYPE,
                    &"monotype",
                    Self::VT_MONOTYPE,
                    false,
                    |key, v, pos| match key {
                        MonoType::NamedType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<NamedType>>(
                                "MonoType::NamedType",
                                pos,
                            ),
                        MonoType::TvarType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<TvarType>>(
                                "MonoType::TvarType",
                                pos,
                            ),
                        MonoType::ArrayType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayType>>(
                                "MonoType::ArrayType",
                                pos,
                            ),
                        MonoType::DictType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<DictType>>(
                                "MonoType::DictType",
                                pos,
                            ),
                        MonoType::RecordType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<RecordType>>(
                                "MonoType::RecordType",
                                pos,
                            ),
                        MonoType::FunctionType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionType>>(
                                "MonoType::FunctionType",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .visit_field::<ParameterKind>(&"kind", Self::VT_KIND, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ParameterTypeArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub monotype_type: MonoType,
        pub monotype: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub kind: ParameterKind,
    }
    impl<'a> Default for ParameterTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            ParameterTypeArgs {
                base_node: None,
                id: None,
                monotype_type: MonoType::NONE,
                monotype: None,
                kind: ParameterKind::Required,
            }
        }
    }
    pub struct ParameterTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ParameterTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ParameterType::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(ParameterType::VT_ID, id);
        }
        #[inline]
        pub fn add_monotype_type(&mut self, monotype_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                ParameterType::VT_MONOTYPE_TYPE,
                monotype_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_monotype(
            &mut self,
            monotype: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ParameterType::VT_MONOTYPE,
                monotype,
            );
        }
        #[inline]
        pub fn add_kind(&mut self, kind: ParameterKind) {
            self.fbb_.push_slot::<ParameterKind>(
                ParameterType::VT_KIND,
                kind,
                ParameterKind::Required,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ParameterTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ParameterTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ParameterType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ParameterType<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ParameterType");
            ds.field("base_node", &self.base_node());
            ds.field("id", &self.id());
            ds.field("monotype_type", &self.monotype_type());
            match self.monotype_type() {
                MonoType::NamedType => {
                    if let Some(x) = self.monotype_as_named_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::TvarType => {
                    if let Some(x) = self.monotype_as_tvar_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::ArrayType => {
                    if let Some(x) = self.monotype_as_array_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::DictType => {
                    if let Some(x) = self.monotype_as_dict_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::RecordType => {
                    if let Some(x) = self.monotype_as_record_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::FunctionType => {
                    if let Some(x) = self.monotype_as_function_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("monotype", &x)
                }
            };
            ds.field("kind", &self.kind());
            ds.finish()
        }
    }
    pub enum FunctionTypeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FunctionType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FunctionType<'a> {
        type Inner = FunctionType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> FunctionType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FunctionType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FunctionTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<FunctionType<'bldr>> {
            let mut builder = FunctionTypeBuilder::new(_fbb);
            if let Some(x) = args.monotype {
                builder.add_monotype(x);
            }
            if let Some(x) = args.parameters {
                builder.add_parameters(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_monotype_type(args.monotype_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_PARAMETERS: flatbuffers::VOffsetT = 6;
        pub const VT_MONOTYPE_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_MONOTYPE: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(FunctionType::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn parameters(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParameterType<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParameterType>>,
            >>(FunctionType::VT_PARAMETERS, None)
        }
        #[inline]
        pub fn monotype_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(FunctionType::VT_MONOTYPE_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn monotype(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    FunctionType::VT_MONOTYPE,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_named_type(&self) -> Option<NamedType<'a>> {
            if self.monotype_type() == MonoType::NamedType {
                self.monotype().map(NamedType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_tvar_type(&self) -> Option<TvarType<'a>> {
            if self.monotype_type() == MonoType::TvarType {
                self.monotype().map(TvarType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_array_type(&self) -> Option<ArrayType<'a>> {
            if self.monotype_type() == MonoType::ArrayType {
                self.monotype().map(ArrayType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_dict_type(&self) -> Option<DictType<'a>> {
            if self.monotype_type() == MonoType::DictType {
                self.monotype().map(DictType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_record_type(&self) -> Option<RecordType<'a>> {
            if self.monotype_type() == MonoType::RecordType {
                self.monotype().map(RecordType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_function_type(&self) -> Option<FunctionType<'a>> {
            if self.monotype_type() == MonoType::FunctionType {
                self.monotype().map(FunctionType::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for FunctionType<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ParameterType>>,
                >>(&"parameters", Self::VT_PARAMETERS, false)?
                .visit_union::<MonoType, _>(
                    &"monotype_type",
                    Self::VT_MONOTYPE_TYPE,
                    &"monotype",
                    Self::VT_MONOTYPE,
                    false,
                    |key, v, pos| match key {
                        MonoType::NamedType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<NamedType>>(
                                "MonoType::NamedType",
                                pos,
                            ),
                        MonoType::TvarType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<TvarType>>(
                                "MonoType::TvarType",
                                pos,
                            ),
                        MonoType::ArrayType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayType>>(
                                "MonoType::ArrayType",
                                pos,
                            ),
                        MonoType::DictType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<DictType>>(
                                "MonoType::DictType",
                                pos,
                            ),
                        MonoType::RecordType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<RecordType>>(
                                "MonoType::RecordType",
                                pos,
                            ),
                        MonoType::FunctionType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionType>>(
                                "MonoType::FunctionType",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct FunctionTypeArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub parameters: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParameterType<'a>>>,
            >,
        >,
        pub monotype_type: MonoType,
        pub monotype: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for FunctionTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            FunctionTypeArgs {
                base_node: None,
                parameters: None,
                monotype_type: MonoType::NONE,
                monotype: None,
            }
        }
    }
    pub struct FunctionTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FunctionTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    FunctionType::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_parameters(
            &mut self,
            parameters: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ParameterType<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                FunctionType::VT_PARAMETERS,
                parameters,
            );
        }
        #[inline]
        pub fn add_monotype_type(&mut self, monotype_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                FunctionType::VT_MONOTYPE_TYPE,
                monotype_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_monotype(
            &mut self,
            monotype: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionType::VT_MONOTYPE, monotype);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FunctionTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FunctionTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FunctionType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for FunctionType<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("FunctionType");
            ds.field("base_node", &self.base_node());
            ds.field("parameters", &self.parameters());
            ds.field("monotype_type", &self.monotype_type());
            match self.monotype_type() {
                MonoType::NamedType => {
                    if let Some(x) = self.monotype_as_named_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::TvarType => {
                    if let Some(x) = self.monotype_as_tvar_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::ArrayType => {
                    if let Some(x) = self.monotype_as_array_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::DictType => {
                    if let Some(x) = self.monotype_as_dict_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::RecordType => {
                    if let Some(x) = self.monotype_as_record_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::FunctionType => {
                    if let Some(x) = self.monotype_as_function_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("monotype", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum TypeConstraintOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TypeConstraint<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TypeConstraint<'a> {
        type Inner = TypeConstraint<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> TypeConstraint<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TypeConstraint { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TypeConstraintArgs<'args>,
        ) -> flatbuffers::WIPOffset<TypeConstraint<'bldr>> {
            let mut builder = TypeConstraintBuilder::new(_fbb);
            if let Some(x) = args.kinds {
                builder.add_kinds(x);
            }
            if let Some(x) = args.tvar {
                builder.add_tvar(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_TVAR: flatbuffers::VOffsetT = 6;
        pub const VT_KINDS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(TypeConstraint::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn tvar(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(TypeConstraint::VT_TVAR, None)
        }
        #[inline]
        pub fn kinds(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Identifier<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Identifier>>,
            >>(TypeConstraint::VT_KINDS, None)
        }
    }

    impl flatbuffers::Verifiable for TypeConstraint<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(
                    &"tvar",
                    Self::VT_TVAR,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Identifier>>,
                >>(&"kinds", Self::VT_KINDS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TypeConstraintArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub tvar: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub kinds: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Identifier<'a>>>,
            >,
        >,
    }
    impl<'a> Default for TypeConstraintArgs<'a> {
        #[inline]
        fn default() -> Self {
            TypeConstraintArgs {
                base_node: None,
                tvar: None,
                kinds: None,
            }
        }
    }
    pub struct TypeConstraintBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TypeConstraintBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    TypeConstraint::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_tvar(&mut self, tvar: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    TypeConstraint::VT_TVAR,
                    tvar,
                );
        }
        #[inline]
        pub fn add_kinds(
            &mut self,
            kinds: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Identifier<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TypeConstraint::VT_KINDS, kinds);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TypeConstraintBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TypeConstraintBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TypeConstraint<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for TypeConstraint<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("TypeConstraint");
            ds.field("base_node", &self.base_node());
            ds.field("tvar", &self.tvar());
            ds.field("kinds", &self.kinds());
            ds.finish()
        }
    }
    pub enum TypeExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TypeExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TypeExpression<'a> {
        type Inner = TypeExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> TypeExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TypeExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TypeExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<TypeExpression<'bldr>> {
            let mut builder = TypeExpressionBuilder::new(_fbb);
            if let Some(x) = args.constraints {
                builder.add_constraints(x);
            }
            if let Some(x) = args.monotype {
                builder.add_monotype(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_monotype_type(args.monotype_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_MONOTYPE_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_MONOTYPE: flatbuffers::VOffsetT = 8;
        pub const VT_CONSTRAINTS: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(TypeExpression::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn monotype_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(TypeExpression::VT_MONOTYPE_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn monotype(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    TypeExpression::VT_MONOTYPE,
                    None,
                )
        }
        #[inline]
        pub fn constraints(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TypeConstraint<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TypeConstraint>>,
            >>(TypeExpression::VT_CONSTRAINTS, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_named_type(&self) -> Option<NamedType<'a>> {
            if self.monotype_type() == MonoType::NamedType {
                self.monotype().map(NamedType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_tvar_type(&self) -> Option<TvarType<'a>> {
            if self.monotype_type() == MonoType::TvarType {
                self.monotype().map(TvarType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_array_type(&self) -> Option<ArrayType<'a>> {
            if self.monotype_type() == MonoType::ArrayType {
                self.monotype().map(ArrayType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_dict_type(&self) -> Option<DictType<'a>> {
            if self.monotype_type() == MonoType::DictType {
                self.monotype().map(DictType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_record_type(&self) -> Option<RecordType<'a>> {
            if self.monotype_type() == MonoType::RecordType {
                self.monotype().map(RecordType::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_function_type(&self) -> Option<FunctionType<'a>> {
            if self.monotype_type() == MonoType::FunctionType {
                self.monotype().map(FunctionType::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for TypeExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_union::<MonoType, _>(
                    &"monotype_type",
                    Self::VT_MONOTYPE_TYPE,
                    &"monotype",
                    Self::VT_MONOTYPE,
                    false,
                    |key, v, pos| match key {
                        MonoType::NamedType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<NamedType>>(
                                "MonoType::NamedType",
                                pos,
                            ),
                        MonoType::TvarType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<TvarType>>(
                                "MonoType::TvarType",
                                pos,
                            ),
                        MonoType::ArrayType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayType>>(
                                "MonoType::ArrayType",
                                pos,
                            ),
                        MonoType::DictType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<DictType>>(
                                "MonoType::DictType",
                                pos,
                            ),
                        MonoType::RecordType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<RecordType>>(
                                "MonoType::RecordType",
                                pos,
                            ),
                        MonoType::FunctionType => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionType>>(
                                "MonoType::FunctionType",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TypeConstraint>>,
                >>(&"constraints", Self::VT_CONSTRAINTS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TypeExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub monotype_type: MonoType,
        pub monotype: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub constraints: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TypeConstraint<'a>>>,
            >,
        >,
    }
    impl<'a> Default for TypeExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            TypeExpressionArgs {
                base_node: None,
                monotype_type: MonoType::NONE,
                monotype: None,
                constraints: None,
            }
        }
    }
    pub struct TypeExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TypeExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    TypeExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_monotype_type(&mut self, monotype_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                TypeExpression::VT_MONOTYPE_TYPE,
                monotype_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_monotype(
            &mut self,
            monotype: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TypeExpression::VT_MONOTYPE,
                monotype,
            );
        }
        #[inline]
        pub fn add_constraints(
            &mut self,
            constraints: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TypeConstraint<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TypeExpression::VT_CONSTRAINTS,
                constraints,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TypeExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TypeExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TypeExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for TypeExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("TypeExpression");
            ds.field("base_node", &self.base_node());
            ds.field("monotype_type", &self.monotype_type());
            match self.monotype_type() {
                MonoType::NamedType => {
                    if let Some(x) = self.monotype_as_named_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::TvarType => {
                    if let Some(x) = self.monotype_as_tvar_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::ArrayType => {
                    if let Some(x) = self.monotype_as_array_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::DictType => {
                    if let Some(x) = self.monotype_as_dict_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::RecordType => {
                    if let Some(x) = self.monotype_as_record_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MonoType::FunctionType => {
                    if let Some(x) = self.monotype_as_function_type() {
                        ds.field("monotype", &x)
                    } else {
                        ds.field(
                            "monotype",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("monotype", &x)
                }
            };
            ds.field("constraints", &self.constraints());
            ds.finish()
        }
    }
    pub enum SourceLocationOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SourceLocation<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SourceLocation<'a> {
        type Inner = SourceLocation<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> SourceLocation<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SourceLocation { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SourceLocationArgs<'args>,
        ) -> flatbuffers::WIPOffset<SourceLocation<'bldr>> {
            let mut builder = SourceLocationBuilder::new(_fbb);
            if let Some(x) = args.source {
                builder.add_source(x);
            }
            if let Some(x) = args.end {
                builder.add_end(x);
            }
            if let Some(x) = args.start {
                builder.add_start(x);
            }
            if let Some(x) = args.file {
                builder.add_file(x);
            }
            builder.finish()
        }

        pub const VT_FILE: flatbuffers::VOffsetT = 4;
        pub const VT_START: flatbuffers::VOffsetT = 6;
        pub const VT_END: flatbuffers::VOffsetT = 8;
        pub const VT_SOURCE: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn file(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SourceLocation::VT_FILE, None)
        }
        #[inline]
        pub fn start(&self) -> Option<&'a Position> {
            self._tab.get::<Position>(SourceLocation::VT_START, None)
        }
        #[inline]
        pub fn end(&self) -> Option<&'a Position> {
            self._tab.get::<Position>(SourceLocation::VT_END, None)
        }
        #[inline]
        pub fn source(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SourceLocation::VT_SOURCE, None)
        }
    }

    impl flatbuffers::Verifiable for SourceLocation<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"file", Self::VT_FILE, false)?
                .visit_field::<Position>(&"start", Self::VT_START, false)?
                .visit_field::<Position>(&"end", Self::VT_END, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    &"source",
                    Self::VT_SOURCE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct SourceLocationArgs<'a> {
        pub file: Option<flatbuffers::WIPOffset<&'a str>>,
        pub start: Option<&'a Position>,
        pub end: Option<&'a Position>,
        pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for SourceLocationArgs<'a> {
        #[inline]
        fn default() -> Self {
            SourceLocationArgs {
                file: None,
                start: None,
                end: None,
                source: None,
            }
        }
    }
    pub struct SourceLocationBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SourceLocationBuilder<'a, 'b> {
        #[inline]
        pub fn add_file(&mut self, file: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SourceLocation::VT_FILE, file);
        }
        #[inline]
        pub fn add_start(&mut self, start: &Position) {
            self.fbb_
                .push_slot_always::<&Position>(SourceLocation::VT_START, start);
        }
        #[inline]
        pub fn add_end(&mut self, end: &Position) {
            self.fbb_
                .push_slot_always::<&Position>(SourceLocation::VT_END, end);
        }
        #[inline]
        pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SourceLocation::VT_SOURCE, source);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SourceLocationBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SourceLocationBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SourceLocation<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for SourceLocation<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("SourceLocation");
            ds.field("file", &self.file());
            ds.field("start", &self.start());
            ds.field("end", &self.end());
            ds.field("source", &self.source());
            ds.finish()
        }
    }
    pub enum CommentOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Comment<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Comment<'a> {
        type Inner = Comment<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Comment<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Comment { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CommentArgs<'args>,
        ) -> flatbuffers::WIPOffset<Comment<'bldr>> {
            let mut builder = CommentBuilder::new(_fbb);
            if let Some(x) = args.text {
                builder.add_text(x);
            }
            builder.finish()
        }

        pub const VT_TEXT: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn text(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Comment::VT_TEXT, None)
        }
    }

    impl flatbuffers::Verifiable for Comment<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"text", Self::VT_TEXT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct CommentArgs<'a> {
        pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for CommentArgs<'a> {
        #[inline]
        fn default() -> Self {
            CommentArgs { text: None }
        }
    }
    pub struct CommentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CommentBuilder<'a, 'b> {
        #[inline]
        pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Comment::VT_TEXT, text);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CommentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CommentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Comment<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Comment<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Comment");
            ds.field("text", &self.text());
            ds.finish()
        }
    }
    pub enum BaseNodeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BaseNode<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BaseNode<'a> {
        type Inner = BaseNode<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> BaseNode<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BaseNode { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BaseNodeArgs<'args>,
        ) -> flatbuffers::WIPOffset<BaseNode<'bldr>> {
            let mut builder = BaseNodeBuilder::new(_fbb);
            if let Some(x) = args.comments {
                builder.add_comments(x);
            }
            if let Some(x) = args.errors {
                builder.add_errors(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ERRORS: flatbuffers::VOffsetT = 6;
        pub const VT_COMMENTS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation>>(BaseNode::VT_LOC, None)
        }
        #[inline]
        pub fn errors(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(BaseNode::VT_ERRORS, None)
        }
        #[inline]
        pub fn comments(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Comment<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Comment>>,
            >>(BaseNode::VT_COMMENTS, None)
        }
    }

    impl flatbuffers::Verifiable for BaseNode<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<SourceLocation>>(
                    &"loc",
                    Self::VT_LOC,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>(&"errors", Self::VT_ERRORS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Comment>>,
                >>(&"comments", Self::VT_COMMENTS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BaseNodeArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub errors: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub comments: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Comment<'a>>>,
            >,
        >,
    }
    impl<'a> Default for BaseNodeArgs<'a> {
        #[inline]
        fn default() -> Self {
            BaseNodeArgs {
                loc: None,
                errors: None,
                comments: None,
            }
        }
    }
    pub struct BaseNodeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BaseNodeBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(BaseNode::VT_LOC, loc);
        }
        #[inline]
        pub fn add_errors(
            &mut self,
            errors: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BaseNode::VT_ERRORS, errors);
        }
        #[inline]
        pub fn add_comments(
            &mut self,
            comments: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Comment<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BaseNode::VT_COMMENTS, comments);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BaseNodeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BaseNodeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BaseNode<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for BaseNode<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("BaseNode");
            ds.field("loc", &self.loc());
            ds.field("errors", &self.errors());
            ds.field("comments", &self.comments());
            ds.finish()
        }
    }
    pub enum PackageOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Package<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Package<'a> {
        type Inner = Package<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Package<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Package { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PackageArgs<'args>,
        ) -> flatbuffers::WIPOffset<Package<'bldr>> {
            let mut builder = PackageBuilder::new(_fbb);
            if let Some(x) = args.files {
                builder.add_files(x);
            }
            if let Some(x) = args.package {
                builder.add_package(x);
            }
            if let Some(x) = args.path {
                builder.add_path(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_PATH: flatbuffers::VOffsetT = 6;
        pub const VT_PACKAGE: flatbuffers::VOffsetT = 8;
        pub const VT_FILES: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(Package::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn path(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Package::VT_PATH, None)
        }
        #[inline]
        pub fn package(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Package::VT_PACKAGE, None)
        }
        #[inline]
        pub fn files(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File>>,
            >>(Package::VT_FILES, None)
        }
    }

    impl flatbuffers::Verifiable for Package<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"path", Self::VT_PATH, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    &"package",
                    Self::VT_PACKAGE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<File>>,
                >>(&"files", Self::VT_FILES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PackageArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub path: Option<flatbuffers::WIPOffset<&'a str>>,
        pub package: Option<flatbuffers::WIPOffset<&'a str>>,
        pub files: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File<'a>>>>,
        >,
    }
    impl<'a> Default for PackageArgs<'a> {
        #[inline]
        fn default() -> Self {
            PackageArgs {
                base_node: None,
                path: None,
                package: None,
                files: None,
            }
        }
    }
    pub struct PackageBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PackageBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    Package::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_PATH, path);
        }
        #[inline]
        pub fn add_package(&mut self, package: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_PACKAGE, package);
        }
        #[inline]
        pub fn add_files(
            &mut self,
            files: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<File<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_FILES, files);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PackageBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PackageBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Package<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Package<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Package");
            ds.field("base_node", &self.base_node());
            ds.field("path", &self.path());
            ds.field("package", &self.package());
            ds.field("files", &self.files());
            ds.finish()
        }
    }
    pub enum FileOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct File<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for File<'a> {
        type Inner = File<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> File<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            File { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FileArgs<'args>,
        ) -> flatbuffers::WIPOffset<File<'bldr>> {
            let mut builder = FileBuilder::new(_fbb);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.imports {
                builder.add_imports(x);
            }
            if let Some(x) = args.package {
                builder.add_package(x);
            }
            if let Some(x) = args.metadata {
                builder.add_metadata(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;
        pub const VT_METADATA: flatbuffers::VOffsetT = 8;
        pub const VT_PACKAGE: flatbuffers::VOffsetT = 10;
        pub const VT_IMPORTS: flatbuffers::VOffsetT = 12;
        pub const VT_BODY: flatbuffers::VOffsetT = 14;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(File::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(File::VT_NAME, None)
        }
        #[inline]
        pub fn metadata(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(File::VT_METADATA, None)
        }
        #[inline]
        pub fn package(&self) -> Option<PackageClause<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<PackageClause>>(File::VT_PACKAGE, None)
        }
        #[inline]
        pub fn imports(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ImportDeclaration<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ImportDeclaration>>,
            >>(File::VT_IMPORTS, None)
        }
        #[inline]
        pub fn body(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement>>,
            >>(File::VT_BODY, None)
        }
    }

    impl flatbuffers::Verifiable for File<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    &"metadata",
                    Self::VT_METADATA,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<PackageClause>>(
                    &"package",
                    Self::VT_PACKAGE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ImportDeclaration>>,
                >>(&"imports", Self::VT_IMPORTS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WrappedStatement>>,
                >>(&"body", Self::VT_BODY, false)?
                .finish();
            Ok(())
        }
    }
    pub struct FileArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub metadata: Option<flatbuffers::WIPOffset<&'a str>>,
        pub package: Option<flatbuffers::WIPOffset<PackageClause<'a>>>,
        pub imports: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ImportDeclaration<'a>>>,
            >,
        >,
        pub body: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>,
            >,
        >,
    }
    impl<'a> Default for FileArgs<'a> {
        #[inline]
        fn default() -> Self {
            FileArgs {
                base_node: None,
                name: None,
                metadata: None,
                package: None,
                imports: None,
                body: None,
            }
        }
    }
    pub struct FileBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FileBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    File::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_NAME, name);
        }
        #[inline]
        pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_METADATA, metadata);
        }
        #[inline]
        pub fn add_package(&mut self, package: flatbuffers::WIPOffset<PackageClause<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<PackageClause>>(
                    File::VT_PACKAGE,
                    package,
                );
        }
        #[inline]
        pub fn add_imports(
            &mut self,
            imports: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ImportDeclaration<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_IMPORTS, imports);
        }
        #[inline]
        pub fn add_body(
            &mut self,
            body: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<WrappedStatement<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_BODY, body);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FileBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FileBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<File<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for File<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("File");
            ds.field("base_node", &self.base_node());
            ds.field("name", &self.name());
            ds.field("metadata", &self.metadata());
            ds.field("package", &self.package());
            ds.field("imports", &self.imports());
            ds.field("body", &self.body());
            ds.finish()
        }
    }
    pub enum PackageClauseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PackageClause<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PackageClause<'a> {
        type Inner = PackageClause<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> PackageClause<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PackageClause { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PackageClauseArgs<'args>,
        ) -> flatbuffers::WIPOffset<PackageClause<'bldr>> {
            let mut builder = PackageClauseBuilder::new(_fbb);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(PackageClause::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn name(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(PackageClause::VT_NAME, None)
        }
    }

    impl flatbuffers::Verifiable for PackageClause<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(
                    &"name",
                    Self::VT_NAME,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PackageClauseArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub name: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    }
    impl<'a> Default for PackageClauseArgs<'a> {
        #[inline]
        fn default() -> Self {
            PackageClauseArgs {
                base_node: None,
                name: None,
            }
        }
    }
    pub struct PackageClauseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PackageClauseBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    PackageClause::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    PackageClause::VT_NAME,
                    name,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> PackageClauseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PackageClauseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PackageClause<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for PackageClause<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("PackageClause");
            ds.field("base_node", &self.base_node());
            ds.field("name", &self.name());
            ds.finish()
        }
    }
    pub enum ImportDeclarationOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ImportDeclaration<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ImportDeclaration<'a> {
        type Inner = ImportDeclaration<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ImportDeclaration<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ImportDeclaration { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ImportDeclarationArgs<'args>,
        ) -> flatbuffers::WIPOffset<ImportDeclaration<'bldr>> {
            let mut builder = ImportDeclarationBuilder::new(_fbb);
            if let Some(x) = args.path {
                builder.add_path(x);
            }
            if let Some(x) = args.as_ {
                builder.add_as_(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_AS_: flatbuffers::VOffsetT = 6;
        pub const VT_PATH: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode>>(
                ImportDeclaration::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn as_(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(ImportDeclaration::VT_AS_, None)
        }
        #[inline]
        pub fn path(&self) -> Option<StringLiteral<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<StringLiteral>>(
                    ImportDeclaration::VT_PATH,
                    None,
                )
        }
    }

    impl flatbuffers::Verifiable for ImportDeclaration<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(
                    &"as_",
                    Self::VT_AS_,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<StringLiteral>>(
                    &"path",
                    Self::VT_PATH,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ImportDeclarationArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub as_: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub path: Option<flatbuffers::WIPOffset<StringLiteral<'a>>>,
    }
    impl<'a> Default for ImportDeclarationArgs<'a> {
        #[inline]
        fn default() -> Self {
            ImportDeclarationArgs {
                base_node: None,
                as_: None,
                path: None,
            }
        }
    }
    pub struct ImportDeclarationBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ImportDeclarationBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ImportDeclaration::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_as_(&mut self, as_: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    ImportDeclaration::VT_AS_,
                    as_,
                );
        }
        #[inline]
        pub fn add_path(&mut self, path: flatbuffers::WIPOffset<StringLiteral<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<StringLiteral>>(
                    ImportDeclaration::VT_PATH,
                    path,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ImportDeclarationBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ImportDeclarationBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ImportDeclaration<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ImportDeclaration<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ImportDeclaration");
            ds.field("base_node", &self.base_node());
            ds.field("as_", &self.as_());
            ds.field("path", &self.path());
            ds.finish()
        }
    }
    pub enum WrappedStatementOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct WrappedStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for WrappedStatement<'a> {
        type Inner = WrappedStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> WrappedStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            WrappedStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args WrappedStatementArgs,
        ) -> flatbuffers::WIPOffset<WrappedStatement<'bldr>> {
            let mut builder = WrappedStatementBuilder::new(_fbb);
            if let Some(x) = args.statement {
                builder.add_statement(x);
            }
            builder.add_statement_type(args.statement_type);
            builder.finish()
        }

        pub const VT_STATEMENT_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_STATEMENT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn statement_type(&self) -> Statement {
            self._tab
                .get::<Statement>(WrappedStatement::VT_STATEMENT_TYPE, Some(Statement::NONE))
                .unwrap()
        }
        #[inline]
        pub fn statement(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    WrappedStatement::VT_STATEMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_bad_statement(&self) -> Option<BadStatement<'a>> {
            if self.statement_type() == Statement::BadStatement {
                self.statement().map(BadStatement::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_variable_assignment(&self) -> Option<VariableAssignment<'a>> {
            if self.statement_type() == Statement::VariableAssignment {
                self.statement().map(VariableAssignment::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_member_assignment(&self) -> Option<MemberAssignment<'a>> {
            if self.statement_type() == Statement::MemberAssignment {
                self.statement().map(MemberAssignment::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_expression_statement(&self) -> Option<ExpressionStatement<'a>> {
            if self.statement_type() == Statement::ExpressionStatement {
                self.statement().map(ExpressionStatement::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_return_statement(&self) -> Option<ReturnStatement<'a>> {
            if self.statement_type() == Statement::ReturnStatement {
                self.statement().map(ReturnStatement::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_option_statement(&self) -> Option<OptionStatement<'a>> {
            if self.statement_type() == Statement::OptionStatement {
                self.statement().map(OptionStatement::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_builtin_statement(&self) -> Option<BuiltinStatement<'a>> {
            if self.statement_type() == Statement::BuiltinStatement {
                self.statement().map(BuiltinStatement::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_test_statement(&self) -> Option<TestStatement<'a>> {
            if self.statement_type() == Statement::TestStatement {
                self.statement().map(TestStatement::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_test_case_statement(&self) -> Option<TestCaseStatement<'a>> {
            if self.statement_type() == Statement::TestCaseStatement {
                self.statement().map(TestCaseStatement::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for WrappedStatement<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_union::<Statement, _>(&"statement_type", Self::VT_STATEMENT_TYPE, &"statement", Self::VT_STATEMENT, false, |key, v, pos| {
        match key {
          Statement::BadStatement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadStatement>>("Statement::BadStatement", pos),
          Statement::VariableAssignment => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VariableAssignment>>("Statement::VariableAssignment", pos),
          Statement::MemberAssignment => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberAssignment>>("Statement::MemberAssignment", pos),
          Statement::ExpressionStatement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExpressionStatement>>("Statement::ExpressionStatement", pos),
          Statement::ReturnStatement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReturnStatement>>("Statement::ReturnStatement", pos),
          Statement::OptionStatement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OptionStatement>>("Statement::OptionStatement", pos),
          Statement::BuiltinStatement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BuiltinStatement>>("Statement::BuiltinStatement", pos),
          Statement::TestStatement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TestStatement>>("Statement::TestStatement", pos),
          Statement::TestCaseStatement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TestCaseStatement>>("Statement::TestCaseStatement", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct WrappedStatementArgs {
        pub statement_type: Statement,
        pub statement: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for WrappedStatementArgs {
        #[inline]
        fn default() -> Self {
            WrappedStatementArgs {
                statement_type: Statement::NONE,
                statement: None,
            }
        }
    }
    pub struct WrappedStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> WrappedStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_statement_type(&mut self, statement_type: Statement) {
            self.fbb_.push_slot::<Statement>(
                WrappedStatement::VT_STATEMENT_TYPE,
                statement_type,
                Statement::NONE,
            );
        }
        #[inline]
        pub fn add_statement(
            &mut self,
            statement: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                WrappedStatement::VT_STATEMENT,
                statement,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> WrappedStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            WrappedStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<WrappedStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for WrappedStatement<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("WrappedStatement");
            ds.field("statement_type", &self.statement_type());
            match self.statement_type() {
                Statement::BadStatement => {
                    if let Some(x) = self.statement_as_bad_statement() {
                        ds.field("statement", &x)
                    } else {
                        ds.field(
                            "statement",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Statement::VariableAssignment => {
                    if let Some(x) = self.statement_as_variable_assignment() {
                        ds.field("statement", &x)
                    } else {
                        ds.field(
                            "statement",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Statement::MemberAssignment => {
                    if let Some(x) = self.statement_as_member_assignment() {
                        ds.field("statement", &x)
                    } else {
                        ds.field(
                            "statement",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Statement::ExpressionStatement => {
                    if let Some(x) = self.statement_as_expression_statement() {
                        ds.field("statement", &x)
                    } else {
                        ds.field(
                            "statement",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Statement::ReturnStatement => {
                    if let Some(x) = self.statement_as_return_statement() {
                        ds.field("statement", &x)
                    } else {
                        ds.field(
                            "statement",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Statement::OptionStatement => {
                    if let Some(x) = self.statement_as_option_statement() {
                        ds.field("statement", &x)
                    } else {
                        ds.field(
                            "statement",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Statement::BuiltinStatement => {
                    if let Some(x) = self.statement_as_builtin_statement() {
                        ds.field("statement", &x)
                    } else {
                        ds.field(
                            "statement",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Statement::TestStatement => {
                    if let Some(x) = self.statement_as_test_statement() {
                        ds.field("statement", &x)
                    } else {
                        ds.field(
                            "statement",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Statement::TestCaseStatement => {
                    if let Some(x) = self.statement_as_test_case_statement() {
                        ds.field("statement", &x)
                    } else {
                        ds.field(
                            "statement",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("statement", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum BadStatementOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BadStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BadStatement<'a> {
        type Inner = BadStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> BadStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BadStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BadStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<BadStatement<'bldr>> {
            let mut builder = BadStatementBuilder::new(_fbb);
            if let Some(x) = args.text {
                builder.add_text(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_TEXT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(BadStatement::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn text(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(BadStatement::VT_TEXT, None)
        }
    }

    impl flatbuffers::Verifiable for BadStatement<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"text", Self::VT_TEXT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BadStatementArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for BadStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            BadStatementArgs {
                base_node: None,
                text: None,
            }
        }
    }
    pub struct BadStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BadStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    BadStatement::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BadStatement::VT_TEXT, text);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BadStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BadStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BadStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for BadStatement<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("BadStatement");
            ds.field("base_node", &self.base_node());
            ds.field("text", &self.text());
            ds.finish()
        }
    }
    pub enum VariableAssignmentOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct VariableAssignment<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for VariableAssignment<'a> {
        type Inner = VariableAssignment<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> VariableAssignment<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            VariableAssignment { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args VariableAssignmentArgs<'args>,
        ) -> flatbuffers::WIPOffset<VariableAssignment<'bldr>> {
            let mut builder = VariableAssignmentBuilder::new(_fbb);
            if let Some(x) = args.init_ {
                builder.add_init_(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_init__type(args.init__type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;
        pub const VT_INIT__TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_INIT_: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode>>(
                VariableAssignment::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn id(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(VariableAssignment::VT_ID, None)
        }
        #[inline]
        pub fn init__type(&self) -> Expression {
            self._tab
                .get::<Expression>(VariableAssignment::VT_INIT__TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn init_(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    VariableAssignment::VT_INIT_,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.init__type() == Expression::StringExpression {
                self.init_().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.init__type() == Expression::ParenExpression {
                self.init_().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.init__type() == Expression::ArrayExpression {
                self.init_().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.init__type() == Expression::DictExpression {
                self.init_().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.init__type() == Expression::FunctionExpression {
                self.init_().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.init__type() == Expression::BinaryExpression {
                self.init_().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.init__type() == Expression::BooleanLiteral {
                self.init_().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.init__type() == Expression::CallExpression {
                self.init_().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.init__type() == Expression::ConditionalExpression {
                self.init_().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.init__type() == Expression::DateTimeLiteral {
                self.init_().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.init__type() == Expression::DurationLiteral {
                self.init_().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.init__type() == Expression::FloatLiteral {
                self.init_().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_identifier(&self) -> Option<Identifier<'a>> {
            if self.init__type() == Expression::Identifier {
                self.init_().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.init__type() == Expression::IntegerLiteral {
                self.init_().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.init__type() == Expression::LogicalExpression {
                self.init_().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.init__type() == Expression::MemberExpression {
                self.init_().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.init__type() == Expression::IndexExpression {
                self.init_().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.init__type() == Expression::ObjectExpression {
                self.init_().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.init__type() == Expression::PipeExpression {
                self.init_().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.init__type() == Expression::PipeLiteral {
                self.init_().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.init__type() == Expression::RegexpLiteral {
                self.init_().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.init__type() == Expression::StringLiteral {
                self.init_().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.init__type() == Expression::UnaryExpression {
                self.init_().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.init__type() == Expression::UnsignedIntegerLiteral {
                self.init_().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.init__type() == Expression::BadExpression {
                self.init_().map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for VariableAssignment<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(&"id", Self::VT_ID, false)?
     .visit_union::<Expression, _>(&"init__type", Self::VT_INIT__TYPE, &"init_", Self::VT_INIT_, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct VariableAssignmentArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub init__type: Expression,
        pub init_: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for VariableAssignmentArgs<'a> {
        #[inline]
        fn default() -> Self {
            VariableAssignmentArgs {
                base_node: None,
                id: None,
                init__type: Expression::NONE,
                init_: None,
            }
        }
    }
    pub struct VariableAssignmentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> VariableAssignmentBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    VariableAssignment::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    VariableAssignment::VT_ID,
                    id,
                );
        }
        #[inline]
        pub fn add_init__type(&mut self, init__type: Expression) {
            self.fbb_.push_slot::<Expression>(
                VariableAssignment::VT_INIT__TYPE,
                init__type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_init_(&mut self, init_: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(VariableAssignment::VT_INIT_, init_);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> VariableAssignmentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            VariableAssignmentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<VariableAssignment<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for VariableAssignment<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("VariableAssignment");
            ds.field("base_node", &self.base_node());
            ds.field("id", &self.id());
            ds.field("init__type", &self.init__type());
            match self.init__type() {
                Expression::StringExpression => {
                    if let Some(x) = self.init__as_string_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.init__as_paren_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.init__as_array_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.init__as_dict_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.init__as_function_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.init__as_binary_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.init__as_boolean_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.init__as_call_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.init__as_conditional_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.init__as_date_time_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.init__as_duration_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.init__as_float_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.init__as_identifier() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.init__as_integer_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.init__as_logical_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.init__as_member_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.init__as_index_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.init__as_object_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.init__as_pipe_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.init__as_pipe_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.init__as_regexp_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.init__as_string_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.init__as_unary_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.init__as_unsigned_integer_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.init__as_bad_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("init_", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum MemberAssignmentOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MemberAssignment<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MemberAssignment<'a> {
        type Inner = MemberAssignment<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> MemberAssignment<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MemberAssignment { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MemberAssignmentArgs<'args>,
        ) -> flatbuffers::WIPOffset<MemberAssignment<'bldr>> {
            let mut builder = MemberAssignmentBuilder::new(_fbb);
            if let Some(x) = args.init_ {
                builder.add_init_(x);
            }
            if let Some(x) = args.member {
                builder.add_member(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_init__type(args.init__type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_MEMBER: flatbuffers::VOffsetT = 6;
        pub const VT_INIT__TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_INIT_: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(MemberAssignment::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn member(&self) -> Option<MemberExpression<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<MemberExpression>>(
                    MemberAssignment::VT_MEMBER,
                    None,
                )
        }
        #[inline]
        pub fn init__type(&self) -> Expression {
            self._tab
                .get::<Expression>(MemberAssignment::VT_INIT__TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn init_(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    MemberAssignment::VT_INIT_,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.init__type() == Expression::StringExpression {
                self.init_().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.init__type() == Expression::ParenExpression {
                self.init_().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.init__type() == Expression::ArrayExpression {
                self.init_().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.init__type() == Expression::DictExpression {
                self.init_().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.init__type() == Expression::FunctionExpression {
                self.init_().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.init__type() == Expression::BinaryExpression {
                self.init_().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.init__type() == Expression::BooleanLiteral {
                self.init_().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.init__type() == Expression::CallExpression {
                self.init_().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.init__type() == Expression::ConditionalExpression {
                self.init_().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.init__type() == Expression::DateTimeLiteral {
                self.init_().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.init__type() == Expression::DurationLiteral {
                self.init_().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.init__type() == Expression::FloatLiteral {
                self.init_().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_identifier(&self) -> Option<Identifier<'a>> {
            if self.init__type() == Expression::Identifier {
                self.init_().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.init__type() == Expression::IntegerLiteral {
                self.init_().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.init__type() == Expression::LogicalExpression {
                self.init_().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.init__type() == Expression::MemberExpression {
                self.init_().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.init__type() == Expression::IndexExpression {
                self.init_().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.init__type() == Expression::ObjectExpression {
                self.init_().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.init__type() == Expression::PipeExpression {
                self.init_().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.init__type() == Expression::PipeLiteral {
                self.init_().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.init__type() == Expression::RegexpLiteral {
                self.init_().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.init__type() == Expression::StringLiteral {
                self.init_().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.init__type() == Expression::UnaryExpression {
                self.init_().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.init__type() == Expression::UnsignedIntegerLiteral {
                self.init_().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.init__type() == Expression::BadExpression {
                self.init_().map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for MemberAssignment<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<MemberExpression>>(&"member", Self::VT_MEMBER, false)?
     .visit_union::<Expression, _>(&"init__type", Self::VT_INIT__TYPE, &"init_", Self::VT_INIT_, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct MemberAssignmentArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub member: Option<flatbuffers::WIPOffset<MemberExpression<'a>>>,
        pub init__type: Expression,
        pub init_: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for MemberAssignmentArgs<'a> {
        #[inline]
        fn default() -> Self {
            MemberAssignmentArgs {
                base_node: None,
                member: None,
                init__type: Expression::NONE,
                init_: None,
            }
        }
    }
    pub struct MemberAssignmentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MemberAssignmentBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    MemberAssignment::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_member(&mut self, member: flatbuffers::WIPOffset<MemberExpression<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<MemberExpression>>(
                    MemberAssignment::VT_MEMBER,
                    member,
                );
        }
        #[inline]
        pub fn add_init__type(&mut self, init__type: Expression) {
            self.fbb_.push_slot::<Expression>(
                MemberAssignment::VT_INIT__TYPE,
                init__type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_init_(&mut self, init_: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MemberAssignment::VT_INIT_, init_);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MemberAssignmentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MemberAssignmentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MemberAssignment<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for MemberAssignment<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("MemberAssignment");
            ds.field("base_node", &self.base_node());
            ds.field("member", &self.member());
            ds.field("init__type", &self.init__type());
            match self.init__type() {
                Expression::StringExpression => {
                    if let Some(x) = self.init__as_string_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.init__as_paren_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.init__as_array_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.init__as_dict_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.init__as_function_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.init__as_binary_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.init__as_boolean_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.init__as_call_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.init__as_conditional_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.init__as_date_time_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.init__as_duration_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.init__as_float_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.init__as_identifier() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.init__as_integer_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.init__as_logical_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.init__as_member_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.init__as_index_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.init__as_object_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.init__as_pipe_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.init__as_pipe_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.init__as_regexp_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.init__as_string_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.init__as_unary_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.init__as_unsigned_integer_literal() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.init__as_bad_expression() {
                        ds.field("init_", &x)
                    } else {
                        ds.field(
                            "init_",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("init_", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum ExpressionStatementOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ExpressionStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ExpressionStatement<'a> {
        type Inner = ExpressionStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ExpressionStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ExpressionStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ExpressionStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<ExpressionStatement<'bldr>> {
            let mut builder = ExpressionStatementBuilder::new(_fbb);
            if let Some(x) = args.expression {
                builder.add_expression(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_expression_type(args.expression_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_EXPRESSION_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_EXPRESSION: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode>>(
                ExpressionStatement::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn expression_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    ExpressionStatement::VT_EXPRESSION_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn expression(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ExpressionStatement::VT_EXPRESSION,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.expression_type() == Expression::StringExpression {
                self.expression().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.expression_type() == Expression::ParenExpression {
                self.expression().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.expression_type() == Expression::ArrayExpression {
                self.expression().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.expression_type() == Expression::DictExpression {
                self.expression().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.expression_type() == Expression::FunctionExpression {
                self.expression().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.expression_type() == Expression::BinaryExpression {
                self.expression().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.expression_type() == Expression::BooleanLiteral {
                self.expression().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.expression_type() == Expression::CallExpression {
                self.expression().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.expression_type() == Expression::ConditionalExpression {
                self.expression()
                    .map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.expression_type() == Expression::DateTimeLiteral {
                self.expression().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.expression_type() == Expression::DurationLiteral {
                self.expression().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.expression_type() == Expression::FloatLiteral {
                self.expression().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.expression_type() == Expression::Identifier {
                self.expression().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.expression_type() == Expression::IntegerLiteral {
                self.expression().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.expression_type() == Expression::LogicalExpression {
                self.expression().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.expression_type() == Expression::MemberExpression {
                self.expression().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.expression_type() == Expression::IndexExpression {
                self.expression().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.expression_type() == Expression::ObjectExpression {
                self.expression().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.expression_type() == Expression::PipeExpression {
                self.expression().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.expression_type() == Expression::PipeLiteral {
                self.expression().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.expression_type() == Expression::RegexpLiteral {
                self.expression().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.expression_type() == Expression::StringLiteral {
                self.expression().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.expression_type() == Expression::UnaryExpression {
                self.expression().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.expression_type() == Expression::UnsignedIntegerLiteral {
                self.expression()
                    .map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.expression_type() == Expression::BadExpression {
                self.expression().map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ExpressionStatement<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_union::<Expression, _>(&"expression_type", Self::VT_EXPRESSION_TYPE, &"expression", Self::VT_EXPRESSION, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct ExpressionStatementArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub expression_type: Expression,
        pub expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ExpressionStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            ExpressionStatementArgs {
                base_node: None,
                expression_type: Expression::NONE,
                expression: None,
            }
        }
    }
    pub struct ExpressionStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ExpressionStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ExpressionStatement::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_expression_type(&mut self, expression_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ExpressionStatement::VT_EXPRESSION_TYPE,
                expression_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_expression(
            &mut self,
            expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ExpressionStatement::VT_EXPRESSION,
                expression,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ExpressionStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ExpressionStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ExpressionStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ExpressionStatement<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ExpressionStatement");
            ds.field("base_node", &self.base_node());
            ds.field("expression_type", &self.expression_type());
            match self.expression_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.expression_as_string_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.expression_as_paren_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.expression_as_array_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.expression_as_dict_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.expression_as_function_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.expression_as_binary_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.expression_as_boolean_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.expression_as_call_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.expression_as_conditional_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.expression_as_date_time_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.expression_as_duration_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.expression_as_float_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.expression_as_identifier() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.expression_as_integer_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.expression_as_logical_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.expression_as_member_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.expression_as_index_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.expression_as_object_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.expression_as_pipe_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.expression_as_pipe_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.expression_as_regexp_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.expression_as_string_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.expression_as_unary_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.expression_as_unsigned_integer_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.expression_as_bad_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("expression", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum ReturnStatementOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ReturnStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ReturnStatement<'a> {
        type Inner = ReturnStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ReturnStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ReturnStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ReturnStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<ReturnStatement<'bldr>> {
            let mut builder = ReturnStatementBuilder::new(_fbb);
            if let Some(x) = args.argument {
                builder.add_argument(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_argument_type(args.argument_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ARGUMENT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ARGUMENT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(ReturnStatement::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn argument_type(&self) -> Expression {
            self._tab
                .get::<Expression>(ReturnStatement::VT_ARGUMENT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn argument(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ReturnStatement::VT_ARGUMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.argument_type() == Expression::StringExpression {
                self.argument().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.argument_type() == Expression::ParenExpression {
                self.argument().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.argument_type() == Expression::ArrayExpression {
                self.argument().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.argument_type() == Expression::DictExpression {
                self.argument().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.argument_type() == Expression::FunctionExpression {
                self.argument().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.argument_type() == Expression::BinaryExpression {
                self.argument().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.argument_type() == Expression::BooleanLiteral {
                self.argument().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.argument_type() == Expression::CallExpression {
                self.argument().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.argument_type() == Expression::ConditionalExpression {
                self.argument().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.argument_type() == Expression::DateTimeLiteral {
                self.argument().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.argument_type() == Expression::DurationLiteral {
                self.argument().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.argument_type() == Expression::FloatLiteral {
                self.argument().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.argument_type() == Expression::Identifier {
                self.argument().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.argument_type() == Expression::IntegerLiteral {
                self.argument().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.argument_type() == Expression::LogicalExpression {
                self.argument().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.argument_type() == Expression::MemberExpression {
                self.argument().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.argument_type() == Expression::IndexExpression {
                self.argument().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.argument_type() == Expression::ObjectExpression {
                self.argument().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.argument_type() == Expression::PipeExpression {
                self.argument().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.argument_type() == Expression::PipeLiteral {
                self.argument().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.argument_type() == Expression::RegexpLiteral {
                self.argument().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.argument_type() == Expression::StringLiteral {
                self.argument().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.argument_type() == Expression::UnaryExpression {
                self.argument().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.argument_type() == Expression::UnsignedIntegerLiteral {
                self.argument().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.argument_type() == Expression::BadExpression {
                self.argument().map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ReturnStatement<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_union::<Expression, _>(&"argument_type", Self::VT_ARGUMENT_TYPE, &"argument", Self::VT_ARGUMENT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct ReturnStatementArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub argument_type: Expression,
        pub argument: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ReturnStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            ReturnStatementArgs {
                base_node: None,
                argument_type: Expression::NONE,
                argument: None,
            }
        }
    }
    pub struct ReturnStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ReturnStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ReturnStatement::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_argument_type(&mut self, argument_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ReturnStatement::VT_ARGUMENT_TYPE,
                argument_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_argument(
            &mut self,
            argument: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ReturnStatement::VT_ARGUMENT,
                argument,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ReturnStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ReturnStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ReturnStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ReturnStatement<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ReturnStatement");
            ds.field("base_node", &self.base_node());
            ds.field("argument_type", &self.argument_type());
            match self.argument_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.argument_as_string_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.argument_as_paren_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.argument_as_array_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.argument_as_dict_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.argument_as_function_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.argument_as_binary_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.argument_as_boolean_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.argument_as_call_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.argument_as_conditional_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.argument_as_date_time_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.argument_as_duration_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.argument_as_float_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.argument_as_identifier() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.argument_as_integer_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.argument_as_logical_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.argument_as_member_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.argument_as_index_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.argument_as_object_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.argument_as_pipe_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.argument_as_pipe_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.argument_as_regexp_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.argument_as_string_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.argument_as_unary_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.argument_as_unsigned_integer_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.argument_as_bad_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("argument", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum OptionStatementOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct OptionStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for OptionStatement<'a> {
        type Inner = OptionStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> OptionStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            OptionStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args OptionStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<OptionStatement<'bldr>> {
            let mut builder = OptionStatementBuilder::new(_fbb);
            if let Some(x) = args.assignment {
                builder.add_assignment(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_assignment_type(args.assignment_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ASSIGNMENT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ASSIGNMENT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(OptionStatement::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn assignment_type(&self) -> Assignment {
            self._tab
                .get::<Assignment>(OptionStatement::VT_ASSIGNMENT_TYPE, Some(Assignment::NONE))
                .unwrap()
        }
        #[inline]
        pub fn assignment(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    OptionStatement::VT_ASSIGNMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn assignment_as_member_assignment(&self) -> Option<MemberAssignment<'a>> {
            if self.assignment_type() == Assignment::MemberAssignment {
                self.assignment().map(MemberAssignment::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn assignment_as_variable_assignment(&self) -> Option<VariableAssignment<'a>> {
            if self.assignment_type() == Assignment::VariableAssignment {
                self.assignment().map(VariableAssignment::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for OptionStatement<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_union::<Assignment, _>(&"assignment_type", Self::VT_ASSIGNMENT_TYPE, &"assignment", Self::VT_ASSIGNMENT, false, |key, v, pos| {
        match key {
          Assignment::MemberAssignment => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberAssignment>>("Assignment::MemberAssignment", pos),
          Assignment::VariableAssignment => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VariableAssignment>>("Assignment::VariableAssignment", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct OptionStatementArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub assignment_type: Assignment,
        pub assignment: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for OptionStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            OptionStatementArgs {
                base_node: None,
                assignment_type: Assignment::NONE,
                assignment: None,
            }
        }
    }
    pub struct OptionStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> OptionStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    OptionStatement::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_assignment_type(&mut self, assignment_type: Assignment) {
            self.fbb_.push_slot::<Assignment>(
                OptionStatement::VT_ASSIGNMENT_TYPE,
                assignment_type,
                Assignment::NONE,
            );
        }
        #[inline]
        pub fn add_assignment(
            &mut self,
            assignment: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                OptionStatement::VT_ASSIGNMENT,
                assignment,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> OptionStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            OptionStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<OptionStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for OptionStatement<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("OptionStatement");
            ds.field("base_node", &self.base_node());
            ds.field("assignment_type", &self.assignment_type());
            match self.assignment_type() {
                Assignment::MemberAssignment => {
                    if let Some(x) = self.assignment_as_member_assignment() {
                        ds.field("assignment", &x)
                    } else {
                        ds.field(
                            "assignment",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Assignment::VariableAssignment => {
                    if let Some(x) = self.assignment_as_variable_assignment() {
                        ds.field("assignment", &x)
                    } else {
                        ds.field(
                            "assignment",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("assignment", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum BuiltinStatementOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BuiltinStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BuiltinStatement<'a> {
        type Inner = BuiltinStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> BuiltinStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BuiltinStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BuiltinStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<BuiltinStatement<'bldr>> {
            let mut builder = BuiltinStatementBuilder::new(_fbb);
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(BuiltinStatement::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn id(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(BuiltinStatement::VT_ID, None)
        }
    }

    impl flatbuffers::Verifiable for BuiltinStatement<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(&"id", Self::VT_ID, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BuiltinStatementArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    }
    impl<'a> Default for BuiltinStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            BuiltinStatementArgs {
                base_node: None,
                id: None,
            }
        }
    }
    pub struct BuiltinStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BuiltinStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    BuiltinStatement::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    BuiltinStatement::VT_ID,
                    id,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BuiltinStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BuiltinStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BuiltinStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for BuiltinStatement<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("BuiltinStatement");
            ds.field("base_node", &self.base_node());
            ds.field("id", &self.id());
            ds.finish()
        }
    }
    pub enum TestStatementOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TestStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TestStatement<'a> {
        type Inner = TestStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> TestStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TestStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TestStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<TestStatement<'bldr>> {
            let mut builder = TestStatementBuilder::new(_fbb);
            if let Some(x) = args.assignment {
                builder.add_assignment(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_assignment_type(args.assignment_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ASSIGNMENT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ASSIGNMENT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(TestStatement::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn assignment_type(&self) -> Assignment {
            self._tab
                .get::<Assignment>(TestStatement::VT_ASSIGNMENT_TYPE, Some(Assignment::NONE))
                .unwrap()
        }
        #[inline]
        pub fn assignment(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    TestStatement::VT_ASSIGNMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn assignment_as_member_assignment(&self) -> Option<MemberAssignment<'a>> {
            if self.assignment_type() == Assignment::MemberAssignment {
                self.assignment().map(MemberAssignment::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn assignment_as_variable_assignment(&self) -> Option<VariableAssignment<'a>> {
            if self.assignment_type() == Assignment::VariableAssignment {
                self.assignment().map(VariableAssignment::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for TestStatement<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_union::<Assignment, _>(&"assignment_type", Self::VT_ASSIGNMENT_TYPE, &"assignment", Self::VT_ASSIGNMENT, false, |key, v, pos| {
        match key {
          Assignment::MemberAssignment => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberAssignment>>("Assignment::MemberAssignment", pos),
          Assignment::VariableAssignment => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VariableAssignment>>("Assignment::VariableAssignment", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct TestStatementArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub assignment_type: Assignment,
        pub assignment: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for TestStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            TestStatementArgs {
                base_node: None,
                assignment_type: Assignment::NONE,
                assignment: None,
            }
        }
    }
    pub struct TestStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TestStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    TestStatement::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_assignment_type(&mut self, assignment_type: Assignment) {
            self.fbb_.push_slot::<Assignment>(
                TestStatement::VT_ASSIGNMENT_TYPE,
                assignment_type,
                Assignment::NONE,
            );
        }
        #[inline]
        pub fn add_assignment(
            &mut self,
            assignment: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TestStatement::VT_ASSIGNMENT,
                assignment,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TestStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TestStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TestStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for TestStatement<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("TestStatement");
            ds.field("base_node", &self.base_node());
            ds.field("assignment_type", &self.assignment_type());
            match self.assignment_type() {
                Assignment::MemberAssignment => {
                    if let Some(x) = self.assignment_as_member_assignment() {
                        ds.field("assignment", &x)
                    } else {
                        ds.field(
                            "assignment",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Assignment::VariableAssignment => {
                    if let Some(x) = self.assignment_as_variable_assignment() {
                        ds.field("assignment", &x)
                    } else {
                        ds.field(
                            "assignment",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("assignment", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum TestCaseStatementOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TestCaseStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TestCaseStatement<'a> {
        type Inner = TestCaseStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> TestCaseStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TestCaseStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TestCaseStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<TestCaseStatement<'bldr>> {
            let mut builder = TestCaseStatementBuilder::new(_fbb);
            if let Some(x) = args.block {
                builder.add_block(x);
            }
            if let Some(x) = args.extends {
                builder.add_extends(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;
        pub const VT_EXTENDS: flatbuffers::VOffsetT = 8;
        pub const VT_BLOCK: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode>>(
                TestCaseStatement::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn id(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(TestCaseStatement::VT_ID, None)
        }
        #[inline]
        pub fn extends(&self) -> Option<StringLiteral<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<StringLiteral>>(
                    TestCaseStatement::VT_EXTENDS,
                    None,
                )
        }
        #[inline]
        pub fn block(&self) -> Option<Block<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Block>>(TestCaseStatement::VT_BLOCK, None)
        }
    }

    impl flatbuffers::Verifiable for TestCaseStatement<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(&"id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<StringLiteral>>(
                    &"extends",
                    Self::VT_EXTENDS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Block>>(
                    &"block",
                    Self::VT_BLOCK,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TestCaseStatementArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub extends: Option<flatbuffers::WIPOffset<StringLiteral<'a>>>,
        pub block: Option<flatbuffers::WIPOffset<Block<'a>>>,
    }
    impl<'a> Default for TestCaseStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            TestCaseStatementArgs {
                base_node: None,
                id: None,
                extends: None,
                block: None,
            }
        }
    }
    pub struct TestCaseStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TestCaseStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    TestCaseStatement::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    TestCaseStatement::VT_ID,
                    id,
                );
        }
        #[inline]
        pub fn add_extends(&mut self, extends: flatbuffers::WIPOffset<StringLiteral<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<StringLiteral>>(
                    TestCaseStatement::VT_EXTENDS,
                    extends,
                );
        }
        #[inline]
        pub fn add_block(&mut self, block: flatbuffers::WIPOffset<Block<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Block>>(
                TestCaseStatement::VT_BLOCK,
                block,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TestCaseStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TestCaseStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TestCaseStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for TestCaseStatement<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("TestCaseStatement");
            ds.field("base_node", &self.base_node());
            ds.field("id", &self.id());
            ds.field("extends", &self.extends());
            ds.field("block", &self.block());
            ds.finish()
        }
    }
    pub enum WrappedExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct WrappedExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for WrappedExpression<'a> {
        type Inner = WrappedExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> WrappedExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            WrappedExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args WrappedExpressionArgs,
        ) -> flatbuffers::WIPOffset<WrappedExpression<'bldr>> {
            let mut builder = WrappedExpressionBuilder::new(_fbb);
            if let Some(x) = args.expr {
                builder.add_expr(x);
            }
            builder.add_expr_type(args.expr_type);
            builder.finish()
        }

        pub const VT_EXPR_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_EXPR: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn expr_type(&self) -> Expression {
            self._tab
                .get::<Expression>(WrappedExpression::VT_EXPR_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn expr(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    WrappedExpression::VT_EXPR,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.expr_type() == Expression::StringExpression {
                self.expr().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.expr_type() == Expression::ParenExpression {
                self.expr().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.expr_type() == Expression::ArrayExpression {
                self.expr().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.expr_type() == Expression::DictExpression {
                self.expr().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.expr_type() == Expression::FunctionExpression {
                self.expr().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.expr_type() == Expression::BinaryExpression {
                self.expr().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.expr_type() == Expression::BooleanLiteral {
                self.expr().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.expr_type() == Expression::CallExpression {
                self.expr().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.expr_type() == Expression::ConditionalExpression {
                self.expr().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.expr_type() == Expression::DateTimeLiteral {
                self.expr().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.expr_type() == Expression::DurationLiteral {
                self.expr().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.expr_type() == Expression::FloatLiteral {
                self.expr().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.expr_type() == Expression::Identifier {
                self.expr().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.expr_type() == Expression::IntegerLiteral {
                self.expr().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.expr_type() == Expression::LogicalExpression {
                self.expr().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.expr_type() == Expression::MemberExpression {
                self.expr().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.expr_type() == Expression::IndexExpression {
                self.expr().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.expr_type() == Expression::ObjectExpression {
                self.expr().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.expr_type() == Expression::PipeExpression {
                self.expr().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.expr_type() == Expression::PipeLiteral {
                self.expr().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.expr_type() == Expression::RegexpLiteral {
                self.expr().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.expr_type() == Expression::StringLiteral {
                self.expr().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.expr_type() == Expression::UnaryExpression {
                self.expr().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.expr_type() == Expression::UnsignedIntegerLiteral {
                self.expr().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.expr_type() == Expression::BadExpression {
                self.expr().map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for WrappedExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_union::<Expression, _>(&"expr_type", Self::VT_EXPR_TYPE, &"expr", Self::VT_EXPR, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct WrappedExpressionArgs {
        pub expr_type: Expression,
        pub expr: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for WrappedExpressionArgs {
        #[inline]
        fn default() -> Self {
            WrappedExpressionArgs {
                expr_type: Expression::NONE,
                expr: None,
            }
        }
    }
    pub struct WrappedExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> WrappedExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_expr_type(&mut self, expr_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                WrappedExpression::VT_EXPR_TYPE,
                expr_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_expr(&mut self, expr: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(WrappedExpression::VT_EXPR, expr);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> WrappedExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            WrappedExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<WrappedExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for WrappedExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("WrappedExpression");
            ds.field("expr_type", &self.expr_type());
            match self.expr_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.expr_as_string_expression() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.expr_as_paren_expression() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.expr_as_array_expression() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.expr_as_dict_expression() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.expr_as_function_expression() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.expr_as_binary_expression() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.expr_as_boolean_literal() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.expr_as_call_expression() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.expr_as_conditional_expression() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.expr_as_date_time_literal() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.expr_as_duration_literal() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.expr_as_float_literal() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.expr_as_identifier() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.expr_as_integer_literal() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.expr_as_logical_expression() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.expr_as_member_expression() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.expr_as_index_expression() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.expr_as_object_expression() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.expr_as_pipe_expression() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.expr_as_pipe_literal() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.expr_as_regexp_literal() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.expr_as_string_literal() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.expr_as_unary_expression() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.expr_as_unsigned_integer_literal() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.expr_as_bad_expression() {
                        ds.field("expr", &x)
                    } else {
                        ds.field(
                            "expr",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("expr", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum BinaryExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BinaryExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BinaryExpression<'a> {
        type Inner = BinaryExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> BinaryExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BinaryExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BinaryExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<BinaryExpression<'bldr>> {
            let mut builder = BinaryExpressionBuilder::new(_fbb);
            if let Some(x) = args.right {
                builder.add_right(x);
            }
            if let Some(x) = args.left {
                builder.add_left(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_right_type(args.right_type);
            builder.add_left_type(args.left_type);
            builder.add_operator(args.operator);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_OPERATOR: flatbuffers::VOffsetT = 6;
        pub const VT_LEFT_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_LEFT: flatbuffers::VOffsetT = 10;
        pub const VT_RIGHT_TYPE: flatbuffers::VOffsetT = 12;
        pub const VT_RIGHT: flatbuffers::VOffsetT = 14;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(BinaryExpression::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn operator(&self) -> Operator {
            self._tab
                .get::<Operator>(
                    BinaryExpression::VT_OPERATOR,
                    Some(Operator::InvalidOperator),
                )
                .unwrap()
        }
        #[inline]
        pub fn left_type(&self) -> Expression {
            self._tab
                .get::<Expression>(BinaryExpression::VT_LEFT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn left(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    BinaryExpression::VT_LEFT,
                    None,
                )
        }
        #[inline]
        pub fn right_type(&self) -> Expression {
            self._tab
                .get::<Expression>(BinaryExpression::VT_RIGHT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn right(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    BinaryExpression::VT_RIGHT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.left_type() == Expression::StringExpression {
                self.left().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.left_type() == Expression::ParenExpression {
                self.left().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.left_type() == Expression::ArrayExpression {
                self.left().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.left_type() == Expression::DictExpression {
                self.left().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.left_type() == Expression::FunctionExpression {
                self.left().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.left_type() == Expression::BinaryExpression {
                self.left().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.left_type() == Expression::BooleanLiteral {
                self.left().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.left_type() == Expression::CallExpression {
                self.left().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.left_type() == Expression::ConditionalExpression {
                self.left().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.left_type() == Expression::DateTimeLiteral {
                self.left().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.left_type() == Expression::DurationLiteral {
                self.left().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.left_type() == Expression::FloatLiteral {
                self.left().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.left_type() == Expression::Identifier {
                self.left().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.left_type() == Expression::IntegerLiteral {
                self.left().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.left_type() == Expression::LogicalExpression {
                self.left().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.left_type() == Expression::MemberExpression {
                self.left().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.left_type() == Expression::IndexExpression {
                self.left().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.left_type() == Expression::ObjectExpression {
                self.left().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.left_type() == Expression::PipeExpression {
                self.left().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.left_type() == Expression::PipeLiteral {
                self.left().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.left_type() == Expression::RegexpLiteral {
                self.left().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.left_type() == Expression::StringLiteral {
                self.left().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.left_type() == Expression::UnaryExpression {
                self.left().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.left_type() == Expression::UnsignedIntegerLiteral {
                self.left().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.left_type() == Expression::BadExpression {
                self.left().map(BadExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.right_type() == Expression::StringExpression {
                self.right().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.right_type() == Expression::ParenExpression {
                self.right().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.right_type() == Expression::ArrayExpression {
                self.right().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.right_type() == Expression::DictExpression {
                self.right().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.right_type() == Expression::FunctionExpression {
                self.right().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.right_type() == Expression::BinaryExpression {
                self.right().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.right_type() == Expression::BooleanLiteral {
                self.right().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.right_type() == Expression::CallExpression {
                self.right().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.right_type() == Expression::ConditionalExpression {
                self.right().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.right_type() == Expression::DateTimeLiteral {
                self.right().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.right_type() == Expression::DurationLiteral {
                self.right().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.right_type() == Expression::FloatLiteral {
                self.right().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.right_type() == Expression::Identifier {
                self.right().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.right_type() == Expression::IntegerLiteral {
                self.right().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.right_type() == Expression::LogicalExpression {
                self.right().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.right_type() == Expression::MemberExpression {
                self.right().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.right_type() == Expression::IndexExpression {
                self.right().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.right_type() == Expression::ObjectExpression {
                self.right().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.right_type() == Expression::PipeExpression {
                self.right().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.right_type() == Expression::PipeLiteral {
                self.right().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.right_type() == Expression::RegexpLiteral {
                self.right().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.right_type() == Expression::StringLiteral {
                self.right().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.right_type() == Expression::UnaryExpression {
                self.right().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.right_type() == Expression::UnsignedIntegerLiteral {
                self.right().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.right_type() == Expression::BadExpression {
                self.right().map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for BinaryExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_field::<Operator>(&"operator", Self::VT_OPERATOR, false)?
     .visit_union::<Expression, _>(&"left_type", Self::VT_LEFT_TYPE, &"left", Self::VT_LEFT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Expression, _>(&"right_type", Self::VT_RIGHT_TYPE, &"right", Self::VT_RIGHT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct BinaryExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub operator: Operator,
        pub left_type: Expression,
        pub left: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub right_type: Expression,
        pub right: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for BinaryExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            BinaryExpressionArgs {
                base_node: None,
                operator: Operator::InvalidOperator,
                left_type: Expression::NONE,
                left: None,
                right_type: Expression::NONE,
                right: None,
            }
        }
    }
    pub struct BinaryExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BinaryExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    BinaryExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_operator(&mut self, operator: Operator) {
            self.fbb_.push_slot::<Operator>(
                BinaryExpression::VT_OPERATOR,
                operator,
                Operator::InvalidOperator,
            );
        }
        #[inline]
        pub fn add_left_type(&mut self, left_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                BinaryExpression::VT_LEFT_TYPE,
                left_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_left(&mut self, left: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryExpression::VT_LEFT, left);
        }
        #[inline]
        pub fn add_right_type(&mut self, right_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                BinaryExpression::VT_RIGHT_TYPE,
                right_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_right(&mut self, right: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryExpression::VT_RIGHT, right);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BinaryExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BinaryExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BinaryExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for BinaryExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("BinaryExpression");
            ds.field("base_node", &self.base_node());
            ds.field("operator", &self.operator());
            ds.field("left_type", &self.left_type());
            match self.left_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.left_as_string_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.left_as_paren_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.left_as_array_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.left_as_dict_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.left_as_function_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.left_as_binary_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.left_as_boolean_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.left_as_call_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.left_as_conditional_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.left_as_date_time_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.left_as_duration_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.left_as_float_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.left_as_identifier() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.left_as_integer_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.left_as_logical_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.left_as_member_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.left_as_index_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.left_as_object_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.left_as_pipe_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.left_as_pipe_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.left_as_regexp_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.left_as_string_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.left_as_unary_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.left_as_unsigned_integer_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.left_as_bad_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("left", &x)
                }
            };
            ds.field("right_type", &self.right_type());
            match self.right_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.right_as_string_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.right_as_paren_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.right_as_array_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.right_as_dict_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.right_as_function_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.right_as_binary_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.right_as_boolean_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.right_as_call_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.right_as_conditional_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.right_as_date_time_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.right_as_duration_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.right_as_float_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.right_as_identifier() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.right_as_integer_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.right_as_logical_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.right_as_member_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.right_as_index_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.right_as_object_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.right_as_pipe_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.right_as_pipe_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.right_as_regexp_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.right_as_string_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.right_as_unary_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.right_as_unsigned_integer_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.right_as_bad_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("right", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum LogicalExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LogicalExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LogicalExpression<'a> {
        type Inner = LogicalExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> LogicalExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LogicalExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LogicalExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<LogicalExpression<'bldr>> {
            let mut builder = LogicalExpressionBuilder::new(_fbb);
            if let Some(x) = args.right {
                builder.add_right(x);
            }
            if let Some(x) = args.left {
                builder.add_left(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_right_type(args.right_type);
            builder.add_left_type(args.left_type);
            builder.add_operator(args.operator);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_OPERATOR: flatbuffers::VOffsetT = 6;
        pub const VT_LEFT_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_LEFT: flatbuffers::VOffsetT = 10;
        pub const VT_RIGHT_TYPE: flatbuffers::VOffsetT = 12;
        pub const VT_RIGHT: flatbuffers::VOffsetT = 14;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode>>(
                LogicalExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn operator(&self) -> LogicalOperator {
            self._tab
                .get::<LogicalOperator>(
                    LogicalExpression::VT_OPERATOR,
                    Some(LogicalOperator::AndOperator),
                )
                .unwrap()
        }
        #[inline]
        pub fn left_type(&self) -> Expression {
            self._tab
                .get::<Expression>(LogicalExpression::VT_LEFT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn left(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    LogicalExpression::VT_LEFT,
                    None,
                )
        }
        #[inline]
        pub fn right_type(&self) -> Expression {
            self._tab
                .get::<Expression>(LogicalExpression::VT_RIGHT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn right(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    LogicalExpression::VT_RIGHT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.left_type() == Expression::StringExpression {
                self.left().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.left_type() == Expression::ParenExpression {
                self.left().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.left_type() == Expression::ArrayExpression {
                self.left().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.left_type() == Expression::DictExpression {
                self.left().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.left_type() == Expression::FunctionExpression {
                self.left().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.left_type() == Expression::BinaryExpression {
                self.left().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.left_type() == Expression::BooleanLiteral {
                self.left().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.left_type() == Expression::CallExpression {
                self.left().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.left_type() == Expression::ConditionalExpression {
                self.left().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.left_type() == Expression::DateTimeLiteral {
                self.left().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.left_type() == Expression::DurationLiteral {
                self.left().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.left_type() == Expression::FloatLiteral {
                self.left().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.left_type() == Expression::Identifier {
                self.left().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.left_type() == Expression::IntegerLiteral {
                self.left().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.left_type() == Expression::LogicalExpression {
                self.left().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.left_type() == Expression::MemberExpression {
                self.left().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.left_type() == Expression::IndexExpression {
                self.left().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.left_type() == Expression::ObjectExpression {
                self.left().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.left_type() == Expression::PipeExpression {
                self.left().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.left_type() == Expression::PipeLiteral {
                self.left().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.left_type() == Expression::RegexpLiteral {
                self.left().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.left_type() == Expression::StringLiteral {
                self.left().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.left_type() == Expression::UnaryExpression {
                self.left().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.left_type() == Expression::UnsignedIntegerLiteral {
                self.left().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.left_type() == Expression::BadExpression {
                self.left().map(BadExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.right_type() == Expression::StringExpression {
                self.right().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.right_type() == Expression::ParenExpression {
                self.right().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.right_type() == Expression::ArrayExpression {
                self.right().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.right_type() == Expression::DictExpression {
                self.right().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.right_type() == Expression::FunctionExpression {
                self.right().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.right_type() == Expression::BinaryExpression {
                self.right().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.right_type() == Expression::BooleanLiteral {
                self.right().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.right_type() == Expression::CallExpression {
                self.right().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.right_type() == Expression::ConditionalExpression {
                self.right().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.right_type() == Expression::DateTimeLiteral {
                self.right().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.right_type() == Expression::DurationLiteral {
                self.right().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.right_type() == Expression::FloatLiteral {
                self.right().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.right_type() == Expression::Identifier {
                self.right().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.right_type() == Expression::IntegerLiteral {
                self.right().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.right_type() == Expression::LogicalExpression {
                self.right().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.right_type() == Expression::MemberExpression {
                self.right().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.right_type() == Expression::IndexExpression {
                self.right().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.right_type() == Expression::ObjectExpression {
                self.right().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.right_type() == Expression::PipeExpression {
                self.right().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.right_type() == Expression::PipeLiteral {
                self.right().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.right_type() == Expression::RegexpLiteral {
                self.right().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.right_type() == Expression::StringLiteral {
                self.right().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.right_type() == Expression::UnaryExpression {
                self.right().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.right_type() == Expression::UnsignedIntegerLiteral {
                self.right().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.right_type() == Expression::BadExpression {
                self.right().map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for LogicalExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_field::<LogicalOperator>(&"operator", Self::VT_OPERATOR, false)?
     .visit_union::<Expression, _>(&"left_type", Self::VT_LEFT_TYPE, &"left", Self::VT_LEFT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Expression, _>(&"right_type", Self::VT_RIGHT_TYPE, &"right", Self::VT_RIGHT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct LogicalExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub operator: LogicalOperator,
        pub left_type: Expression,
        pub left: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub right_type: Expression,
        pub right: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for LogicalExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            LogicalExpressionArgs {
                base_node: None,
                operator: LogicalOperator::AndOperator,
                left_type: Expression::NONE,
                left: None,
                right_type: Expression::NONE,
                right: None,
            }
        }
    }
    pub struct LogicalExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LogicalExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    LogicalExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_operator(&mut self, operator: LogicalOperator) {
            self.fbb_.push_slot::<LogicalOperator>(
                LogicalExpression::VT_OPERATOR,
                operator,
                LogicalOperator::AndOperator,
            );
        }
        #[inline]
        pub fn add_left_type(&mut self, left_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                LogicalExpression::VT_LEFT_TYPE,
                left_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_left(&mut self, left: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(LogicalExpression::VT_LEFT, left);
        }
        #[inline]
        pub fn add_right_type(&mut self, right_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                LogicalExpression::VT_RIGHT_TYPE,
                right_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_right(&mut self, right: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(LogicalExpression::VT_RIGHT, right);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LogicalExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LogicalExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LogicalExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for LogicalExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("LogicalExpression");
            ds.field("base_node", &self.base_node());
            ds.field("operator", &self.operator());
            ds.field("left_type", &self.left_type());
            match self.left_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.left_as_string_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.left_as_paren_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.left_as_array_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.left_as_dict_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.left_as_function_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.left_as_binary_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.left_as_boolean_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.left_as_call_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.left_as_conditional_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.left_as_date_time_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.left_as_duration_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.left_as_float_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.left_as_identifier() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.left_as_integer_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.left_as_logical_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.left_as_member_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.left_as_index_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.left_as_object_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.left_as_pipe_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.left_as_pipe_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.left_as_regexp_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.left_as_string_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.left_as_unary_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.left_as_unsigned_integer_literal() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.left_as_bad_expression() {
                        ds.field("left", &x)
                    } else {
                        ds.field(
                            "left",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("left", &x)
                }
            };
            ds.field("right_type", &self.right_type());
            match self.right_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.right_as_string_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.right_as_paren_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.right_as_array_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.right_as_dict_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.right_as_function_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.right_as_binary_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.right_as_boolean_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.right_as_call_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.right_as_conditional_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.right_as_date_time_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.right_as_duration_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.right_as_float_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.right_as_identifier() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.right_as_integer_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.right_as_logical_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.right_as_member_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.right_as_index_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.right_as_object_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.right_as_pipe_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.right_as_pipe_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.right_as_regexp_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.right_as_string_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.right_as_unary_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.right_as_unsigned_integer_literal() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.right_as_bad_expression() {
                        ds.field("right", &x)
                    } else {
                        ds.field(
                            "right",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("right", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum UnaryExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UnaryExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnaryExpression<'a> {
        type Inner = UnaryExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> UnaryExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnaryExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UnaryExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<UnaryExpression<'bldr>> {
            let mut builder = UnaryExpressionBuilder::new(_fbb);
            if let Some(x) = args.argument {
                builder.add_argument(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_argument_type(args.argument_type);
            builder.add_operator(args.operator);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_OPERATOR: flatbuffers::VOffsetT = 6;
        pub const VT_ARGUMENT_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_ARGUMENT: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(UnaryExpression::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn operator(&self) -> Operator {
            self._tab
                .get::<Operator>(
                    UnaryExpression::VT_OPERATOR,
                    Some(Operator::InvalidOperator),
                )
                .unwrap()
        }
        #[inline]
        pub fn argument_type(&self) -> Expression {
            self._tab
                .get::<Expression>(UnaryExpression::VT_ARGUMENT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn argument(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    UnaryExpression::VT_ARGUMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.argument_type() == Expression::StringExpression {
                self.argument().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.argument_type() == Expression::ParenExpression {
                self.argument().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.argument_type() == Expression::ArrayExpression {
                self.argument().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.argument_type() == Expression::DictExpression {
                self.argument().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.argument_type() == Expression::FunctionExpression {
                self.argument().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.argument_type() == Expression::BinaryExpression {
                self.argument().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.argument_type() == Expression::BooleanLiteral {
                self.argument().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.argument_type() == Expression::CallExpression {
                self.argument().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.argument_type() == Expression::ConditionalExpression {
                self.argument().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.argument_type() == Expression::DateTimeLiteral {
                self.argument().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.argument_type() == Expression::DurationLiteral {
                self.argument().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.argument_type() == Expression::FloatLiteral {
                self.argument().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.argument_type() == Expression::Identifier {
                self.argument().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.argument_type() == Expression::IntegerLiteral {
                self.argument().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.argument_type() == Expression::LogicalExpression {
                self.argument().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.argument_type() == Expression::MemberExpression {
                self.argument().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.argument_type() == Expression::IndexExpression {
                self.argument().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.argument_type() == Expression::ObjectExpression {
                self.argument().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.argument_type() == Expression::PipeExpression {
                self.argument().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.argument_type() == Expression::PipeLiteral {
                self.argument().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.argument_type() == Expression::RegexpLiteral {
                self.argument().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.argument_type() == Expression::StringLiteral {
                self.argument().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.argument_type() == Expression::UnaryExpression {
                self.argument().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.argument_type() == Expression::UnsignedIntegerLiteral {
                self.argument().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.argument_type() == Expression::BadExpression {
                self.argument().map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for UnaryExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_field::<Operator>(&"operator", Self::VT_OPERATOR, false)?
     .visit_union::<Expression, _>(&"argument_type", Self::VT_ARGUMENT_TYPE, &"argument", Self::VT_ARGUMENT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct UnaryExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub operator: Operator,
        pub argument_type: Expression,
        pub argument: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for UnaryExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            UnaryExpressionArgs {
                base_node: None,
                operator: Operator::InvalidOperator,
                argument_type: Expression::NONE,
                argument: None,
            }
        }
    }
    pub struct UnaryExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UnaryExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    UnaryExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_operator(&mut self, operator: Operator) {
            self.fbb_.push_slot::<Operator>(
                UnaryExpression::VT_OPERATOR,
                operator,
                Operator::InvalidOperator,
            );
        }
        #[inline]
        pub fn add_argument_type(&mut self, argument_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                UnaryExpression::VT_ARGUMENT_TYPE,
                argument_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_argument(
            &mut self,
            argument: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UnaryExpression::VT_ARGUMENT,
                argument,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UnaryExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UnaryExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnaryExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for UnaryExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("UnaryExpression");
            ds.field("base_node", &self.base_node());
            ds.field("operator", &self.operator());
            ds.field("argument_type", &self.argument_type());
            match self.argument_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.argument_as_string_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.argument_as_paren_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.argument_as_array_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.argument_as_dict_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.argument_as_function_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.argument_as_binary_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.argument_as_boolean_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.argument_as_call_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.argument_as_conditional_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.argument_as_date_time_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.argument_as_duration_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.argument_as_float_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.argument_as_identifier() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.argument_as_integer_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.argument_as_logical_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.argument_as_member_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.argument_as_index_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.argument_as_object_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.argument_as_pipe_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.argument_as_pipe_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.argument_as_regexp_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.argument_as_string_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.argument_as_unary_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.argument_as_unsigned_integer_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.argument_as_bad_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("argument", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum BooleanLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BooleanLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BooleanLiteral<'a> {
        type Inner = BooleanLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> BooleanLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BooleanLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BooleanLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<BooleanLiteral<'bldr>> {
            let mut builder = BooleanLiteralBuilder::new(_fbb);
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_value(args.value);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(BooleanLiteral::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn value(&self) -> bool {
            self._tab
                .get::<bool>(BooleanLiteral::VT_VALUE, Some(false))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for BooleanLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<bool>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BooleanLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub value: bool,
    }
    impl<'a> Default for BooleanLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            BooleanLiteralArgs {
                base_node: None,
                value: false,
            }
        }
    }
    pub struct BooleanLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BooleanLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    BooleanLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: bool) {
            self.fbb_
                .push_slot::<bool>(BooleanLiteral::VT_VALUE, value, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BooleanLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BooleanLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BooleanLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for BooleanLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("BooleanLiteral");
            ds.field("base_node", &self.base_node());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum DateTimeLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DateTimeLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DateTimeLiteral<'a> {
        type Inner = DateTimeLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> DateTimeLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DateTimeLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DateTimeLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<DateTimeLiteral<'bldr>> {
            let mut builder = DateTimeLiteralBuilder::new(_fbb);
            builder.add_secs(args.secs);
            builder.add_offset(args.offset);
            builder.add_nsecs(args.nsecs);
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_SECS: flatbuffers::VOffsetT = 6;
        pub const VT_NSECS: flatbuffers::VOffsetT = 8;
        pub const VT_OFFSET: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(DateTimeLiteral::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn secs(&self) -> i64 {
            self._tab
                .get::<i64>(DateTimeLiteral::VT_SECS, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn nsecs(&self) -> u32 {
            self._tab
                .get::<u32>(DateTimeLiteral::VT_NSECS, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn offset(&self) -> i32 {
            self._tab
                .get::<i32>(DateTimeLiteral::VT_OFFSET, Some(0))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for DateTimeLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<i64>(&"secs", Self::VT_SECS, false)?
                .visit_field::<u32>(&"nsecs", Self::VT_NSECS, false)?
                .visit_field::<i32>(&"offset", Self::VT_OFFSET, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DateTimeLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub secs: i64,
        pub nsecs: u32,
        pub offset: i32,
    }
    impl<'a> Default for DateTimeLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            DateTimeLiteralArgs {
                base_node: None,
                secs: 0,
                nsecs: 0,
                offset: 0,
            }
        }
    }
    pub struct DateTimeLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DateTimeLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    DateTimeLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_secs(&mut self, secs: i64) {
            self.fbb_
                .push_slot::<i64>(DateTimeLiteral::VT_SECS, secs, 0);
        }
        #[inline]
        pub fn add_nsecs(&mut self, nsecs: u32) {
            self.fbb_
                .push_slot::<u32>(DateTimeLiteral::VT_NSECS, nsecs, 0);
        }
        #[inline]
        pub fn add_offset(&mut self, offset: i32) {
            self.fbb_
                .push_slot::<i32>(DateTimeLiteral::VT_OFFSET, offset, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DateTimeLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DateTimeLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DateTimeLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for DateTimeLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("DateTimeLiteral");
            ds.field("base_node", &self.base_node());
            ds.field("secs", &self.secs());
            ds.field("nsecs", &self.nsecs());
            ds.field("offset", &self.offset());
            ds.finish()
        }
    }
    pub enum DurationLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DurationLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DurationLiteral<'a> {
        type Inner = DurationLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> DurationLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DurationLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DurationLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<DurationLiteral<'bldr>> {
            let mut builder = DurationLiteralBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_VALUES: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(DurationLiteral::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Duration<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Duration>>,
            >>(DurationLiteral::VT_VALUES, None)
        }
    }

    impl flatbuffers::Verifiable for DurationLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Duration>>,
                >>(&"values", Self::VT_VALUES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DurationLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Duration<'a>>>,
            >,
        >,
    }
    impl<'a> Default for DurationLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            DurationLiteralArgs {
                base_node: None,
                values: None,
            }
        }
    }
    pub struct DurationLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DurationLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    DurationLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Duration<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DurationLiteral::VT_VALUES, values);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DurationLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DurationLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DurationLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for DurationLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("DurationLiteral");
            ds.field("base_node", &self.base_node());
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    pub enum DurationOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Duration<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Duration<'a> {
        type Inner = Duration<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Duration<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Duration { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DurationArgs,
        ) -> flatbuffers::WIPOffset<Duration<'bldr>> {
            let mut builder = DurationBuilder::new(_fbb);
            builder.add_magnitude(args.magnitude);
            builder.add_unit(args.unit);
            builder.finish()
        }

        pub const VT_MAGNITUDE: flatbuffers::VOffsetT = 4;
        pub const VT_UNIT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn magnitude(&self) -> i64 {
            self._tab
                .get::<i64>(Duration::VT_MAGNITUDE, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn unit(&self) -> TimeUnit {
            self._tab
                .get::<TimeUnit>(Duration::VT_UNIT, Some(TimeUnit::y))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for Duration<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i64>(&"magnitude", Self::VT_MAGNITUDE, false)?
                .visit_field::<TimeUnit>(&"unit", Self::VT_UNIT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DurationArgs {
        pub magnitude: i64,
        pub unit: TimeUnit,
    }
    impl<'a> Default for DurationArgs {
        #[inline]
        fn default() -> Self {
            DurationArgs {
                magnitude: 0,
                unit: TimeUnit::y,
            }
        }
    }
    pub struct DurationBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DurationBuilder<'a, 'b> {
        #[inline]
        pub fn add_magnitude(&mut self, magnitude: i64) {
            self.fbb_
                .push_slot::<i64>(Duration::VT_MAGNITUDE, magnitude, 0);
        }
        #[inline]
        pub fn add_unit(&mut self, unit: TimeUnit) {
            self.fbb_
                .push_slot::<TimeUnit>(Duration::VT_UNIT, unit, TimeUnit::y);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DurationBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DurationBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Duration<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Duration<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Duration");
            ds.field("magnitude", &self.magnitude());
            ds.field("unit", &self.unit());
            ds.finish()
        }
    }
    pub enum FloatLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FloatLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FloatLiteral<'a> {
        type Inner = FloatLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> FloatLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FloatLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FloatLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<FloatLiteral<'bldr>> {
            let mut builder = FloatLiteralBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(FloatLiteral::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn value(&self) -> f64 {
            self._tab
                .get::<f64>(FloatLiteral::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for FloatLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<f64>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct FloatLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub value: f64,
    }
    impl<'a> Default for FloatLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            FloatLiteralArgs {
                base_node: None,
                value: 0.0,
            }
        }
    }
    pub struct FloatLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FloatLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    FloatLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: f64) {
            self.fbb_
                .push_slot::<f64>(FloatLiteral::VT_VALUE, value, 0.0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FloatLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FloatLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FloatLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for FloatLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("FloatLiteral");
            ds.field("base_node", &self.base_node());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum IntegerLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct IntegerLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for IntegerLiteral<'a> {
        type Inner = IntegerLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> IntegerLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            IntegerLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IntegerLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<IntegerLiteral<'bldr>> {
            let mut builder = IntegerLiteralBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(IntegerLiteral::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn value(&self) -> i64 {
            self._tab
                .get::<i64>(IntegerLiteral::VT_VALUE, Some(0))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for IntegerLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<i64>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct IntegerLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub value: i64,
    }
    impl<'a> Default for IntegerLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            IntegerLiteralArgs {
                base_node: None,
                value: 0,
            }
        }
    }
    pub struct IntegerLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IntegerLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    IntegerLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: i64) {
            self.fbb_
                .push_slot::<i64>(IntegerLiteral::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> IntegerLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IntegerLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<IntegerLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for IntegerLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("IntegerLiteral");
            ds.field("base_node", &self.base_node());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum PipeLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PipeLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PipeLiteral<'a> {
        type Inner = PipeLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> PipeLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PipeLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PipeLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<PipeLiteral<'bldr>> {
            let mut builder = PipeLiteralBuilder::new(_fbb);
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(PipeLiteral::VT_BASE_NODE, None)
        }
    }

    impl flatbuffers::Verifiable for PipeLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PipeLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
    }
    impl<'a> Default for PipeLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            PipeLiteralArgs { base_node: None }
        }
    }
    pub struct PipeLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PipeLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    PipeLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PipeLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PipeLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PipeLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for PipeLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("PipeLiteral");
            ds.field("base_node", &self.base_node());
            ds.finish()
        }
    }
    pub enum RegexpLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RegexpLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RegexpLiteral<'a> {
        type Inner = RegexpLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> RegexpLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RegexpLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RegexpLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<RegexpLiteral<'bldr>> {
            let mut builder = RegexpLiteralBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(RegexpLiteral::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn value(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(RegexpLiteral::VT_VALUE, None)
        }
    }

    impl flatbuffers::Verifiable for RegexpLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RegexpLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for RegexpLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            RegexpLiteralArgs {
                base_node: None,
                value: None,
            }
        }
    }
    pub struct RegexpLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RegexpLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    RegexpLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(RegexpLiteral::VT_VALUE, value);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> RegexpLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RegexpLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RegexpLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for RegexpLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("RegexpLiteral");
            ds.field("base_node", &self.base_node());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum StringLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct StringLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StringLiteral<'a> {
        type Inner = StringLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> StringLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StringLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StringLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<StringLiteral<'bldr>> {
            let mut builder = StringLiteralBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(StringLiteral::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn value(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(StringLiteral::VT_VALUE, None)
        }
    }

    impl flatbuffers::Verifiable for StringLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct StringLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for StringLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            StringLiteralArgs {
                base_node: None,
                value: None,
            }
        }
    }
    pub struct StringLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StringLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    StringLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(StringLiteral::VT_VALUE, value);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> StringLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StringLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StringLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for StringLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("StringLiteral");
            ds.field("base_node", &self.base_node());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum UnsignedIntegerLiteralOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UnsignedIntegerLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnsignedIntegerLiteral<'a> {
        type Inner = UnsignedIntegerLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> UnsignedIntegerLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnsignedIntegerLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UnsignedIntegerLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<UnsignedIntegerLiteral<'bldr>> {
            let mut builder = UnsignedIntegerLiteralBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode>>(
                UnsignedIntegerLiteral::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn value(&self) -> u64 {
            self._tab
                .get::<u64>(UnsignedIntegerLiteral::VT_VALUE, Some(0))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for UnsignedIntegerLiteral<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<u64>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UnsignedIntegerLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub value: u64,
    }
    impl<'a> Default for UnsignedIntegerLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            UnsignedIntegerLiteralArgs {
                base_node: None,
                value: 0,
            }
        }
    }
    pub struct UnsignedIntegerLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UnsignedIntegerLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    UnsignedIntegerLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_
                .push_slot::<u64>(UnsignedIntegerLiteral::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UnsignedIntegerLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UnsignedIntegerLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnsignedIntegerLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for UnsignedIntegerLiteral<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("UnsignedIntegerLiteral");
            ds.field("base_node", &self.base_node());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum IdentifierOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Identifier<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Identifier<'a> {
        type Inner = Identifier<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Identifier<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Identifier { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IdentifierArgs<'args>,
        ) -> flatbuffers::WIPOffset<Identifier<'bldr>> {
            let mut builder = IdentifierBuilder::new(_fbb);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(Identifier::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Identifier::VT_NAME, None)
        }
    }

    impl flatbuffers::Verifiable for Identifier<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
                .finish();
            Ok(())
        }
    }
    pub struct IdentifierArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for IdentifierArgs<'a> {
        #[inline]
        fn default() -> Self {
            IdentifierArgs {
                base_node: None,
                name: None,
            }
        }
    }
    pub struct IdentifierBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IdentifierBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    Identifier::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Identifier::VT_NAME, name);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IdentifierBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IdentifierBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Identifier<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Identifier<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Identifier");
            ds.field("base_node", &self.base_node());
            ds.field("name", &self.name());
            ds.finish()
        }
    }
    pub enum StringExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct StringExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StringExpression<'a> {
        type Inner = StringExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> StringExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StringExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StringExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<StringExpression<'bldr>> {
            let mut builder = StringExpressionBuilder::new(_fbb);
            if let Some(x) = args.parts {
                builder.add_parts(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_PARTS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(StringExpression::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn parts(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringExpressionPart<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringExpressionPart>>,
            >>(StringExpression::VT_PARTS, None)
        }
    }

    impl flatbuffers::Verifiable for StringExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringExpressionPart>>,
                >>(&"parts", Self::VT_PARTS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct StringExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub parts: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringExpressionPart<'a>>>,
            >,
        >,
    }
    impl<'a> Default for StringExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            StringExpressionArgs {
                base_node: None,
                parts: None,
            }
        }
    }
    pub struct StringExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StringExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    StringExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_parts(
            &mut self,
            parts: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<StringExpressionPart<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(StringExpression::VT_PARTS, parts);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> StringExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StringExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StringExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for StringExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("StringExpression");
            ds.field("base_node", &self.base_node());
            ds.field("parts", &self.parts());
            ds.finish()
        }
    }
    pub enum StringExpressionPartOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct StringExpressionPart<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StringExpressionPart<'a> {
        type Inner = StringExpressionPart<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> StringExpressionPart<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StringExpressionPart { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StringExpressionPartArgs<'args>,
        ) -> flatbuffers::WIPOffset<StringExpressionPart<'bldr>> {
            let mut builder = StringExpressionPartBuilder::new(_fbb);
            if let Some(x) = args.interpolated_expression {
                builder.add_interpolated_expression(x);
            }
            if let Some(x) = args.text_value {
                builder.add_text_value(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_interpolated_expression_type(args.interpolated_expression_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_TEXT_VALUE: flatbuffers::VOffsetT = 6;
        pub const VT_INTERPOLATED_EXPRESSION_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_INTERPOLATED_EXPRESSION: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode>>(
                StringExpressionPart::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn text_value(&self) -> Option<&'a str> {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                StringExpressionPart::VT_TEXT_VALUE,
                None,
            )
        }
        #[inline]
        pub fn interpolated_expression_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    StringExpressionPart::VT_INTERPOLATED_EXPRESSION_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn interpolated_expression(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    StringExpressionPart::VT_INTERPOLATED_EXPRESSION,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.interpolated_expression_type() == Expression::StringExpression {
                self.interpolated_expression()
                    .map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.interpolated_expression_type() == Expression::ParenExpression {
                self.interpolated_expression()
                    .map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.interpolated_expression_type() == Expression::ArrayExpression {
                self.interpolated_expression()
                    .map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.interpolated_expression_type() == Expression::DictExpression {
                self.interpolated_expression()
                    .map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_function_expression(
            &self,
        ) -> Option<FunctionExpression<'a>> {
            if self.interpolated_expression_type() == Expression::FunctionExpression {
                self.interpolated_expression()
                    .map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.interpolated_expression_type() == Expression::BinaryExpression {
                self.interpolated_expression()
                    .map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::BooleanLiteral {
                self.interpolated_expression()
                    .map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.interpolated_expression_type() == Expression::CallExpression {
                self.interpolated_expression()
                    .map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_conditional_expression(
            &self,
        ) -> Option<ConditionalExpression<'a>> {
            if self.interpolated_expression_type() == Expression::ConditionalExpression {
                self.interpolated_expression()
                    .map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::DateTimeLiteral {
                self.interpolated_expression()
                    .map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::DurationLiteral {
                self.interpolated_expression()
                    .map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::FloatLiteral {
                self.interpolated_expression()
                    .map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.interpolated_expression_type() == Expression::Identifier {
                self.interpolated_expression()
                    .map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::IntegerLiteral {
                self.interpolated_expression()
                    .map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_logical_expression(
            &self,
        ) -> Option<LogicalExpression<'a>> {
            if self.interpolated_expression_type() == Expression::LogicalExpression {
                self.interpolated_expression()
                    .map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.interpolated_expression_type() == Expression::MemberExpression {
                self.interpolated_expression()
                    .map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.interpolated_expression_type() == Expression::IndexExpression {
                self.interpolated_expression()
                    .map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.interpolated_expression_type() == Expression::ObjectExpression {
                self.interpolated_expression()
                    .map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.interpolated_expression_type() == Expression::PipeExpression {
                self.interpolated_expression()
                    .map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::PipeLiteral {
                self.interpolated_expression()
                    .map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::RegexpLiteral {
                self.interpolated_expression()
                    .map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::StringLiteral {
                self.interpolated_expression()
                    .map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.interpolated_expression_type() == Expression::UnaryExpression {
                self.interpolated_expression()
                    .map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_unsigned_integer_literal(
            &self,
        ) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::UnsignedIntegerLiteral {
                self.interpolated_expression()
                    .map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.interpolated_expression_type() == Expression::BadExpression {
                self.interpolated_expression()
                    .map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for StringExpressionPart<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"text_value", Self::VT_TEXT_VALUE, false)?
     .visit_union::<Expression, _>(&"interpolated_expression_type", Self::VT_INTERPOLATED_EXPRESSION_TYPE, &"interpolated_expression", Self::VT_INTERPOLATED_EXPRESSION, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct StringExpressionPartArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub text_value: Option<flatbuffers::WIPOffset<&'a str>>,
        pub interpolated_expression_type: Expression,
        pub interpolated_expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for StringExpressionPartArgs<'a> {
        #[inline]
        fn default() -> Self {
            StringExpressionPartArgs {
                base_node: None,
                text_value: None,
                interpolated_expression_type: Expression::NONE,
                interpolated_expression: None,
            }
        }
    }
    pub struct StringExpressionPartBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StringExpressionPartBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    StringExpressionPart::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_text_value(&mut self, text_value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                StringExpressionPart::VT_TEXT_VALUE,
                text_value,
            );
        }
        #[inline]
        pub fn add_interpolated_expression_type(
            &mut self,
            interpolated_expression_type: Expression,
        ) {
            self.fbb_.push_slot::<Expression>(
                StringExpressionPart::VT_INTERPOLATED_EXPRESSION_TYPE,
                interpolated_expression_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_interpolated_expression(
            &mut self,
            interpolated_expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                StringExpressionPart::VT_INTERPOLATED_EXPRESSION,
                interpolated_expression,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> StringExpressionPartBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StringExpressionPartBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StringExpressionPart<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for StringExpressionPart<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("StringExpressionPart");
            ds.field("base_node", &self.base_node());
            ds.field("text_value", &self.text_value());
            ds.field(
                "interpolated_expression_type",
                &self.interpolated_expression_type(),
            );
            match self.interpolated_expression_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.interpolated_expression_as_string_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.interpolated_expression_as_paren_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.interpolated_expression_as_array_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.interpolated_expression_as_dict_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.interpolated_expression_as_function_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.interpolated_expression_as_binary_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.interpolated_expression_as_boolean_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.interpolated_expression_as_call_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.interpolated_expression_as_conditional_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.interpolated_expression_as_date_time_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.interpolated_expression_as_duration_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.interpolated_expression_as_float_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.interpolated_expression_as_identifier() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.interpolated_expression_as_integer_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.interpolated_expression_as_logical_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.interpolated_expression_as_member_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.interpolated_expression_as_index_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.interpolated_expression_as_object_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.interpolated_expression_as_pipe_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.interpolated_expression_as_pipe_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.interpolated_expression_as_regexp_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.interpolated_expression_as_string_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.interpolated_expression_as_unary_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.interpolated_expression_as_unsigned_integer_literal() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.interpolated_expression_as_bad_expression() {
                        ds.field("interpolated_expression", &x)
                    } else {
                        ds.field(
                            "interpolated_expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("interpolated_expression", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum ParenExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ParenExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ParenExpression<'a> {
        type Inner = ParenExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ParenExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ParenExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ParenExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<ParenExpression<'bldr>> {
            let mut builder = ParenExpressionBuilder::new(_fbb);
            if let Some(x) = args.expression {
                builder.add_expression(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_expression_type(args.expression_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_EXPRESSION_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_EXPRESSION: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(ParenExpression::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn expression_type(&self) -> Expression {
            self._tab
                .get::<Expression>(ParenExpression::VT_EXPRESSION_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn expression(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ParenExpression::VT_EXPRESSION,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.expression_type() == Expression::StringExpression {
                self.expression().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.expression_type() == Expression::ParenExpression {
                self.expression().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.expression_type() == Expression::ArrayExpression {
                self.expression().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.expression_type() == Expression::DictExpression {
                self.expression().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.expression_type() == Expression::FunctionExpression {
                self.expression().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.expression_type() == Expression::BinaryExpression {
                self.expression().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.expression_type() == Expression::BooleanLiteral {
                self.expression().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.expression_type() == Expression::CallExpression {
                self.expression().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.expression_type() == Expression::ConditionalExpression {
                self.expression()
                    .map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.expression_type() == Expression::DateTimeLiteral {
                self.expression().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.expression_type() == Expression::DurationLiteral {
                self.expression().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.expression_type() == Expression::FloatLiteral {
                self.expression().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.expression_type() == Expression::Identifier {
                self.expression().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.expression_type() == Expression::IntegerLiteral {
                self.expression().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.expression_type() == Expression::LogicalExpression {
                self.expression().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.expression_type() == Expression::MemberExpression {
                self.expression().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.expression_type() == Expression::IndexExpression {
                self.expression().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.expression_type() == Expression::ObjectExpression {
                self.expression().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.expression_type() == Expression::PipeExpression {
                self.expression().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.expression_type() == Expression::PipeLiteral {
                self.expression().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.expression_type() == Expression::RegexpLiteral {
                self.expression().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.expression_type() == Expression::StringLiteral {
                self.expression().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.expression_type() == Expression::UnaryExpression {
                self.expression().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.expression_type() == Expression::UnsignedIntegerLiteral {
                self.expression()
                    .map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.expression_type() == Expression::BadExpression {
                self.expression().map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ParenExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_union::<Expression, _>(&"expression_type", Self::VT_EXPRESSION_TYPE, &"expression", Self::VT_EXPRESSION, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct ParenExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub expression_type: Expression,
        pub expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ParenExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            ParenExpressionArgs {
                base_node: None,
                expression_type: Expression::NONE,
                expression: None,
            }
        }
    }
    pub struct ParenExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ParenExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ParenExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_expression_type(&mut self, expression_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ParenExpression::VT_EXPRESSION_TYPE,
                expression_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_expression(
            &mut self,
            expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ParenExpression::VT_EXPRESSION,
                expression,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ParenExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ParenExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ParenExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ParenExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ParenExpression");
            ds.field("base_node", &self.base_node());
            ds.field("expression_type", &self.expression_type());
            match self.expression_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.expression_as_string_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.expression_as_paren_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.expression_as_array_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.expression_as_dict_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.expression_as_function_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.expression_as_binary_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.expression_as_boolean_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.expression_as_call_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.expression_as_conditional_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.expression_as_date_time_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.expression_as_duration_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.expression_as_float_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.expression_as_identifier() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.expression_as_integer_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.expression_as_logical_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.expression_as_member_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.expression_as_index_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.expression_as_object_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.expression_as_pipe_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.expression_as_pipe_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.expression_as_regexp_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.expression_as_string_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.expression_as_unary_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.expression_as_unsigned_integer_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.expression_as_bad_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("expression", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum ArrayExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ArrayExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ArrayExpression<'a> {
        type Inner = ArrayExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ArrayExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ArrayExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ArrayExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<ArrayExpression<'bldr>> {
            let mut builder = ArrayExpressionBuilder::new(_fbb);
            if let Some(x) = args.elements {
                builder.add_elements(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ELEMENTS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(ArrayExpression::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn elements(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedExpression<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedExpression>>,
            >>(ArrayExpression::VT_ELEMENTS, None)
        }
    }

    impl flatbuffers::Verifiable for ArrayExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WrappedExpression>>,
                >>(&"elements", Self::VT_ELEMENTS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ArrayExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub elements: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedExpression<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ArrayExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            ArrayExpressionArgs {
                base_node: None,
                elements: None,
            }
        }
    }
    pub struct ArrayExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ArrayExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ArrayExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_elements(
            &mut self,
            elements: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<WrappedExpression<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ArrayExpression::VT_ELEMENTS,
                elements,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ArrayExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ArrayExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ArrayExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ArrayExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ArrayExpression");
            ds.field("base_node", &self.base_node());
            ds.field("elements", &self.elements());
            ds.finish()
        }
    }
    pub enum DictExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DictExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DictExpression<'a> {
        type Inner = DictExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> DictExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DictExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DictExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<DictExpression<'bldr>> {
            let mut builder = DictExpressionBuilder::new(_fbb);
            if let Some(x) = args.elements {
                builder.add_elements(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ELEMENTS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(DictExpression::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn elements(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DictItem<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DictItem>>,
            >>(DictExpression::VT_ELEMENTS, None)
        }
    }

    impl flatbuffers::Verifiable for DictExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DictItem>>,
                >>(&"elements", Self::VT_ELEMENTS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DictExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub elements: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DictItem<'a>>>,
            >,
        >,
    }
    impl<'a> Default for DictExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            DictExpressionArgs {
                base_node: None,
                elements: None,
            }
        }
    }
    pub struct DictExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DictExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    DictExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_elements(
            &mut self,
            elements: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DictItem<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                DictExpression::VT_ELEMENTS,
                elements,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DictExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DictExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DictExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for DictExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("DictExpression");
            ds.field("base_node", &self.base_node());
            ds.field("elements", &self.elements());
            ds.finish()
        }
    }
    pub enum DictItemOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DictItem<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DictItem<'a> {
        type Inner = DictItem<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> DictItem<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DictItem { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DictItemArgs,
        ) -> flatbuffers::WIPOffset<DictItem<'bldr>> {
            let mut builder = DictItemBuilder::new(_fbb);
            if let Some(x) = args.val {
                builder.add_val(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.add_val_type(args.val_type);
            builder.add_key_type(args.key_type);
            builder.finish()
        }

        pub const VT_KEY_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_KEY: flatbuffers::VOffsetT = 6;
        pub const VT_VAL_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_VAL: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn key_type(&self) -> Expression {
            self._tab
                .get::<Expression>(DictItem::VT_KEY_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn key(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DictItem::VT_KEY, None)
        }
        #[inline]
        pub fn val_type(&self) -> Expression {
            self._tab
                .get::<Expression>(DictItem::VT_VAL_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn val(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DictItem::VT_VAL, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.key_type() == Expression::StringExpression {
                self.key().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.key_type() == Expression::ParenExpression {
                self.key().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.key_type() == Expression::ArrayExpression {
                self.key().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.key_type() == Expression::DictExpression {
                self.key().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.key_type() == Expression::FunctionExpression {
                self.key().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.key_type() == Expression::BinaryExpression {
                self.key().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.key_type() == Expression::BooleanLiteral {
                self.key().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.key_type() == Expression::CallExpression {
                self.key().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.key_type() == Expression::ConditionalExpression {
                self.key().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.key_type() == Expression::DateTimeLiteral {
                self.key().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.key_type() == Expression::DurationLiteral {
                self.key().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.key_type() == Expression::FloatLiteral {
                self.key().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.key_type() == Expression::Identifier {
                self.key().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.key_type() == Expression::IntegerLiteral {
                self.key().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.key_type() == Expression::LogicalExpression {
                self.key().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.key_type() == Expression::MemberExpression {
                self.key().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.key_type() == Expression::IndexExpression {
                self.key().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.key_type() == Expression::ObjectExpression {
                self.key().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.key_type() == Expression::PipeExpression {
                self.key().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.key_type() == Expression::PipeLiteral {
                self.key().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.key_type() == Expression::RegexpLiteral {
                self.key().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.key_type() == Expression::StringLiteral {
                self.key().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.key_type() == Expression::UnaryExpression {
                self.key().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.key_type() == Expression::UnsignedIntegerLiteral {
                self.key().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.key_type() == Expression::BadExpression {
                self.key().map(BadExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.val_type() == Expression::StringExpression {
                self.val().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.val_type() == Expression::ParenExpression {
                self.val().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.val_type() == Expression::ArrayExpression {
                self.val().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.val_type() == Expression::DictExpression {
                self.val().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.val_type() == Expression::FunctionExpression {
                self.val().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.val_type() == Expression::BinaryExpression {
                self.val().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.val_type() == Expression::BooleanLiteral {
                self.val().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.val_type() == Expression::CallExpression {
                self.val().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.val_type() == Expression::ConditionalExpression {
                self.val().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.val_type() == Expression::DateTimeLiteral {
                self.val().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.val_type() == Expression::DurationLiteral {
                self.val().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.val_type() == Expression::FloatLiteral {
                self.val().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.val_type() == Expression::Identifier {
                self.val().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.val_type() == Expression::IntegerLiteral {
                self.val().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.val_type() == Expression::LogicalExpression {
                self.val().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.val_type() == Expression::MemberExpression {
                self.val().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.val_type() == Expression::IndexExpression {
                self.val().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.val_type() == Expression::ObjectExpression {
                self.val().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.val_type() == Expression::PipeExpression {
                self.val().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.val_type() == Expression::PipeLiteral {
                self.val().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.val_type() == Expression::RegexpLiteral {
                self.val().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.val_type() == Expression::StringLiteral {
                self.val().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.val_type() == Expression::UnaryExpression {
                self.val().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.val_type() == Expression::UnsignedIntegerLiteral {
                self.val().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn val_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.val_type() == Expression::BadExpression {
                self.val().map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for DictItem<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_union::<Expression, _>(&"key_type", Self::VT_KEY_TYPE, &"key", Self::VT_KEY, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Expression, _>(&"val_type", Self::VT_VAL_TYPE, &"val", Self::VT_VAL, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct DictItemArgs {
        pub key_type: Expression,
        pub key: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub val_type: Expression,
        pub val: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for DictItemArgs {
        #[inline]
        fn default() -> Self {
            DictItemArgs {
                key_type: Expression::NONE,
                key: None,
                val_type: Expression::NONE,
                val: None,
            }
        }
    }
    pub struct DictItemBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DictItemBuilder<'a, 'b> {
        #[inline]
        pub fn add_key_type(&mut self, key_type: Expression) {
            self.fbb_
                .push_slot::<Expression>(DictItem::VT_KEY_TYPE, key_type, Expression::NONE);
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DictItem::VT_KEY, key);
        }
        #[inline]
        pub fn add_val_type(&mut self, val_type: Expression) {
            self.fbb_
                .push_slot::<Expression>(DictItem::VT_VAL_TYPE, val_type, Expression::NONE);
        }
        #[inline]
        pub fn add_val(&mut self, val: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DictItem::VT_VAL, val);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DictItemBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DictItemBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DictItem<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for DictItem<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("DictItem");
            ds.field("key_type", &self.key_type());
            match self.key_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.key_as_string_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.key_as_paren_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.key_as_array_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.key_as_dict_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.key_as_function_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.key_as_binary_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.key_as_boolean_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.key_as_call_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.key_as_conditional_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.key_as_date_time_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.key_as_duration_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.key_as_float_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.key_as_identifier() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.key_as_integer_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.key_as_logical_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.key_as_member_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.key_as_index_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.key_as_object_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.key_as_pipe_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.key_as_pipe_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.key_as_regexp_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.key_as_string_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.key_as_unary_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.key_as_unsigned_integer_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.key_as_bad_expression() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("key", &x)
                }
            };
            ds.field("val_type", &self.val_type());
            match self.val_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.val_as_string_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.val_as_paren_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.val_as_array_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.val_as_dict_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.val_as_function_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.val_as_binary_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.val_as_boolean_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.val_as_call_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.val_as_conditional_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.val_as_date_time_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.val_as_duration_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.val_as_float_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.val_as_identifier() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.val_as_integer_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.val_as_logical_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.val_as_member_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.val_as_index_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.val_as_object_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.val_as_pipe_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.val_as_pipe_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.val_as_regexp_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.val_as_string_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.val_as_unary_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.val_as_unsigned_integer_literal() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.val_as_bad_expression() {
                        ds.field("val", &x)
                    } else {
                        ds.field(
                            "val",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("val", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum FunctionExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FunctionExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FunctionExpression<'a> {
        type Inner = FunctionExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> FunctionExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FunctionExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FunctionExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<FunctionExpression<'bldr>> {
            let mut builder = FunctionExpressionBuilder::new(_fbb);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.params {
                builder.add_params(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_body_type(args.body_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_PARAMS: flatbuffers::VOffsetT = 6;
        pub const VT_BODY_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_BODY: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode>>(
                FunctionExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn params(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>,
            >>(FunctionExpression::VT_PARAMS, None)
        }
        #[inline]
        pub fn body_type(&self) -> ExpressionOrBlock {
            self._tab
                .get::<ExpressionOrBlock>(
                    FunctionExpression::VT_BODY_TYPE,
                    Some(ExpressionOrBlock::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn body(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    FunctionExpression::VT_BODY,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_block(&self) -> Option<Block<'a>> {
            if self.body_type() == ExpressionOrBlock::Block {
                self.body().map(Block::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_wrapped_expression(&self) -> Option<WrappedExpression<'a>> {
            if self.body_type() == ExpressionOrBlock::WrappedExpression {
                self.body().map(WrappedExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for FunctionExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>(&"params", Self::VT_PARAMS, false)?
     .visit_union::<ExpressionOrBlock, _>(&"body_type", Self::VT_BODY_TYPE, &"body", Self::VT_BODY, false, |key, v, pos| {
        match key {
          ExpressionOrBlock::Block => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Block>>("ExpressionOrBlock::Block", pos),
          ExpressionOrBlock::WrappedExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WrappedExpression>>("ExpressionOrBlock::WrappedExpression", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct FunctionExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub params: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>,
            >,
        >,
        pub body_type: ExpressionOrBlock,
        pub body: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for FunctionExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            FunctionExpressionArgs {
                base_node: None,
                params: None,
                body_type: ExpressionOrBlock::NONE,
                body: None,
            }
        }
    }
    pub struct FunctionExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FunctionExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    FunctionExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_params(
            &mut self,
            params: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Property<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                FunctionExpression::VT_PARAMS,
                params,
            );
        }
        #[inline]
        pub fn add_body_type(&mut self, body_type: ExpressionOrBlock) {
            self.fbb_.push_slot::<ExpressionOrBlock>(
                FunctionExpression::VT_BODY_TYPE,
                body_type,
                ExpressionOrBlock::NONE,
            );
        }
        #[inline]
        pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionExpression::VT_BODY, body);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FunctionExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FunctionExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FunctionExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for FunctionExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("FunctionExpression");
            ds.field("base_node", &self.base_node());
            ds.field("params", &self.params());
            ds.field("body_type", &self.body_type());
            match self.body_type() {
                ExpressionOrBlock::Block => {
                    if let Some(x) = self.body_as_block() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ExpressionOrBlock::WrappedExpression => {
                    if let Some(x) = self.body_as_wrapped_expression() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("body", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum BlockOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Block<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Block<'a> {
        type Inner = Block<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Block<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Block { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BlockArgs<'args>,
        ) -> flatbuffers::WIPOffset<Block<'bldr>> {
            let mut builder = BlockBuilder::new(_fbb);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_BODY: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(Block::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn body(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement>>,
            >>(Block::VT_BODY, None)
        }
    }

    impl flatbuffers::Verifiable for Block<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WrappedStatement>>,
                >>(&"body", Self::VT_BODY, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BlockArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub body: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>,
            >,
        >,
    }
    impl<'a> Default for BlockArgs<'a> {
        #[inline]
        fn default() -> Self {
            BlockArgs {
                base_node: None,
                body: None,
            }
        }
    }
    pub struct BlockBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BlockBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    Block::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_body(
            &mut self,
            body: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<WrappedStatement<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_BODY, body);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BlockBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Block<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Block<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Block");
            ds.field("base_node", &self.base_node());
            ds.field("body", &self.body());
            ds.finish()
        }
    }
    pub enum CallExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CallExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CallExpression<'a> {
        type Inner = CallExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> CallExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CallExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CallExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<CallExpression<'bldr>> {
            let mut builder = CallExpressionBuilder::new(_fbb);
            if let Some(x) = args.arguments {
                builder.add_arguments(x);
            }
            if let Some(x) = args.callee {
                builder.add_callee(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_callee_type(args.callee_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_CALLEE_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_CALLEE: flatbuffers::VOffsetT = 8;
        pub const VT_ARGUMENTS: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(CallExpression::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn callee_type(&self) -> Expression {
            self._tab
                .get::<Expression>(CallExpression::VT_CALLEE_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn callee(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    CallExpression::VT_CALLEE,
                    None,
                )
        }
        #[inline]
        pub fn arguments(&self) -> Option<ObjectExpression<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<ObjectExpression>>(
                    CallExpression::VT_ARGUMENTS,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.callee_type() == Expression::StringExpression {
                self.callee().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.callee_type() == Expression::ParenExpression {
                self.callee().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.callee_type() == Expression::ArrayExpression {
                self.callee().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.callee_type() == Expression::DictExpression {
                self.callee().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.callee_type() == Expression::FunctionExpression {
                self.callee().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.callee_type() == Expression::BinaryExpression {
                self.callee().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.callee_type() == Expression::BooleanLiteral {
                self.callee().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.callee_type() == Expression::CallExpression {
                self.callee().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.callee_type() == Expression::ConditionalExpression {
                self.callee().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.callee_type() == Expression::DateTimeLiteral {
                self.callee().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.callee_type() == Expression::DurationLiteral {
                self.callee().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.callee_type() == Expression::FloatLiteral {
                self.callee().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.callee_type() == Expression::Identifier {
                self.callee().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.callee_type() == Expression::IntegerLiteral {
                self.callee().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.callee_type() == Expression::LogicalExpression {
                self.callee().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.callee_type() == Expression::MemberExpression {
                self.callee().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.callee_type() == Expression::IndexExpression {
                self.callee().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.callee_type() == Expression::ObjectExpression {
                self.callee().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.callee_type() == Expression::PipeExpression {
                self.callee().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.callee_type() == Expression::PipeLiteral {
                self.callee().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.callee_type() == Expression::RegexpLiteral {
                self.callee().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.callee_type() == Expression::StringLiteral {
                self.callee().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.callee_type() == Expression::UnaryExpression {
                self.callee().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.callee_type() == Expression::UnsignedIntegerLiteral {
                self.callee().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.callee_type() == Expression::BadExpression {
                self.callee().map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for CallExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_union::<Expression, _>(&"callee_type", Self::VT_CALLEE_TYPE, &"callee", Self::VT_CALLEE, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<ObjectExpression>>(&"arguments", Self::VT_ARGUMENTS, false)?
     .finish();
            Ok(())
        }
    }
    pub struct CallExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub callee_type: Expression,
        pub callee: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub arguments: Option<flatbuffers::WIPOffset<ObjectExpression<'a>>>,
    }
    impl<'a> Default for CallExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            CallExpressionArgs {
                base_node: None,
                callee_type: Expression::NONE,
                callee: None,
                arguments: None,
            }
        }
    }
    pub struct CallExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CallExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    CallExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_callee_type(&mut self, callee_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                CallExpression::VT_CALLEE_TYPE,
                callee_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_callee(&mut self, callee: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CallExpression::VT_CALLEE, callee);
        }
        #[inline]
        pub fn add_arguments(&mut self, arguments: flatbuffers::WIPOffset<ObjectExpression<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<ObjectExpression>>(
                    CallExpression::VT_ARGUMENTS,
                    arguments,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CallExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CallExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CallExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for CallExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("CallExpression");
            ds.field("base_node", &self.base_node());
            ds.field("callee_type", &self.callee_type());
            match self.callee_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.callee_as_string_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.callee_as_paren_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.callee_as_array_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.callee_as_dict_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.callee_as_function_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.callee_as_binary_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.callee_as_boolean_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.callee_as_call_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.callee_as_conditional_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.callee_as_date_time_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.callee_as_duration_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.callee_as_float_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.callee_as_identifier() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.callee_as_integer_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.callee_as_logical_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.callee_as_member_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.callee_as_index_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.callee_as_object_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.callee_as_pipe_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.callee_as_pipe_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.callee_as_regexp_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.callee_as_string_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.callee_as_unary_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.callee_as_unsigned_integer_literal() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.callee_as_bad_expression() {
                        ds.field("callee", &x)
                    } else {
                        ds.field(
                            "callee",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("callee", &x)
                }
            };
            ds.field("arguments", &self.arguments());
            ds.finish()
        }
    }
    pub enum ConditionalExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ConditionalExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ConditionalExpression<'a> {
        type Inner = ConditionalExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ConditionalExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ConditionalExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ConditionalExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<ConditionalExpression<'bldr>> {
            let mut builder = ConditionalExpressionBuilder::new(_fbb);
            if let Some(x) = args.alternate {
                builder.add_alternate(x);
            }
            if let Some(x) = args.consequent {
                builder.add_consequent(x);
            }
            if let Some(x) = args.test {
                builder.add_test(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_alternate_type(args.alternate_type);
            builder.add_consequent_type(args.consequent_type);
            builder.add_test_type(args.test_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_TEST_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_TEST: flatbuffers::VOffsetT = 8;
        pub const VT_CONSEQUENT_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_CONSEQUENT: flatbuffers::VOffsetT = 12;
        pub const VT_ALTERNATE_TYPE: flatbuffers::VOffsetT = 14;
        pub const VT_ALTERNATE: flatbuffers::VOffsetT = 16;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode>>(
                ConditionalExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn test_type(&self) -> Expression {
            self._tab
                .get::<Expression>(ConditionalExpression::VT_TEST_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn test(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConditionalExpression::VT_TEST,
                    None,
                )
        }
        #[inline]
        pub fn consequent_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    ConditionalExpression::VT_CONSEQUENT_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn consequent(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConditionalExpression::VT_CONSEQUENT,
                    None,
                )
        }
        #[inline]
        pub fn alternate_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    ConditionalExpression::VT_ALTERNATE_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn alternate(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConditionalExpression::VT_ALTERNATE,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.test_type() == Expression::StringExpression {
                self.test().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.test_type() == Expression::ParenExpression {
                self.test().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.test_type() == Expression::ArrayExpression {
                self.test().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.test_type() == Expression::DictExpression {
                self.test().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.test_type() == Expression::FunctionExpression {
                self.test().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.test_type() == Expression::BinaryExpression {
                self.test().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.test_type() == Expression::BooleanLiteral {
                self.test().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.test_type() == Expression::CallExpression {
                self.test().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.test_type() == Expression::ConditionalExpression {
                self.test().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.test_type() == Expression::DateTimeLiteral {
                self.test().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.test_type() == Expression::DurationLiteral {
                self.test().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.test_type() == Expression::FloatLiteral {
                self.test().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.test_type() == Expression::Identifier {
                self.test().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.test_type() == Expression::IntegerLiteral {
                self.test().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.test_type() == Expression::LogicalExpression {
                self.test().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.test_type() == Expression::MemberExpression {
                self.test().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.test_type() == Expression::IndexExpression {
                self.test().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.test_type() == Expression::ObjectExpression {
                self.test().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.test_type() == Expression::PipeExpression {
                self.test().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.test_type() == Expression::PipeLiteral {
                self.test().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.test_type() == Expression::RegexpLiteral {
                self.test().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.test_type() == Expression::StringLiteral {
                self.test().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.test_type() == Expression::UnaryExpression {
                self.test().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.test_type() == Expression::UnsignedIntegerLiteral {
                self.test().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.test_type() == Expression::BadExpression {
                self.test().map(BadExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.consequent_type() == Expression::StringExpression {
                self.consequent().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.consequent_type() == Expression::ParenExpression {
                self.consequent().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.consequent_type() == Expression::ArrayExpression {
                self.consequent().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.consequent_type() == Expression::DictExpression {
                self.consequent().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.consequent_type() == Expression::FunctionExpression {
                self.consequent().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.consequent_type() == Expression::BinaryExpression {
                self.consequent().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.consequent_type() == Expression::BooleanLiteral {
                self.consequent().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.consequent_type() == Expression::CallExpression {
                self.consequent().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.consequent_type() == Expression::ConditionalExpression {
                self.consequent()
                    .map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.consequent_type() == Expression::DateTimeLiteral {
                self.consequent().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.consequent_type() == Expression::DurationLiteral {
                self.consequent().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.consequent_type() == Expression::FloatLiteral {
                self.consequent().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.consequent_type() == Expression::Identifier {
                self.consequent().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.consequent_type() == Expression::IntegerLiteral {
                self.consequent().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.consequent_type() == Expression::LogicalExpression {
                self.consequent().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.consequent_type() == Expression::MemberExpression {
                self.consequent().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.consequent_type() == Expression::IndexExpression {
                self.consequent().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.consequent_type() == Expression::ObjectExpression {
                self.consequent().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.consequent_type() == Expression::PipeExpression {
                self.consequent().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.consequent_type() == Expression::PipeLiteral {
                self.consequent().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.consequent_type() == Expression::RegexpLiteral {
                self.consequent().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.consequent_type() == Expression::StringLiteral {
                self.consequent().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.consequent_type() == Expression::UnaryExpression {
                self.consequent().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.consequent_type() == Expression::UnsignedIntegerLiteral {
                self.consequent()
                    .map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.consequent_type() == Expression::BadExpression {
                self.consequent().map(BadExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.alternate_type() == Expression::StringExpression {
                self.alternate().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.alternate_type() == Expression::ParenExpression {
                self.alternate().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.alternate_type() == Expression::ArrayExpression {
                self.alternate().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.alternate_type() == Expression::DictExpression {
                self.alternate().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.alternate_type() == Expression::FunctionExpression {
                self.alternate().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.alternate_type() == Expression::BinaryExpression {
                self.alternate().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.alternate_type() == Expression::BooleanLiteral {
                self.alternate().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.alternate_type() == Expression::CallExpression {
                self.alternate().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.alternate_type() == Expression::ConditionalExpression {
                self.alternate().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.alternate_type() == Expression::DateTimeLiteral {
                self.alternate().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.alternate_type() == Expression::DurationLiteral {
                self.alternate().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.alternate_type() == Expression::FloatLiteral {
                self.alternate().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.alternate_type() == Expression::Identifier {
                self.alternate().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.alternate_type() == Expression::IntegerLiteral {
                self.alternate().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.alternate_type() == Expression::LogicalExpression {
                self.alternate().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.alternate_type() == Expression::MemberExpression {
                self.alternate().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.alternate_type() == Expression::IndexExpression {
                self.alternate().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.alternate_type() == Expression::ObjectExpression {
                self.alternate().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.alternate_type() == Expression::PipeExpression {
                self.alternate().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.alternate_type() == Expression::PipeLiteral {
                self.alternate().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.alternate_type() == Expression::RegexpLiteral {
                self.alternate().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.alternate_type() == Expression::StringLiteral {
                self.alternate().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.alternate_type() == Expression::UnaryExpression {
                self.alternate().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.alternate_type() == Expression::UnsignedIntegerLiteral {
                self.alternate()
                    .map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.alternate_type() == Expression::BadExpression {
                self.alternate().map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ConditionalExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_union::<Expression, _>(&"test_type", Self::VT_TEST_TYPE, &"test", Self::VT_TEST, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Expression, _>(&"consequent_type", Self::VT_CONSEQUENT_TYPE, &"consequent", Self::VT_CONSEQUENT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Expression, _>(&"alternate_type", Self::VT_ALTERNATE_TYPE, &"alternate", Self::VT_ALTERNATE, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct ConditionalExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub test_type: Expression,
        pub test: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub consequent_type: Expression,
        pub consequent: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub alternate_type: Expression,
        pub alternate: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ConditionalExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            ConditionalExpressionArgs {
                base_node: None,
                test_type: Expression::NONE,
                test: None,
                consequent_type: Expression::NONE,
                consequent: None,
                alternate_type: Expression::NONE,
                alternate: None,
            }
        }
    }
    pub struct ConditionalExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ConditionalExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ConditionalExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_test_type(&mut self, test_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ConditionalExpression::VT_TEST_TYPE,
                test_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_test(&mut self, test: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ConditionalExpression::VT_TEST,
                test,
            );
        }
        #[inline]
        pub fn add_consequent_type(&mut self, consequent_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ConditionalExpression::VT_CONSEQUENT_TYPE,
                consequent_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_consequent(
            &mut self,
            consequent: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ConditionalExpression::VT_CONSEQUENT,
                consequent,
            );
        }
        #[inline]
        pub fn add_alternate_type(&mut self, alternate_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ConditionalExpression::VT_ALTERNATE_TYPE,
                alternate_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_alternate(
            &mut self,
            alternate: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ConditionalExpression::VT_ALTERNATE,
                alternate,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ConditionalExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ConditionalExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ConditionalExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ConditionalExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ConditionalExpression");
            ds.field("base_node", &self.base_node());
            ds.field("test_type", &self.test_type());
            match self.test_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.test_as_string_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.test_as_paren_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.test_as_array_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.test_as_dict_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.test_as_function_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.test_as_binary_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.test_as_boolean_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.test_as_call_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.test_as_conditional_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.test_as_date_time_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.test_as_duration_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.test_as_float_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.test_as_identifier() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.test_as_integer_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.test_as_logical_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.test_as_member_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.test_as_index_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.test_as_object_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.test_as_pipe_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.test_as_pipe_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.test_as_regexp_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.test_as_string_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.test_as_unary_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.test_as_unsigned_integer_literal() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.test_as_bad_expression() {
                        ds.field("test", &x)
                    } else {
                        ds.field(
                            "test",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("test", &x)
                }
            };
            ds.field("consequent_type", &self.consequent_type());
            match self.consequent_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.consequent_as_string_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.consequent_as_paren_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.consequent_as_array_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.consequent_as_dict_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.consequent_as_function_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.consequent_as_binary_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.consequent_as_boolean_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.consequent_as_call_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.consequent_as_conditional_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.consequent_as_date_time_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.consequent_as_duration_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.consequent_as_float_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.consequent_as_identifier() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.consequent_as_integer_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.consequent_as_logical_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.consequent_as_member_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.consequent_as_index_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.consequent_as_object_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.consequent_as_pipe_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.consequent_as_pipe_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.consequent_as_regexp_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.consequent_as_string_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.consequent_as_unary_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.consequent_as_unsigned_integer_literal() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.consequent_as_bad_expression() {
                        ds.field("consequent", &x)
                    } else {
                        ds.field(
                            "consequent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("consequent", &x)
                }
            };
            ds.field("alternate_type", &self.alternate_type());
            match self.alternate_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.alternate_as_string_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.alternate_as_paren_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.alternate_as_array_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.alternate_as_dict_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.alternate_as_function_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.alternate_as_binary_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.alternate_as_boolean_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.alternate_as_call_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.alternate_as_conditional_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.alternate_as_date_time_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.alternate_as_duration_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.alternate_as_float_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.alternate_as_identifier() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.alternate_as_integer_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.alternate_as_logical_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.alternate_as_member_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.alternate_as_index_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.alternate_as_object_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.alternate_as_pipe_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.alternate_as_pipe_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.alternate_as_regexp_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.alternate_as_string_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.alternate_as_unary_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.alternate_as_unsigned_integer_literal() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.alternate_as_bad_expression() {
                        ds.field("alternate", &x)
                    } else {
                        ds.field(
                            "alternate",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("alternate", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum PropertyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Property<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Property<'a> {
        type Inner = Property<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Property<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Property { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PropertyArgs<'args>,
        ) -> flatbuffers::WIPOffset<Property<'bldr>> {
            let mut builder = PropertyBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_value_type(args.value_type);
            builder.add_key_type(args.key_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_KEY_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_KEY: flatbuffers::VOffsetT = 8;
        pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_VALUE: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(Property::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn key_type(&self) -> PropertyKey {
            self._tab
                .get::<PropertyKey>(Property::VT_KEY_TYPE, Some(PropertyKey::NONE))
                .unwrap()
        }
        #[inline]
        pub fn key(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Property::VT_KEY, None)
        }
        #[inline]
        pub fn value_type(&self) -> Expression {
            self._tab
                .get::<Expression>(Property::VT_VALUE_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    Property::VT_VALUE,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.key_type() == PropertyKey::Identifier {
                self.key().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.key_type() == PropertyKey::StringLiteral {
                self.key().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.value_type() == Expression::StringExpression {
                self.value().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.value_type() == Expression::ParenExpression {
                self.value().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.value_type() == Expression::ArrayExpression {
                self.value().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.value_type() == Expression::DictExpression {
                self.value().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.value_type() == Expression::FunctionExpression {
                self.value().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.value_type() == Expression::BinaryExpression {
                self.value().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.value_type() == Expression::BooleanLiteral {
                self.value().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.value_type() == Expression::CallExpression {
                self.value().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.value_type() == Expression::ConditionalExpression {
                self.value().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.value_type() == Expression::DateTimeLiteral {
                self.value().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.value_type() == Expression::DurationLiteral {
                self.value().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.value_type() == Expression::FloatLiteral {
                self.value().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.value_type() == Expression::Identifier {
                self.value().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.value_type() == Expression::IntegerLiteral {
                self.value().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.value_type() == Expression::LogicalExpression {
                self.value().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.value_type() == Expression::MemberExpression {
                self.value().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.value_type() == Expression::IndexExpression {
                self.value().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.value_type() == Expression::ObjectExpression {
                self.value().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.value_type() == Expression::PipeExpression {
                self.value().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.value_type() == Expression::PipeLiteral {
                self.value().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.value_type() == Expression::RegexpLiteral {
                self.value().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.value_type() == Expression::StringLiteral {
                self.value().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.value_type() == Expression::UnaryExpression {
                self.value().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.value_type() == Expression::UnsignedIntegerLiteral {
                self.value().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.value_type() == Expression::BadExpression {
                self.value().map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for Property<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_union::<PropertyKey, _>(&"key_type", Self::VT_KEY_TYPE, &"key", Self::VT_KEY, false, |key, v, pos| {
        match key {
          PropertyKey::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("PropertyKey::Identifier", pos),
          PropertyKey::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("PropertyKey::StringLiteral", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Expression, _>(&"value_type", Self::VT_VALUE_TYPE, &"value", Self::VT_VALUE, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct PropertyArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub key_type: PropertyKey,
        pub key: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub value_type: Expression,
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for PropertyArgs<'a> {
        #[inline]
        fn default() -> Self {
            PropertyArgs {
                base_node: None,
                key_type: PropertyKey::NONE,
                key: None,
                value_type: Expression::NONE,
                value: None,
            }
        }
    }
    pub struct PropertyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PropertyBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    Property::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_key_type(&mut self, key_type: PropertyKey) {
            self.fbb_
                .push_slot::<PropertyKey>(Property::VT_KEY_TYPE, key_type, PropertyKey::NONE);
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Property::VT_KEY, key);
        }
        #[inline]
        pub fn add_value_type(&mut self, value_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                Property::VT_VALUE_TYPE,
                value_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Property::VT_VALUE, value);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PropertyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PropertyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Property<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Property<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Property");
            ds.field("base_node", &self.base_node());
            ds.field("key_type", &self.key_type());
            match self.key_type() {
                PropertyKey::Identifier => {
                    if let Some(x) = self.key_as_identifier() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                PropertyKey::StringLiteral => {
                    if let Some(x) = self.key_as_string_literal() {
                        ds.field("key", &x)
                    } else {
                        ds.field(
                            "key",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("key", &x)
                }
            };
            ds.field("value_type", &self.value_type());
            match self.value_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.value_as_string_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.value_as_paren_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.value_as_array_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.value_as_dict_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.value_as_function_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.value_as_binary_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.value_as_boolean_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.value_as_call_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.value_as_conditional_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.value_as_date_time_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.value_as_duration_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.value_as_float_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.value_as_identifier() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.value_as_integer_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.value_as_logical_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.value_as_member_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.value_as_index_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.value_as_object_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.value_as_pipe_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.value_as_pipe_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.value_as_regexp_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.value_as_string_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.value_as_unary_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.value_as_unsigned_integer_literal() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.value_as_bad_expression() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("value", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum MemberExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MemberExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MemberExpression<'a> {
        type Inner = MemberExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> MemberExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MemberExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MemberExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<MemberExpression<'bldr>> {
            let mut builder = MemberExpressionBuilder::new(_fbb);
            if let Some(x) = args.property {
                builder.add_property(x);
            }
            if let Some(x) = args.object {
                builder.add_object(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_property_type(args.property_type);
            builder.add_object_type(args.object_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_OBJECT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_OBJECT: flatbuffers::VOffsetT = 8;
        pub const VT_PROPERTY_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_PROPERTY: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(MemberExpression::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn object_type(&self) -> Expression {
            self._tab
                .get::<Expression>(MemberExpression::VT_OBJECT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn object(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    MemberExpression::VT_OBJECT,
                    None,
                )
        }
        #[inline]
        pub fn property_type(&self) -> PropertyKey {
            self._tab
                .get::<PropertyKey>(MemberExpression::VT_PROPERTY_TYPE, Some(PropertyKey::NONE))
                .unwrap()
        }
        #[inline]
        pub fn property(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    MemberExpression::VT_PROPERTY,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.object_type() == Expression::StringExpression {
                self.object().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.object_type() == Expression::ParenExpression {
                self.object().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.object_type() == Expression::ArrayExpression {
                self.object().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.object_type() == Expression::DictExpression {
                self.object().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.object_type() == Expression::FunctionExpression {
                self.object().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.object_type() == Expression::BinaryExpression {
                self.object().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.object_type() == Expression::BooleanLiteral {
                self.object().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.object_type() == Expression::CallExpression {
                self.object().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.object_type() == Expression::ConditionalExpression {
                self.object().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.object_type() == Expression::DateTimeLiteral {
                self.object().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.object_type() == Expression::DurationLiteral {
                self.object().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.object_type() == Expression::FloatLiteral {
                self.object().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.object_type() == Expression::Identifier {
                self.object().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.object_type() == Expression::IntegerLiteral {
                self.object().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.object_type() == Expression::LogicalExpression {
                self.object().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.object_type() == Expression::MemberExpression {
                self.object().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.object_type() == Expression::IndexExpression {
                self.object().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.object_type() == Expression::ObjectExpression {
                self.object().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.object_type() == Expression::PipeExpression {
                self.object().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.object_type() == Expression::PipeLiteral {
                self.object().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.object_type() == Expression::RegexpLiteral {
                self.object().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.object_type() == Expression::StringLiteral {
                self.object().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.object_type() == Expression::UnaryExpression {
                self.object().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.object_type() == Expression::UnsignedIntegerLiteral {
                self.object().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.object_type() == Expression::BadExpression {
                self.object().map(BadExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn property_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.property_type() == PropertyKey::Identifier {
                self.property().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn property_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.property_type() == PropertyKey::StringLiteral {
                self.property().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for MemberExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_union::<Expression, _>(&"object_type", Self::VT_OBJECT_TYPE, &"object", Self::VT_OBJECT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<PropertyKey, _>(&"property_type", Self::VT_PROPERTY_TYPE, &"property", Self::VT_PROPERTY, false, |key, v, pos| {
        match key {
          PropertyKey::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("PropertyKey::Identifier", pos),
          PropertyKey::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("PropertyKey::StringLiteral", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct MemberExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub object_type: Expression,
        pub object: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub property_type: PropertyKey,
        pub property: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for MemberExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            MemberExpressionArgs {
                base_node: None,
                object_type: Expression::NONE,
                object: None,
                property_type: PropertyKey::NONE,
                property: None,
            }
        }
    }
    pub struct MemberExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MemberExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    MemberExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_object_type(&mut self, object_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                MemberExpression::VT_OBJECT_TYPE,
                object_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_object(&mut self, object: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MemberExpression::VT_OBJECT, object);
        }
        #[inline]
        pub fn add_property_type(&mut self, property_type: PropertyKey) {
            self.fbb_.push_slot::<PropertyKey>(
                MemberExpression::VT_PROPERTY_TYPE,
                property_type,
                PropertyKey::NONE,
            );
        }
        #[inline]
        pub fn add_property(
            &mut self,
            property: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MemberExpression::VT_PROPERTY,
                property,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MemberExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MemberExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MemberExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for MemberExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("MemberExpression");
            ds.field("base_node", &self.base_node());
            ds.field("object_type", &self.object_type());
            match self.object_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.object_as_string_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.object_as_paren_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.object_as_array_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.object_as_dict_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.object_as_function_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.object_as_binary_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.object_as_boolean_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.object_as_call_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.object_as_conditional_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.object_as_date_time_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.object_as_duration_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.object_as_float_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.object_as_identifier() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.object_as_integer_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.object_as_logical_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.object_as_member_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.object_as_index_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.object_as_object_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.object_as_pipe_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.object_as_pipe_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.object_as_regexp_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.object_as_string_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.object_as_unary_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.object_as_unsigned_integer_literal() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.object_as_bad_expression() {
                        ds.field("object", &x)
                    } else {
                        ds.field(
                            "object",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("object", &x)
                }
            };
            ds.field("property_type", &self.property_type());
            match self.property_type() {
                PropertyKey::Identifier => {
                    if let Some(x) = self.property_as_identifier() {
                        ds.field("property", &x)
                    } else {
                        ds.field(
                            "property",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                PropertyKey::StringLiteral => {
                    if let Some(x) = self.property_as_string_literal() {
                        ds.field("property", &x)
                    } else {
                        ds.field(
                            "property",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("property", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum IndexExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct IndexExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for IndexExpression<'a> {
        type Inner = IndexExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> IndexExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            IndexExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IndexExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<IndexExpression<'bldr>> {
            let mut builder = IndexExpressionBuilder::new(_fbb);
            if let Some(x) = args.index {
                builder.add_index(x);
            }
            if let Some(x) = args.array {
                builder.add_array(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_index_type(args.index_type);
            builder.add_array_type(args.array_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ARRAY_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ARRAY: flatbuffers::VOffsetT = 8;
        pub const VT_INDEX_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_INDEX: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(IndexExpression::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn array_type(&self) -> Expression {
            self._tab
                .get::<Expression>(IndexExpression::VT_ARRAY_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn array(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    IndexExpression::VT_ARRAY,
                    None,
                )
        }
        #[inline]
        pub fn index_type(&self) -> Expression {
            self._tab
                .get::<Expression>(IndexExpression::VT_INDEX_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn index(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    IndexExpression::VT_INDEX,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.array_type() == Expression::StringExpression {
                self.array().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.array_type() == Expression::ParenExpression {
                self.array().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.array_type() == Expression::ArrayExpression {
                self.array().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.array_type() == Expression::DictExpression {
                self.array().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.array_type() == Expression::FunctionExpression {
                self.array().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.array_type() == Expression::BinaryExpression {
                self.array().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.array_type() == Expression::BooleanLiteral {
                self.array().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.array_type() == Expression::CallExpression {
                self.array().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.array_type() == Expression::ConditionalExpression {
                self.array().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.array_type() == Expression::DateTimeLiteral {
                self.array().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.array_type() == Expression::DurationLiteral {
                self.array().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.array_type() == Expression::FloatLiteral {
                self.array().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.array_type() == Expression::Identifier {
                self.array().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.array_type() == Expression::IntegerLiteral {
                self.array().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.array_type() == Expression::LogicalExpression {
                self.array().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.array_type() == Expression::MemberExpression {
                self.array().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.array_type() == Expression::IndexExpression {
                self.array().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.array_type() == Expression::ObjectExpression {
                self.array().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.array_type() == Expression::PipeExpression {
                self.array().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.array_type() == Expression::PipeLiteral {
                self.array().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.array_type() == Expression::RegexpLiteral {
                self.array().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.array_type() == Expression::StringLiteral {
                self.array().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.array_type() == Expression::UnaryExpression {
                self.array().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.array_type() == Expression::UnsignedIntegerLiteral {
                self.array().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.array_type() == Expression::BadExpression {
                self.array().map(BadExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.index_type() == Expression::StringExpression {
                self.index().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.index_type() == Expression::ParenExpression {
                self.index().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.index_type() == Expression::ArrayExpression {
                self.index().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.index_type() == Expression::DictExpression {
                self.index().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.index_type() == Expression::FunctionExpression {
                self.index().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.index_type() == Expression::BinaryExpression {
                self.index().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.index_type() == Expression::BooleanLiteral {
                self.index().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.index_type() == Expression::CallExpression {
                self.index().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.index_type() == Expression::ConditionalExpression {
                self.index().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.index_type() == Expression::DateTimeLiteral {
                self.index().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.index_type() == Expression::DurationLiteral {
                self.index().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.index_type() == Expression::FloatLiteral {
                self.index().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.index_type() == Expression::Identifier {
                self.index().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.index_type() == Expression::IntegerLiteral {
                self.index().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.index_type() == Expression::LogicalExpression {
                self.index().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.index_type() == Expression::MemberExpression {
                self.index().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.index_type() == Expression::IndexExpression {
                self.index().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.index_type() == Expression::ObjectExpression {
                self.index().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.index_type() == Expression::PipeExpression {
                self.index().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.index_type() == Expression::PipeLiteral {
                self.index().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.index_type() == Expression::RegexpLiteral {
                self.index().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.index_type() == Expression::StringLiteral {
                self.index().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.index_type() == Expression::UnaryExpression {
                self.index().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.index_type() == Expression::UnsignedIntegerLiteral {
                self.index().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.index_type() == Expression::BadExpression {
                self.index().map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for IndexExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_union::<Expression, _>(&"array_type", Self::VT_ARRAY_TYPE, &"array", Self::VT_ARRAY, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Expression, _>(&"index_type", Self::VT_INDEX_TYPE, &"index", Self::VT_INDEX, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct IndexExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub array_type: Expression,
        pub array: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub index_type: Expression,
        pub index: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for IndexExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            IndexExpressionArgs {
                base_node: None,
                array_type: Expression::NONE,
                array: None,
                index_type: Expression::NONE,
                index: None,
            }
        }
    }
    pub struct IndexExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IndexExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    IndexExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_array_type(&mut self, array_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                IndexExpression::VT_ARRAY_TYPE,
                array_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_array(&mut self, array: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IndexExpression::VT_ARRAY, array);
        }
        #[inline]
        pub fn add_index_type(&mut self, index_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                IndexExpression::VT_INDEX_TYPE,
                index_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_index(&mut self, index: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IndexExpression::VT_INDEX, index);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> IndexExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IndexExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<IndexExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for IndexExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("IndexExpression");
            ds.field("base_node", &self.base_node());
            ds.field("array_type", &self.array_type());
            match self.array_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.array_as_string_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.array_as_paren_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.array_as_array_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.array_as_dict_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.array_as_function_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.array_as_binary_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.array_as_boolean_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.array_as_call_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.array_as_conditional_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.array_as_date_time_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.array_as_duration_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.array_as_float_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.array_as_identifier() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.array_as_integer_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.array_as_logical_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.array_as_member_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.array_as_index_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.array_as_object_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.array_as_pipe_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.array_as_pipe_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.array_as_regexp_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.array_as_string_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.array_as_unary_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.array_as_unsigned_integer_literal() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.array_as_bad_expression() {
                        ds.field("array", &x)
                    } else {
                        ds.field(
                            "array",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("array", &x)
                }
            };
            ds.field("index_type", &self.index_type());
            match self.index_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.index_as_string_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.index_as_paren_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.index_as_array_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.index_as_dict_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.index_as_function_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.index_as_binary_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.index_as_boolean_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.index_as_call_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.index_as_conditional_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.index_as_date_time_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.index_as_duration_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.index_as_float_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.index_as_identifier() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.index_as_integer_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.index_as_logical_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.index_as_member_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.index_as_index_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.index_as_object_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.index_as_pipe_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.index_as_pipe_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.index_as_regexp_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.index_as_string_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.index_as_unary_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.index_as_unsigned_integer_literal() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.index_as_bad_expression() {
                        ds.field("index", &x)
                    } else {
                        ds.field(
                            "index",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("index", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum ObjectExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ObjectExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ObjectExpression<'a> {
        type Inner = ObjectExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ObjectExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ObjectExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ObjectExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<ObjectExpression<'bldr>> {
            let mut builder = ObjectExpressionBuilder::new(_fbb);
            if let Some(x) = args.properties {
                builder.add_properties(x);
            }
            if let Some(x) = args.with {
                builder.add_with(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_WITH: flatbuffers::VOffsetT = 6;
        pub const VT_PROPERTIES: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(ObjectExpression::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn with(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier>>(ObjectExpression::VT_WITH, None)
        }
        #[inline]
        pub fn properties(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>,
            >>(ObjectExpression::VT_PROPERTIES, None)
        }
    }

    impl flatbuffers::Verifiable for ObjectExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(
                    &"base_node",
                    Self::VT_BASE_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>(
                    &"with",
                    Self::VT_WITH,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>,
                >>(&"properties", Self::VT_PROPERTIES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ObjectExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub with: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub properties: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ObjectExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            ObjectExpressionArgs {
                base_node: None,
                with: None,
                properties: None,
            }
        }
    }
    pub struct ObjectExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ObjectExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ObjectExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_with(&mut self, with: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    ObjectExpression::VT_WITH,
                    with,
                );
        }
        #[inline]
        pub fn add_properties(
            &mut self,
            properties: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Property<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ObjectExpression::VT_PROPERTIES,
                properties,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ObjectExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ObjectExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ObjectExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ObjectExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ObjectExpression");
            ds.field("base_node", &self.base_node());
            ds.field("with", &self.with());
            ds.field("properties", &self.properties());
            ds.finish()
        }
    }
    pub enum PipeExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PipeExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PipeExpression<'a> {
        type Inner = PipeExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> PipeExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PipeExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PipeExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<PipeExpression<'bldr>> {
            let mut builder = PipeExpressionBuilder::new(_fbb);
            if let Some(x) = args.call {
                builder.add_call(x);
            }
            if let Some(x) = args.argument {
                builder.add_argument(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_argument_type(args.argument_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ARGUMENT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ARGUMENT: flatbuffers::VOffsetT = 8;
        pub const VT_CALL: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(PipeExpression::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn argument_type(&self) -> Expression {
            self._tab
                .get::<Expression>(PipeExpression::VT_ARGUMENT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn argument(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    PipeExpression::VT_ARGUMENT,
                    None,
                )
        }
        #[inline]
        pub fn call(&self) -> Option<CallExpression<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<CallExpression>>(PipeExpression::VT_CALL, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.argument_type() == Expression::StringExpression {
                self.argument().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.argument_type() == Expression::ParenExpression {
                self.argument().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.argument_type() == Expression::ArrayExpression {
                self.argument().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.argument_type() == Expression::DictExpression {
                self.argument().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.argument_type() == Expression::FunctionExpression {
                self.argument().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.argument_type() == Expression::BinaryExpression {
                self.argument().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.argument_type() == Expression::BooleanLiteral {
                self.argument().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.argument_type() == Expression::CallExpression {
                self.argument().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.argument_type() == Expression::ConditionalExpression {
                self.argument().map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.argument_type() == Expression::DateTimeLiteral {
                self.argument().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.argument_type() == Expression::DurationLiteral {
                self.argument().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.argument_type() == Expression::FloatLiteral {
                self.argument().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.argument_type() == Expression::Identifier {
                self.argument().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.argument_type() == Expression::IntegerLiteral {
                self.argument().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.argument_type() == Expression::LogicalExpression {
                self.argument().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.argument_type() == Expression::MemberExpression {
                self.argument().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.argument_type() == Expression::IndexExpression {
                self.argument().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.argument_type() == Expression::ObjectExpression {
                self.argument().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.argument_type() == Expression::PipeExpression {
                self.argument().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.argument_type() == Expression::PipeLiteral {
                self.argument().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.argument_type() == Expression::RegexpLiteral {
                self.argument().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.argument_type() == Expression::StringLiteral {
                self.argument().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.argument_type() == Expression::UnaryExpression {
                self.argument().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.argument_type() == Expression::UnsignedIntegerLiteral {
                self.argument().map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.argument_type() == Expression::BadExpression {
                self.argument().map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for PipeExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_union::<Expression, _>(&"argument_type", Self::VT_ARGUMENT_TYPE, &"argument", Self::VT_ARGUMENT, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<CallExpression>>(&"call", Self::VT_CALL, false)?
     .finish();
            Ok(())
        }
    }
    pub struct PipeExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub argument_type: Expression,
        pub argument: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub call: Option<flatbuffers::WIPOffset<CallExpression<'a>>>,
    }
    impl<'a> Default for PipeExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            PipeExpressionArgs {
                base_node: None,
                argument_type: Expression::NONE,
                argument: None,
                call: None,
            }
        }
    }
    pub struct PipeExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PipeExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    PipeExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_argument_type(&mut self, argument_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                PipeExpression::VT_ARGUMENT_TYPE,
                argument_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_argument(
            &mut self,
            argument: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                PipeExpression::VT_ARGUMENT,
                argument,
            );
        }
        #[inline]
        pub fn add_call(&mut self, call: flatbuffers::WIPOffset<CallExpression<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<CallExpression>>(
                    PipeExpression::VT_CALL,
                    call,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> PipeExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PipeExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PipeExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for PipeExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("PipeExpression");
            ds.field("base_node", &self.base_node());
            ds.field("argument_type", &self.argument_type());
            match self.argument_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.argument_as_string_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.argument_as_paren_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.argument_as_array_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.argument_as_dict_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.argument_as_function_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.argument_as_binary_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.argument_as_boolean_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.argument_as_call_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.argument_as_conditional_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.argument_as_date_time_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.argument_as_duration_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.argument_as_float_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.argument_as_identifier() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.argument_as_integer_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.argument_as_logical_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.argument_as_member_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.argument_as_index_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.argument_as_object_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.argument_as_pipe_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.argument_as_pipe_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.argument_as_regexp_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.argument_as_string_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.argument_as_unary_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.argument_as_unsigned_integer_literal() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.argument_as_bad_expression() {
                        ds.field("argument", &x)
                    } else {
                        ds.field(
                            "argument",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("argument", &x)
                }
            };
            ds.field("call", &self.call());
            ds.finish()
        }
    }
    pub enum BadExpressionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BadExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BadExpression<'a> {
        type Inner = BadExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> BadExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BadExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BadExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<BadExpression<'bldr>> {
            let mut builder = BadExpressionBuilder::new(_fbb);
            if let Some(x) = args.expression {
                builder.add_expression(x);
            }
            if let Some(x) = args.text {
                builder.add_text(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_expression_type(args.expression_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_TEXT: flatbuffers::VOffsetT = 6;
        pub const VT_EXPRESSION_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_EXPRESSION: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode>>(BadExpression::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn text(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(BadExpression::VT_TEXT, None)
        }
        #[inline]
        pub fn expression_type(&self) -> Expression {
            self._tab
                .get::<Expression>(BadExpression::VT_EXPRESSION_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn expression(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    BadExpression::VT_EXPRESSION,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.expression_type() == Expression::StringExpression {
                self.expression().map(StringExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.expression_type() == Expression::ParenExpression {
                self.expression().map(ParenExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.expression_type() == Expression::ArrayExpression {
                self.expression().map(ArrayExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_dict_expression(&self) -> Option<DictExpression<'a>> {
            if self.expression_type() == Expression::DictExpression {
                self.expression().map(DictExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.expression_type() == Expression::FunctionExpression {
                self.expression().map(FunctionExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.expression_type() == Expression::BinaryExpression {
                self.expression().map(BinaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.expression_type() == Expression::BooleanLiteral {
                self.expression().map(BooleanLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.expression_type() == Expression::CallExpression {
                self.expression().map(CallExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.expression_type() == Expression::ConditionalExpression {
                self.expression()
                    .map(ConditionalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.expression_type() == Expression::DateTimeLiteral {
                self.expression().map(DateTimeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.expression_type() == Expression::DurationLiteral {
                self.expression().map(DurationLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.expression_type() == Expression::FloatLiteral {
                self.expression().map(FloatLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.expression_type() == Expression::Identifier {
                self.expression().map(Identifier::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.expression_type() == Expression::IntegerLiteral {
                self.expression().map(IntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.expression_type() == Expression::LogicalExpression {
                self.expression().map(LogicalExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.expression_type() == Expression::MemberExpression {
                self.expression().map(MemberExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.expression_type() == Expression::IndexExpression {
                self.expression().map(IndexExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.expression_type() == Expression::ObjectExpression {
                self.expression().map(ObjectExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.expression_type() == Expression::PipeExpression {
                self.expression().map(PipeExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.expression_type() == Expression::PipeLiteral {
                self.expression().map(PipeLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.expression_type() == Expression::RegexpLiteral {
                self.expression().map(RegexpLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.expression_type() == Expression::StringLiteral {
                self.expression().map(StringLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.expression_type() == Expression::UnaryExpression {
                self.expression().map(UnaryExpression::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.expression_type() == Expression::UnsignedIntegerLiteral {
                self.expression()
                    .map(UnsignedIntegerLiteral::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.expression_type() == Expression::BadExpression {
                self.expression().map(BadExpression::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for BadExpression<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseNode>>(&"base_node", Self::VT_BASE_NODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"text", Self::VT_TEXT, false)?
     .visit_union::<Expression, _>(&"expression_type", Self::VT_EXPRESSION_TYPE, &"expression", Self::VT_EXPRESSION, false, |key, v, pos| {
        match key {
          Expression::StringExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringExpression>>("Expression::StringExpression", pos),
          Expression::ParenExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParenExpression>>("Expression::ParenExpression", pos),
          Expression::ArrayExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayExpression>>("Expression::ArrayExpression", pos),
          Expression::DictExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DictExpression>>("Expression::DictExpression", pos),
          Expression::FunctionExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionExpression>>("Expression::FunctionExpression", pos),
          Expression::BinaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryExpression>>("Expression::BinaryExpression", pos),
          Expression::BooleanLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BooleanLiteral>>("Expression::BooleanLiteral", pos),
          Expression::CallExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallExpression>>("Expression::CallExpression", pos),
          Expression::ConditionalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConditionalExpression>>("Expression::ConditionalExpression", pos),
          Expression::DateTimeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DateTimeLiteral>>("Expression::DateTimeLiteral", pos),
          Expression::DurationLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationLiteral>>("Expression::DurationLiteral", pos),
          Expression::FloatLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatLiteral>>("Expression::FloatLiteral", pos),
          Expression::Identifier => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Identifier>>("Expression::Identifier", pos),
          Expression::IntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntegerLiteral>>("Expression::IntegerLiteral", pos),
          Expression::LogicalExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalExpression>>("Expression::LogicalExpression", pos),
          Expression::MemberExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MemberExpression>>("Expression::MemberExpression", pos),
          Expression::IndexExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndexExpression>>("Expression::IndexExpression", pos),
          Expression::ObjectExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectExpression>>("Expression::ObjectExpression", pos),
          Expression::PipeExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeExpression>>("Expression::PipeExpression", pos),
          Expression::PipeLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PipeLiteral>>("Expression::PipeLiteral", pos),
          Expression::RegexpLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexpLiteral>>("Expression::RegexpLiteral", pos),
          Expression::StringLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringLiteral>>("Expression::StringLiteral", pos),
          Expression::UnaryExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnaryExpression>>("Expression::UnaryExpression", pos),
          Expression::UnsignedIntegerLiteral => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsignedIntegerLiteral>>("Expression::UnsignedIntegerLiteral", pos),
          Expression::BadExpression => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BadExpression>>("Expression::BadExpression", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct BadExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub text: Option<flatbuffers::WIPOffset<&'a str>>,
        pub expression_type: Expression,
        pub expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for BadExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            BadExpressionArgs {
                base_node: None,
                text: None,
                expression_type: Expression::NONE,
                expression: None,
            }
        }
    }
    pub struct BadExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BadExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    BadExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BadExpression::VT_TEXT, text);
        }
        #[inline]
        pub fn add_expression_type(&mut self, expression_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                BadExpression::VT_EXPRESSION_TYPE,
                expression_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_expression(
            &mut self,
            expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BadExpression::VT_EXPRESSION,
                expression,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BadExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BadExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BadExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for BadExpression<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("BadExpression");
            ds.field("base_node", &self.base_node());
            ds.field("text", &self.text());
            ds.field("expression_type", &self.expression_type());
            match self.expression_type() {
                Expression::StringExpression => {
                    if let Some(x) = self.expression_as_string_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ParenExpression => {
                    if let Some(x) = self.expression_as_paren_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ArrayExpression => {
                    if let Some(x) = self.expression_as_array_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DictExpression => {
                    if let Some(x) = self.expression_as_dict_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FunctionExpression => {
                    if let Some(x) = self.expression_as_function_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BinaryExpression => {
                    if let Some(x) = self.expression_as_binary_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BooleanLiteral => {
                    if let Some(x) = self.expression_as_boolean_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::CallExpression => {
                    if let Some(x) = self.expression_as_call_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ConditionalExpression => {
                    if let Some(x) = self.expression_as_conditional_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DateTimeLiteral => {
                    if let Some(x) = self.expression_as_date_time_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::DurationLiteral => {
                    if let Some(x) = self.expression_as_duration_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::FloatLiteral => {
                    if let Some(x) = self.expression_as_float_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::Identifier => {
                    if let Some(x) = self.expression_as_identifier() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IntegerLiteral => {
                    if let Some(x) = self.expression_as_integer_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::LogicalExpression => {
                    if let Some(x) = self.expression_as_logical_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::MemberExpression => {
                    if let Some(x) = self.expression_as_member_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::IndexExpression => {
                    if let Some(x) = self.expression_as_index_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::ObjectExpression => {
                    if let Some(x) = self.expression_as_object_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeExpression => {
                    if let Some(x) = self.expression_as_pipe_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::PipeLiteral => {
                    if let Some(x) = self.expression_as_pipe_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::RegexpLiteral => {
                    if let Some(x) = self.expression_as_regexp_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::StringLiteral => {
                    if let Some(x) = self.expression_as_string_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnaryExpression => {
                    if let Some(x) = self.expression_as_unary_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::UnsignedIntegerLiteral => {
                    if let Some(x) = self.expression_as_unsigned_integer_literal() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Expression::BadExpression => {
                    if let Some(x) = self.expression_as_bad_expression() {
                        ds.field("expression", &x)
                    } else {
                        ds.field(
                            "expression",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("expression", &x)
                }
            };
            ds.finish()
        }
    }
    #[inline]
    #[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
    pub fn get_root_as_package<'a>(buf: &'a [u8]) -> Package<'a> {
        unsafe { flatbuffers::root_unchecked::<Package<'a>>(buf) }
    }

    #[inline]
    #[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
    pub fn get_size_prefixed_root_as_package<'a>(buf: &'a [u8]) -> Package<'a> {
        unsafe { flatbuffers::size_prefixed_root_unchecked::<Package<'a>>(buf) }
    }

    #[inline]
    /// Verifies that a buffer of bytes contains a `Package`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_package_unchecked`.
    pub fn root_as_package(buf: &[u8]) -> Result<Package, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<Package>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `Package` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_package_unchecked`.
    pub fn size_prefixed_root_as_package(
        buf: &[u8],
    ) -> Result<Package, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<Package>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `Package` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_package_unchecked`.
    pub fn root_as_package_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Package<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<Package<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `Package` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_package_unchecked`.
    pub fn size_prefixed_root_as_package_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Package<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<Package<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a Package and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `Package`.
    pub unsafe fn root_as_package_unchecked(buf: &[u8]) -> Package {
        flatbuffers::root_unchecked::<Package>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed Package and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `Package`.
    pub unsafe fn size_prefixed_root_as_package_unchecked(buf: &[u8]) -> Package {
        flatbuffers::size_prefixed_root_unchecked::<Package>(buf)
    }
    #[inline]
    pub fn finish_package_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Package<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_package_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Package<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod fbast

use std::fmt;

#[derive(Clone, Copy, Debug, Hash, Eq, PartialEq)]
pub enum TokenType {
    Illegal,
    Eof,
    Comment,

    // Reserved keywords->
    And,
    Or,
    Not,
    Empty,
    In,
    Import,
    Package,
    Return,
    Option,
    Builtin,
    Test,
    TestCase,
    If,
    Then,
    Else,

    // Identifiers and literals->
    Ident,
    Int,
    Float,
    String,
    Regex,
    Time,
    Duration,

    // Operators->
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    Pow,
    Eq,
    Lt,
    Gt,
    Lte,
    Gte,
    Neq,
    RegexEq,
    RegexNeq,
    Assign,
    Arrow,
    LParen,
    RParen,
    LBrack,
    RBrack,
    LBrace,
    RBrace,
    Comma,
    Dot,
    Colon,
    PipeForward,
    PipeReceive,
    Exists,

    // String expression tokens->
    Quote,
    StringExpr,
    Text,

    QuestionMark,
}

impl fmt::Display for TokenType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TokenType::Illegal => write!(f, "ILLEGAL"),
            TokenType::Eof => write!(f, "EOF"),
            TokenType::Comment => write!(f, "COMMENT"),
            TokenType::And => write!(f, "AND"),
            TokenType::Or => write!(f, "OR"),
            TokenType::Not => write!(f, "NOT"),
            TokenType::Empty => write!(f, "EMPTY"),
            TokenType::In => write!(f, "IN"),
            TokenType::Import => write!(f, "IMPORT"),
            TokenType::Package => write!(f, "PACKAGE"),
            TokenType::Return => write!(f, "RETURN"),
            TokenType::Option => write!(f, "OPTION"),
            TokenType::Builtin => write!(f, "BUILTIN"),
            TokenType::Test => write!(f, "TEST"),
            TokenType::TestCase => write!(f, "TESTCASE"),
            TokenType::If => write!(f, "IF"),
            TokenType::Then => write!(f, "THEN"),
            TokenType::Else => write!(f, "ELSE"),
            TokenType::Ident => write!(f, "IDENT"),
            TokenType::Int => write!(f, "INT"),
            TokenType::Float => write!(f, "FLOAT"),
            TokenType::String => write!(f, "STRING"),
            TokenType::Regex => write!(f, "REGEX"),
            TokenType::Time => write!(f, "TIME"),
            TokenType::Duration => write!(f, "DURATION"),
            TokenType::Add => write!(f, "ADD"),
            TokenType::Sub => write!(f, "SUB"),
            TokenType::Mul => write!(f, "MUL"),
            TokenType::Div => write!(f, "DIV"),
            TokenType::Mod => write!(f, "MOD"),
            TokenType::Pow => write!(f, "POW"),
            TokenType::Eq => write!(f, "EQ"),
            TokenType::Lt => write!(f, "LT"),
            TokenType::Gt => write!(f, "GT"),
            TokenType::Lte => write!(f, "LTE"),
            TokenType::Gte => write!(f, "GTE"),
            TokenType::Neq => write!(f, "NEQ"),
            TokenType::RegexEq => write!(f, "REGEXEQ"),
            TokenType::RegexNeq => write!(f, "REGEXNEQ"),
            TokenType::Assign => write!(f, "ASSIGN"),
            TokenType::Arrow => write!(f, "ARROW"),
            TokenType::LParen => write!(f, "LPAREN"),
            TokenType::RParen => write!(f, "RPAREN"),
            TokenType::LBrack => write!(f, "LBRACK"),
            TokenType::RBrack => write!(f, "RBRACK"),
            TokenType::LBrace => write!(f, "LBRACE"),
            TokenType::RBrace => write!(f, "RBRACE"),
            TokenType::Comma => write!(f, "COMMA"),
            TokenType::Dot => write!(f, "DOT"),
            TokenType::Colon => write!(f, "COLON"),
            TokenType::QuestionMark => write!(f, "QUESTION_MARK"),
            TokenType::PipeForward => write!(f, "PIPE_FORWARD"),
            TokenType::PipeReceive => write!(f, "PIPE_RECEIVE"),
            TokenType::Exists => write!(f, "EXISTS"),
            TokenType::Quote => write!(f, "QUOTE"),
            TokenType::StringExpr => write!(f, "STRINGEXPR"),
            TokenType::Text => write!(f, "TEXT"),
        }
    }
}

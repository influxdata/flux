{"path":"","name":"main","values":[],"packages":[{"path":"slack","name":"slack","values":[{"name":"validateColorString","doc":"","typ":"(color:string) => string"},{"name":"defaultURL","doc":"","typ":"string"},{"name":"message","doc":"","typ":"(channel:A, color:string, text:B, ?token:string, ?url:string) => int"},{"name":"endpoint","doc":"","typ":"(?token:string, ?url:string) => (mapFn:(r:A) => {B with text:D, color:string, channel:C}) => (<-tables:[A]) => [{A with _sent:string}]"}],"packages":[]},{"path":"json","name":"json","values":[{"name":"encode","doc":"// encode converts a value into JSON bytes\n// Time values are encoded using RFC3339.\n// Duration values are encoded in number of milleseconds since the epoch.\n// Regexp values are encoded as their string representation.\n// Bytes values are encodes as base64-encoded strings.\n// Function values cannot be encoded and will produce an error.\n","typ":"(v:A) => bytes"}],"packages":[]},{"path":"profiler","name":"profiler","values":[{"name":"enabledProfilers","doc":"// EnabledProfilers sets a list of profilers that should be enabled during execution\n// Available profilers are:\n//   query - Profiles time spent in the various phases of query execution\n//   operator - Profiles time spent in each operator of the query\n","typ":"[string]"}],"packages":[]},{"path":"http","name":"http","values":[{"name":"post","doc":"// Post submits an HTTP post request to the specified URL with headers and data.\n// The HTTP status code is returned.\n","typ":"(url:string, ?data:bytes, ?headers:A) => int"},{"name":"basicAuth","doc":"// basicAuth will take a username/password combination and return the authorization\n// header value.\n","typ":"(p:string, u:string) => string"},{"name":"pathEscape","doc":"// PathEscape escapes the string so it can be safely placed inside a URL path segment\n// replacing special characters (including /) with %XX sequences as needed.\n","typ":"(inputString:string) => string"},{"name":"endpoint","doc":"","typ":"(url:string) => (mapFn:(r:A) => {B with headers:C, data:bytes}) => (<-tables:[A]) => [{A with _sent:string}]"}],"packages":[]},{"path":"strings","name":"strings","values":[{"name":"title","doc":"// Transformation functions\n","typ":"(v:string) => string"},{"name":"toUpper","doc":"","typ":"(v:string) => string"},{"name":"toLower","doc":"","typ":"(v:string) => string"},{"name":"trim","doc":"","typ":"(cutset:string, v:string) => string"},{"name":"trimPrefix","doc":"","typ":"(prefix:string, v:string) => string"},{"name":"trimSpace","doc":"","typ":"(v:string) => string"},{"name":"trimSuffix","doc":"","typ":"(suffix:string, v:string) => string"},{"name":"trimRight","doc":"","typ":"(cutset:string, v:string) => string"},{"name":"trimLeft","doc":"","typ":"(cutset:string, v:string) => string"},{"name":"toTitle","doc":"","typ":"(v:string) => string"},{"name":"hasPrefix","doc":"","typ":"(prefix:string, v:string) => bool"},{"name":"hasSuffix","doc":"","typ":"(suffix:string, v:string) => bool"},{"name":"containsStr","doc":"","typ":"(substr:string, v:string) => bool"},{"name":"containsAny","doc":"","typ":"(chars:string, v:string) => bool"},{"name":"equalFold","doc":"","typ":"(t:string, v:string) => bool"},{"name":"compare","doc":"","typ":"(t:string, v:string) => int"},{"name":"countStr","doc":"","typ":"(substr:string, v:string) => int"},{"name":"index","doc":"","typ":"(substr:string, v:string) => int"},{"name":"indexAny","doc":"","typ":"(chars:string, v:string) => int"},{"name":"lastIndex","doc":"","typ":"(substr:string, v:string) => int"},{"name":"lastIndexAny","doc":"","typ":"(chars:string, v:string) => int"},{"name":"isDigit","doc":"","typ":"(v:string) => bool"},{"name":"isLetter","doc":"","typ":"(v:string) => bool"},{"name":"isLower","doc":"","typ":"(v:string) => bool"},{"name":"isUpper","doc":"","typ":"(v:string) => bool"},{"name":"repeat","doc":"","typ":"(i:int, v:string) => string"},{"name":"replace","doc":"","typ":"(i:int, t:string, u:string, v:string) => string"},{"name":"replaceAll","doc":"","typ":"(t:string, u:string, v:string) => string"},{"name":"split","doc":"","typ":"(t:string, v:string) => [string]"},{"name":"splitAfter","doc":"","typ":"(t:string, v:string) => [string]"},{"name":"splitN","doc":"","typ":"(n:int, t:string, v:string) => [string]"},{"name":"splitAfterN","doc":"","typ":"(i:int, t:string, v:string) => [string]"},{"name":"joinStr","doc":"","typ":"(arr:[string], v:string) => string"},{"name":"strlen","doc":"","typ":"(v:string) => int"},{"name":"substring","doc":"","typ":"(end:int, start:int, v:string) => string"}],"packages":[]},{"path":"internal","name":"internal","values":[],"packages":[{"path":"internal/influxql","name":"influxql","values":[{"name":"epoch","doc":"","typ":"time"},{"name":"minTime","doc":"","typ":"time"},{"name":"maxTime","doc":"","typ":"time"}],"packages":[]},{"path":"internal/gen","name":"gen","values":[{"name":"tables","doc":"","typ":"(n:int, ?nulls:float, ?tags:[{name:string, cardinality:int}]) => [{A with _value:float, _time:time}]"}],"packages":[]},{"path":"internal/testutil","name":"testutil","values":[{"name":"fail","doc":"","typ":"() => bool"},{"name":"yield","doc":"","typ":"(<-v:A) => A"},{"name":"makeRecord","doc":"","typ":"(o:A) => B"}],"packages":[]},{"path":"internal/promql","name":"promql","values":[{"name":"changes","doc":"// changes() implements functionality equivalent to PromQL's changes() function:\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#changes\n","typ":"(<-tables:[{A with _value:float}]) => [{B with _value:float}]"},{"name":"promqlDayOfMonth","doc":"// promqlDayOfMonth() implements functionality equivalent to PromQL's day_of_month() function:\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#day_of_month\n","typ":"(timestamp:float) => float"},{"name":"promqlDayOfWeek","doc":"// promqlDayOfWeek() implements functionality equivalent to PromQL's day_of_week() function:\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#day_of_week\n","typ":"(timestamp:float) => float"},{"name":"promqlDaysInMonth","doc":"// promqlDaysInMonth() implements functionality equivalent to PromQL's days_in_month() function:\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#days_in_month\n","typ":"(timestamp:float) => float"},{"name":"emptyTable","doc":"// emptyTable() returns an empty table, which is used as a helper function to implement\n// PromQL's time() and vector() functions:\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#time\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#vector\n","typ":"() => [{_value:float, _time:time, _stop:time, _start:time}]"},{"name":"extrapolatedRate","doc":"// extrapolatedRate() is a helper function that calculates extrapolated rates over\n// counters and is used to implement PromQL's rate(), delta(), and increase() functions.\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#rate\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#increase\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#delta\n","typ":"(<-tables:[{A with _value:float, _time:time, _stop:time, _start:time}], ?isCounter:bool, ?isRate:bool) => [{B with _value:float}]"},{"name":"holtWinters","doc":"// holtWinters() implements functionality equivalent to PromQL's holt_winters()\n// function:\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#holt_winters\n","typ":"(<-tables:[{A with _value:float, _time:time}], ?smoothingFactor:float, ?trendFactor:float) => [{B with _value:float}]"},{"name":"promqlHour","doc":"// promqlHour() implements functionality equivalent to PromQL's hour() function:\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#hour\n","typ":"(timestamp:float) => float"},{"name":"instantRate","doc":"// instantRate() is a helper function that calculates instant rates over\n// counters and is used to implement PromQL's irate() and idelta() functions.\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#irate\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#idelta\n","typ":"(<-tables:[{A with _value:float, _time:time}], ?isRate:bool) => [{B with _value:float}]"},{"name":"labelReplace","doc":"// labelReplace implements functionality equivalent to PromQL's label_replace() function:\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#label_replace\n","typ":"(<-tables:[{A with _value:float}], destination:string, regex:string, replacement:string, source:string) => [{B with _value:float}]"},{"name":"linearRegression","doc":"// linearRegression implements linear regression functionality required to implement\n// PromQL's deriv() and predict_linear() functions:\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#deriv\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#predict_linear\n","typ":"(<-tables:[{A with _value:float, _time:time, _stop:time}], ?fromNow:float, ?predict:bool) => [{B with _value:float}]"},{"name":"promqlMinute","doc":"// promqlMinute() implements functionality equivalent to PromQL's minute() function:\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#minute\n","typ":"(timestamp:float) => float"},{"name":"promqlMonth","doc":"// promqlMonth() implements functionality equivalent to PromQL's month() function:\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#month\n","typ":"(timestamp:float) => float"},{"name":"promHistogramQuantile","doc":"// promHistogramQuantile() implements functionality equivalent to PromQL's\n// histogram_quantile() function:\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#histogram_quantile\n","typ":"(<-tables:[A], ?countColumn:string, ?quantile:float, ?upperBoundColumn:string, ?valueColumn:string) => [B]"},{"name":"resets","doc":"// resets() implements functionality equivalent to PromQL's resets() function:\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#resets\n","typ":"(<-tables:[{A with _value:float}]) => [{B with _value:float}]"},{"name":"timestamp","doc":"// timestamp() implements functionality equivalent to PromQL's timestamp() function:\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#timestamp\n","typ":"(<-tables:[{A with _value:float}]) => [{A with _value:float}]"},{"name":"promqlYear","doc":"// promqlYear() implements functionality equivalent to PromQL's year() function:\n//\n// https://prometheus.io/docs/prometheus/latest/querying/functions/#year\n","typ":"(timestamp:float) => float"},{"name":"quantile","doc":"","typ":"(<-tables:[A], q:float, ?method:string) => [A]"},{"name":"join","doc":"","typ":"(fn:(left:A, right:B) => C, left:[A], right:[B]) => [C]"}],"packages":[]},{"path":"internal/debug","name":"debug","values":[{"name":"pass","doc":"// pass will pass any incoming tables directly next to the following transformation.\n// It is best used to interrupt any planner rules that rely on a specific ordering.\n","typ":"(<-tables:[A]) => [A]"}],"packages":[]}]},{"path":"planner","name":"planner","values":[{"name":"disableLogicalRules","doc":"","typ":"[string]"},{"name":"disablePhysicalRules","doc":"","typ":"[string]"}],"packages":[]},{"path":"universe","name":"universe","values":[{"name":"now","doc":"// now is a function option whose default behaviour is to return the current system time\n","typ":"() => time"},{"name":"true","doc":"// Booleans\n","typ":"bool"},{"name":"false","doc":"","typ":"bool"},{"name":"chandeMomentumOscillator","doc":"// Transformation functions\n","typ":"(<-tables:[A], n:int, ?columns:[string]) => [B]"},{"name":"columns","doc":"","typ":"(<-tables:[A], ?column:string) => [B]"},{"name":"count","doc":"","typ":"(<-tables:[A], ?column:string) => [B]"},{"name":"covariance","doc":"","typ":"(<-tables:[A], columns:[string], ?pearsonr:bool, ?valueDst:string) => [B]"},{"name":"cumulativeSum","doc":"","typ":"(<-tables:[A], ?columns:[string]) => [B]"},{"name":"derivative","doc":"","typ":"(<-tables:[A], ?columns:[string], ?nonNegative:bool, ?timeColumn:string, ?unit:duration) => [B]"},{"name":"die","doc":"","typ":"(msg:string) => A"},{"name":"difference","doc":"","typ":"(<-tables:[A], ?columns:[string], ?keepFirst:bool, ?nonNegative:bool) => [B]"},{"name":"distinct","doc":"","typ":"(<-tables:[A], ?column:string) => [B]"},{"name":"drop","doc":"","typ":"(<-tables:[A], ?columns:[string], ?fn:(column:string) => bool) => [B]"},{"name":"duplicate","doc":"","typ":"(<-tables:[A], as:string, column:string) => [B]"},{"name":"elapsed","doc":"","typ":"(<-tables:[A], ?columnName:string, ?timeColumn:string, ?unit:duration) => [B]"},{"name":"exponentialMovingAverage","doc":"","typ":"(<-tables:[{A with _value:B}], n:int) => [{A with _value:B}]"},{"name":"fill","doc":"","typ":"(<-tables:[B], ?column:string, ?usePrevious:bool, ?value:A) => [C]"},{"name":"filter","doc":"","typ":"(<-tables:[A], fn:(r:A) => bool, ?onEmpty:string) => [A]"},{"name":"first","doc":"","typ":"(<-tables:[A], ?column:string) => [A]"},{"name":"group","doc":"","typ":"(<-tables:[A], ?columns:[string], ?mode:string) => [A]"},{"name":"histogram","doc":"","typ":"(<-tables:[A], bins:[float], ?column:string, ?countColumn:string, ?normalize:bool, ?upperBoundColumn:string) => [B]"},{"name":"histogramQuantile","doc":"","typ":"(<-tables:[A], ?countColumn:string, ?minValue:float, ?quantile:float, ?upperBoundColumn:string, ?valueColumn:string) => [B]"},{"name":"holtWinters","doc":"","typ":"(<-tables:[A], interval:duration, n:int, ?column:string, ?seasonality:int, ?timeColumn:string, ?withFit:bool) => [B]"},{"name":"hourSelection","doc":"","typ":"(<-tables:[A], start:int, stop:int, ?timeColumn:string) => [A]"},{"name":"integral","doc":"","typ":"(<-tables:[A], ?column:string, ?interpolate:string, ?timeColumn:string, ?unit:duration) => [B]"},{"name":"join","doc":"","typ":"(<-tables:A, ?method:string, ?on:[string]) => [B]"},{"name":"kaufmansAMA","doc":"","typ":"(<-tables:[A], n:int, ?column:string) => [B]"},{"name":"keep","doc":"","typ":"(<-tables:[A], ?columns:[string], ?fn:(column:string) => bool) => [B]"},{"name":"keyValues","doc":"","typ":"(<-tables:[A], ?keyColumns:[string]) => [{B with _value:C, _key:string}]"},{"name":"keys","doc":"","typ":"(<-tables:[A], ?column:string) => [B]"},{"name":"last","doc":"","typ":"(<-tables:[A], ?column:string) => [A]"},{"name":"limit","doc":"","typ":"(<-tables:[A], n:int, ?offset:int) => [A]"},{"name":"map","doc":"","typ":"(<-tables:[A], fn:(r:A) => B, ?mergeKey:bool) => [B]"},{"name":"max","doc":"","typ":"(<-tables:[A], ?column:string) => [A]"},{"name":"mean","doc":"","typ":"(<-tables:[A], ?column:string) => [B]"},{"name":"min","doc":"","typ":"(<-tables:[A], ?column:string) => [A]"},{"name":"mode","doc":"","typ":"(<-tables:[A], ?column:string) => [{B with _value:C}]"},{"name":"movingAverage","doc":"","typ":"(<-tables:[{A with _value:B}], n:int) => [{A with _value:float}]"},{"name":"quantile","doc":"","typ":"(<-tables:[A], q:float, ?column:string, ?compression:float, ?method:string) => [A]"},{"name":"pivot","doc":"","typ":"(<-tables:[A], columnKey:[string], rowKey:[string], valueColumn:string) => [B]"},{"name":"range","doc":"","typ":"(<-tables:[{C with _time:time}], start:A, ?stop:B) => [{C with _time:time, _stop:time, _start:time}]"},{"name":"reduce","doc":"","typ":"(<-tables:[B], fn:(accumulator:A, r:B) => A, identity:A) => [C]"},{"name":"relativeStrengthIndex","doc":"","typ":"(<-tables:[A], n:int, ?columns:[string]) => [B]"},{"name":"rename","doc":"","typ":"(<-tables:[B], ?columns:A, ?fn:(column:string) => string) => [C]"},{"name":"sample","doc":"","typ":"(<-tables:[A], n:int, ?column:string, ?pos:int) => [A]"},{"name":"set","doc":"","typ":"(<-tables:[A], key:string, value:string) => [A]"},{"name":"tail","doc":"","typ":"(<-tables:[A], n:int, ?offset:int) => [A]"},{"name":"timeShift","doc":"","typ":"(<-tables:[A], duration:duration, ?columns:[string]) => [A]"},{"name":"skew","doc":"","typ":"(<-tables:[A], ?column:string) => [B]"},{"name":"spread","doc":"","typ":"(<-tables:[A], ?column:string) => [B]"},{"name":"sort","doc":"","typ":"(<-tables:[A], ?columns:[string], ?desc:bool) => [A]"},{"name":"stateTracking","doc":"","typ":"(<-tables:[A], fn:(r:A) => bool, ?countColumn:string, ?durationColumn:string, ?durationUnit:duration, ?timeColumn:string) => [B]"},{"name":"stddev","doc":"","typ":"(<-tables:[A], ?column:string, ?mode:string) => [B]"},{"name":"sum","doc":"","typ":"(<-tables:[A], ?column:string) => [B]"},{"name":"tripleExponentialDerivative","doc":"","typ":"(<-tables:[{A with _value:B}], n:int) => [{A with _value:float}]"},{"name":"union","doc":"","typ":"(tables:[[A]]) => [A]"},{"name":"unique","doc":"","typ":"(<-tables:[A], ?column:string) => [A]"},{"name":"window","doc":"","typ":"(<-tables:[A], ?createEmpty:bool, ?every:duration, ?offset:duration, ?period:duration, ?startColumn:string, ?stopColumn:string, ?timeColumn:string) => [B]"},{"name":"yield","doc":"","typ":"(<-tables:[A], ?name:string) => [A]"},{"name":"tableFind","doc":"// stream/table index functions\n","typ":"(<-tables:[B], fn:(key:A) => bool) => [B]"},{"name":"getColumn","doc":"","typ":"(<-table:[A], column:string) => [B]"},{"name":"getRecord","doc":"","typ":"(<-table:[A], idx:int) => A"},{"name":"findColumn","doc":"","typ":"(<-tables:[B], column:string, fn:(key:A) => bool) => [C]"},{"name":"findRecord","doc":"","typ":"(<-tables:[B], fn:(key:A) => bool, idx:int) => B"},{"name":"bool","doc":"// type conversion functions\n","typ":"(v:A) => bool"},{"name":"bytes","doc":"","typ":"(v:A) => bytes"},{"name":"duration","doc":"","typ":"(v:A) => duration"},{"name":"float","doc":"","typ":"(v:A) => float"},{"name":"int","doc":"","typ":"(v:A) => int"},{"name":"string","doc":"","typ":"(v:A) => string"},{"name":"time","doc":"","typ":"(v:A) => time"},{"name":"uint","doc":"","typ":"(v:A) => uint"},{"name":"contains","doc":"// contains function\n","typ":"(set:[A], value:A) => bool"},{"name":"inf","doc":"// other builtins\n","typ":"duration"},{"name":"length","doc":"","typ":"(arr:[A]) => int"},{"name":"linearBins","doc":"","typ":"(count:int, start:float, width:float, ?infinity:bool) => [float]"},{"name":"logarithmicBins","doc":"","typ":"(count:int, factor:float, start:float, ?infinity:bool) => [float]"},{"name":"sleep","doc":"// sleep is the identity function with the side effect of delaying execution by a specified duration\n","typ":"(<-v:A, duration:duration) => A"},{"name":"die","doc":"// die returns a fatal error from within a flux script\n","typ":"(msg:string) => A"},{"name":"timeWeightedAvg","doc":"","typ":"(<-tables:[A], unit:duration) => [{B with _value:float, _value:float, _stop:D, _start:C}]"},{"name":"cov","doc":"","typ":"(on:[string], x:A, y:B, ?pearsonr:bool) => [C]"},{"name":"pearsonr","doc":"","typ":"(on:[string], x:A, y:B) => [C]"},{"name":"aggregateWindow","doc":"","typ":"(<-tables:[C], every:duration, fn:(<-:[A], column:string) => [B], ?column:string, ?createEmpty:bool, ?timeDst:string, ?timeSrc:string) => [D]"},{"name":"increase","doc":"","typ":"(<-tables:[A], ?columns:[string]) => [B]"},{"name":"median","doc":"","typ":"(<-tables:[A], ?column:string, ?compression:float, ?method:string) => [A]"},{"name":"stateCount","doc":"","typ":"(<-tables:[A], fn:(r:A) => bool, ?column:string) => [B]"},{"name":"stateDuration","doc":"","typ":"(<-tables:[A], fn:(r:A) => bool, ?column:string, ?timeColumn:string, ?unit:duration) => [B]"},{"name":"_sortLimit","doc":"","typ":"(<-tables:[A], desc:bool, n:int, ?columns:[string]) => [A]"},{"name":"top","doc":"","typ":"(<-tables:[A], n:int, ?columns:[string]) => [A]"},{"name":"bottom","doc":"","typ":"(<-tables:[A], n:int, ?columns:[string]) => [A]"},{"name":"_highestOrLowest","doc":"","typ":"(<-tables:[D], _sortLimit:(<-:[B], columns:[string], n:A) => C, n:A, reducer:(<-:[D]) => [B], ?column:string, ?groupColumns:[string]) => C"},{"name":"highestMax","doc":"","typ":"(<-tables:[A], n:int, ?column:string, ?groupColumns:[string]) => [A]"},{"name":"highestAverage","doc":"","typ":"(<-tables:[A], n:int, ?column:string, ?groupColumns:[string]) => [B]"},{"name":"highestCurrent","doc":"","typ":"(<-tables:[A], n:int, ?column:string, ?groupColumns:[string]) => [A]"},{"name":"lowestMin","doc":"","typ":"(<-tables:[A], n:int, ?column:string, ?groupColumns:[string]) => [A]"},{"name":"lowestAverage","doc":"","typ":"(<-tables:[A], n:int, ?column:string, ?groupColumns:[string]) => [B]"},{"name":"lowestCurrent","doc":"","typ":"(<-tables:[A], n:int, ?column:string, ?groupColumns:[string]) => [A]"},{"name":"timedMovingAverage","doc":"","typ":"(<-tables:[A], every:duration, period:duration, ?column:string) => [B]"},{"name":"doubleEMA","doc":"","typ":"(<-tables:[{A with _value:B}], n:int) => [C]"},{"name":"tripleEMA","doc":"","typ":"(<-tables:[{A with _value:B}], n:int) => [C]"},{"name":"truncateTimeColumn","doc":"","typ":"(<-tables:[{A with _time:B}], unit:duration, ?timeColumn:string) => [{A with _time:B, _time:time}]"},{"name":"kaufmansER","doc":"","typ":"(<-tables:[A], n:int) => [{B with _value:float, _value:float}]"},{"name":"toString","doc":"","typ":"(<-tables:[{A with _value:B}]) => [{A with _value:B, _value:string}]"},{"name":"toInt","doc":"","typ":"(<-tables:[{A with _value:B}]) => [{A with _value:B, _value:int}]"},{"name":"toUInt","doc":"","typ":"(<-tables:[{A with _value:B}]) => [{A with _value:B, _value:uint}]"},{"name":"toFloat","doc":"","typ":"(<-tables:[{A with _value:B}]) => [{A with _value:B, _value:float}]"},{"name":"toBool","doc":"","typ":"(<-tables:[{A with _value:B}]) => [{A with _value:B, _value:bool}]"},{"name":"toTime","doc":"","typ":"(<-tables:[{A with _value:B}]) => [{A with _value:B, _value:time}]"}],"packages":[{"path":"universe/holt_winters","name":"holt_winters","values":[],"packages":[]}]},{"path":"sql","name":"sql","values":[{"name":"from","doc":"","typ":"(dataSourceName:string, driverName:string, query:string) => [A]"},{"name":"to","doc":"","typ":"(<-tables:[A], dataSourceName:string, driverName:string, table:string, ?batchSize:int) => [A]"}],"packages":[]},{"path":"kafka","name":"kafka","values":[{"name":"to","doc":"","typ":"(<-tables:[A], brokers:[string], topic:string, ?balancer:string, ?name:string, ?nameColumn:string, ?tagColumns:[string], ?timeColumn:string, ?valueColumns:[string]) => [A]"}],"packages":[]},{"path":"testing","name":"testing","values":[{"name":"assertEquals","doc":"","typ":"(<-got:[A], name:string, want:[A]) => [A]"},{"name":"assertEmpty","doc":"","typ":"(<-tables:[A]) => [A]"},{"name":"diff","doc":"","typ":"(<-got:[A], want:[A], ?epsilon:float, ?verbose:bool) => [{A with _diff:string}]"},{"name":"loadStorage","doc":"","typ":"(csv:string) => [{A with _time:time, _time:time, _stop:time, _start:time, _measurement:C, _measurement:C, _field:B, _field:B}]"},{"name":"loadMem","doc":"","typ":"(csv:string) => [A]"},{"name":"inspect","doc":"","typ":"(case:() => {A with input:B, fn:(<-:B) => [C]}) => {want:[C], input:B, got:[C], fn:(<-:B) => [C], diff:[{C with _diff:string}]}"},{"name":"run","doc":"","typ":"(case:() => {A with input:B, fn:(<-:B) => [C]}) => [{C with _diff:string}]"},{"name":"benchmark","doc":"","typ":"(case:() => {A with input:B, fn:(<-:B) => C}) => C"}],"packages":[{"path":"testing/influxql","name":"influxql","values":[],"packages":[]},{"path":"testing/kapacitor","name":"kapacitor","values":[],"packages":[]},{"path":"testing/prometheus","name":"prometheus","values":[],"packages":[]},{"path":"testing/chronograf","name":"chronograf","values":[],"packages":[]},{"path":"testing/promql","name":"promql","values":[],"packages":[]},{"path":"testing/usage","name":"usage","values":[],"packages":[]},{"path":"testing/pandas","name":"pandas","values":[],"packages":[]}]},{"path":"system","name":"system","values":[{"name":"time","doc":"","typ":"() => time"}],"packages":[]},{"path":"generate","name":"generate","values":[{"name":"from","doc":"","typ":"(count:int, fn:(n:int) => int, start:A, stop:A) => [{_value:int, _time:time, _stop:time, _start:time}]"}],"packages":[]},{"path":"experimental","name":"experimental","values":[{"name":"addDuration","doc":"","typ":"(d:duration, to:time) => time"},{"name":"subDuration","doc":"","typ":"(d:duration, from:time) => time"},{"name":"group","doc":"// An experimental version of group that has mode: \"extend\"\n","typ":"(<-tables:[A], columns:[string], mode:string) => [A]"},{"name":"objectKeys","doc":"// objectKeys produces a list of the keys existing on the object\n","typ":"(o:A) => [string]"},{"name":"set","doc":"// set adds the values from the object onto each row of a table\n","typ":"(<-tables:[B], o:A) => [C]"},{"name":"to","doc":"// An experimental version of \"to\" that:\n// - Expects pivoted data\n// - Any column in the group key is made a tag in storage\n// - All other columns are fields\n// - An error will be thrown for incompatible data types\n","typ":"(<-tables:[A], ?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?token:string) => [A]"},{"name":"join","doc":"// An experimental version of join.\n","typ":"(fn:(left:A, right:B) => C, left:[A], right:[B]) => [C]"},{"name":"chain","doc":"","typ":"(first:[A], second:[B]) => [B]"},{"name":"alignTime","doc":"","typ":"(<-tables:[A], ?alignTo:time) => [B]"}],"packages":[{"path":"experimental/geo","name":"geo","values":[{"name":"units","doc":"// Units\n","typ":"{distance:string}"},{"name":"stContains","doc":"//\n// Builtin GIS functions\n//\n// Returns boolean whether the region contains specified geometry.\n","typ":"(geometry:A, region:B, units:{distance:string}) => bool"},{"name":"stDistance","doc":"// Returns distance from given region to specified geometry.\n","typ":"(geometry:A, region:B, units:{distance:string}) => float"},{"name":"stLength","doc":"// Returns length of a curve.\n","typ":"(geometry:A, units:{distance:string}) => float"},{"name":"ST_Contains","doc":"","typ":"(geometry:A, region:B, ?units:{distance:string}) => bool"},{"name":"ST_Distance","doc":"","typ":"(geometry:A, region:B, ?units:{distance:string}) => float"},{"name":"ST_DWithin","doc":"","typ":"(distance:A, geometry:B, region:C, ?units:{distance:string}) => bool"},{"name":"ST_Intersects","doc":"","typ":"(geometry:A, region:B, ?units:{distance:string}) => bool"},{"name":"ST_Length","doc":"","typ":"(geometry:A, ?units:{distance:string}) => float"},{"name":"ST_LineString","doc":"","typ":"(<-tables:[{A with lon:C, lat:B}]) => [D]"},{"name":"getGrid","doc":"//\n// None of the following builtin functions are intended to be used by end users.\n//\n// Calculates grid (set of cell ID tokens) for given region and according to options.\n","typ":"(region:A, units:{distance:string}, ?level:int, ?maxLevel:int, ?maxSize:int, ?minSize:int) => {set:[string], level:int}"},{"name":"getLevel","doc":"// Returns level of specified cell ID token.\n","typ":"(token:string) => int"},{"name":"s2CellIDToken","doc":"// Returns cell ID token for given cell or lat/lon point at specified level.\n","typ":"(level:int, ?point:{lon:float, lat:float}, ?token:string) => string"},{"name":"s2CellLatLon","doc":"// Returns lat/lon coordinates of given cell ID token.\n","typ":"(token:string) => {lon:float, lat:float}"},{"name":"_detectLevel","doc":"","typ":"(<-tables:[{A with s2_cell_id:string}]) => int"},{"name":"toRows","doc":"","typ":"(<-tables:[A]) => [B]"},{"name":"shapeData","doc":"","typ":"(<-tables:[{C with _field:string}], latField:A, level:int, lonField:B) => [{D with s2_cell_id:string, lon:float, lat:float}]"},{"name":"gridFilter","doc":"","typ":"(<-tables:[{B with s2_cell_id:string}], region:A, ?level:int, ?maxSize:int, ?minSize:int, ?s2cellIDLevel:int, ?units:{distance:string}) => [{B with s2_cell_id:string}]"},{"name":"strictFilter","doc":"","typ":"(<-tables:[{B with lon:D, lat:C}], region:A) => [{B with lon:D, lat:C}]"},{"name":"filterRows","doc":"","typ":"(<-tables:[{B with s2_cell_id:string, lon:D, lat:C}], region:A, ?level:int, ?maxSize:int, ?minSize:int, ?s2cellIDLevel:int, ?strict:bool) => [{E with s2_cell_id:string, lon:D, lat:C}]"},{"name":"groupByArea","doc":"","typ":"(<-tables:[{A with s2_cell_id:string, lon:float, lat:float}], level:int, newColumn:string, ?s2cellIDLevel:int) => [B]"},{"name":"asTracks","doc":"","typ":"(<-tables:[A], ?groupBy:[string], ?orderBy:[string]) => [A]"}],"packages":[]},{"path":"experimental/json","name":"json","values":[{"name":"parse","doc":"// Parse will consume json data as bytes and return a value.\n// Lists, objects, strings, booleans and float values can be produced.\n// All numeric values are represented using the float type.\n","typ":"(data:bytes) => A"}],"packages":[]},{"path":"experimental/http","name":"http","values":[{"name":"get","doc":"// Get submits an HTTP get request to the specified URL with headers\n// Returns HTTP status code and body as a byte array\n","typ":"(url:string, ?headers:A, ?timeout:duration) => {statusCode:int, headers:B, body:bytes}"}],"packages":[]},{"path":"experimental/prometheus","name":"prometheus","values":[{"name":"scrape","doc":"// scrape enables scraping of a prometheus metrics endpoint and converts \n// that input into flux tables. Each metric is put into an individual flux \n// table, including each histogram and summary value.  \n","typ":"(url:string) => [A]"},{"name":"histogramQuantile","doc":"","typ":"(<-tables:[{A with le:C, _measurement:B}], quantile:float) => [D]"}],"packages":[]},{"path":"experimental/aggregate","name":"aggregate","values":[{"name":"rate","doc":"","typ":"(<-tables:[A], every:duration, ?groupColumns:[string], ?unit:duration) => [B]"}],"packages":[]},{"path":"experimental/query","name":"query","values":[{"name":"fromRange","doc":"","typ":"(bucket:string, start:A, ?stop:time) => [{B with _value:C, _time:time, _stop:time, _start:time, _measurement:string, _field:string}]"},{"name":"filterMeasurement","doc":"","typ":"(<-table:[{B with _measurement:C}], measurement:A) => [{B with _measurement:C}]"},{"name":"filterFields","doc":"","typ":"(<-table:[{B with _field:A}], ?fields:[A]) => [{B with _field:A}]"},{"name":"inBucket","doc":"","typ":"(bucket:string, measurement:A, start:B, ?fields:[string], ?predicate:(r:{C with _value:D, _time:time, _stop:time, _start:time, _measurement:string, _field:string}) => bool, ?stop:time) => [{C with _value:D, _time:time, _stop:time, _start:time, _measurement:string, _field:string}]"}],"packages":[]},{"path":"experimental/mqtt","name":"mqtt","values":[{"name":"to","doc":"","typ":"(<-tables:[A], broker:string, ?clientid:string, ?message:string, ?name:string, ?password:string, ?qos:int, ?tagColumns:[string], ?timeColumn:string, ?timeout:duration, ?topic:string, ?username:string, ?valueColumns:[string]) => [B]"}],"packages":[]},{"path":"experimental/bigtable","name":"bigtable","values":[{"name":"from","doc":"","typ":"(instance:string, project:string, table:string, token:string) => [A]"}],"packages":[]},{"path":"experimental/csv","name":"csv","values":[{"name":"from","doc":"","typ":"(url:string) => [A]"}],"packages":[]},{"path":"experimental/array","name":"array","values":[{"name":"from","doc":"// from will construct a table from the input rows.\n//\n// This function takes the `rows` parameter. The rows\n// parameter is an array of records that will be constructed.\n// All of the records must have the same keys and the same types\n// for the values.\n","typ":"(rows:[A]) => [A]"}],"packages":[]}]},{"path":"pushbullet","name":"pushbullet","values":[{"name":"defaultURL","doc":"","typ":"string"},{"name":"pushData","doc":"","typ":"(data:A, ?token:string, ?url:string) => int"},{"name":"pushNote","doc":"","typ":"(text:A, title:B, ?token:string, ?url:string) => int"},{"name":"endpoint","doc":"","typ":"(?token:string, ?url:string) => (mapFn:(r:A) => {B with title:D, text:C}) => (<-tables:[A]) => [{A with _sent:string}]"}],"packages":[]},{"path":"dict","name":"dict","values":[{"name":"fromList","doc":"// fromList will convert an array of key/value pairs\n// into a dictionary.\n","typ":"(pairs:[{value:B, key:A}]) => [t8135:t8136]"},{"name":"get","doc":"// get will retrieve a value from a dictionary. If there is no\n// key in the dictionary, the default value will be returned.\n","typ":"(default:A, dict:[t8137:t8138], key:B) => A"},{"name":"insert","doc":"// insert will insert a key/value pair into the dictionary\n// and return a new dictionary with that value inserted.\n// If the key already exists in the dictionary, it will\n// be overwritten.\n","typ":"(dict:[t8139:t8140], key:A, value:B) => [t8139:t8140]"},{"name":"remove","doc":"// remove will remove a key/value pair from the dictionary\n// and return a new dictionary with that value removed.\n","typ":"(dict:[t8141:t8142], key:A) => [t8141:t8142]"}],"packages":[]},{"path":"interpolate","name":"interpolate","values":[{"name":"linear","doc":"","typ":"(<-tables:[{A with _value:float, _time:time}], every:duration) => [{A with _value:float, _time:time}]"}],"packages":[]},{"path":"math","name":"math","values":[{"name":"pi","doc":"// builtin constants\n","typ":"float"},{"name":"e","doc":"","typ":"float"},{"name":"phi","doc":"","typ":"float"},{"name":"sqrt2","doc":"","typ":"float"},{"name":"sqrte","doc":"","typ":"float"},{"name":"sqrtpi","doc":"","typ":"float"},{"name":"sqrtphi","doc":"","typ":"float"},{"name":"ln2","doc":"","typ":"float"},{"name":"log2e","doc":"","typ":"float"},{"name":"ln10","doc":"","typ":"float"},{"name":"log10e","doc":"","typ":"float"},{"name":"maxfloat","doc":"","typ":"float"},{"name":"smallestNonzeroFloat","doc":"","typ":"float"},{"name":"maxint","doc":"","typ":"int"},{"name":"minint","doc":"","typ":"int"},{"name":"maxuint","doc":"","typ":"uint"},{"name":"abs","doc":"// builtin functions\n","typ":"(x:float) => float"},{"name":"acos","doc":"","typ":"(x:float) => float"},{"name":"acosh","doc":"","typ":"(x:float) => float"},{"name":"asin","doc":"","typ":"(x:float) => float"},{"name":"asinh","doc":"","typ":"(x:float) => float"},{"name":"atan","doc":"","typ":"(x:float) => float"},{"name":"atan2","doc":"","typ":"(x:float, y:float) => float"},{"name":"atanh","doc":"","typ":"(x:float) => float"},{"name":"cbrt","doc":"","typ":"(x:float) => float"},{"name":"ceil","doc":"","typ":"(x:float) => float"},{"name":"copysign","doc":"","typ":"(x:float, y:float) => float"},{"name":"cos","doc":"","typ":"(x:float) => float"},{"name":"cosh","doc":"","typ":"(x:float) => float"},{"name":"dim","doc":"","typ":"(x:float, y:float) => float"},{"name":"erf","doc":"","typ":"(x:float) => float"},{"name":"erfc","doc":"","typ":"(x:float) => float"},{"name":"erfcinv","doc":"","typ":"(x:float) => float"},{"name":"erfinv","doc":"","typ":"(x:float) => float"},{"name":"exp","doc":"","typ":"(x:float) => float"},{"name":"exp2","doc":"","typ":"(x:float) => float"},{"name":"expm1","doc":"","typ":"(x:float) => float"},{"name":"float64bits","doc":"","typ":"(f:float) => uint"},{"name":"float64frombits","doc":"","typ":"(b:uint) => float"},{"name":"floor","doc":"","typ":"(x:float) => float"},{"name":"frexp","doc":"","typ":"(f:float) => {frac:float, exp:int}"},{"name":"gamma","doc":"","typ":"(x:float) => float"},{"name":"hypot","doc":"","typ":"(x:float) => float"},{"name":"ilogb","doc":"","typ":"(x:float) => float"},{"name":"mInf","doc":"","typ":"(sign:int) => float"},{"name":"isInf","doc":"","typ":"(f:float, sign:int) => bool"},{"name":"isNaN","doc":"","typ":"(f:float) => bool"},{"name":"j0","doc":"","typ":"(x:float) => float"},{"name":"j1","doc":"","typ":"(x:float) => float"},{"name":"jn","doc":"","typ":"(n:int, x:float) => float"},{"name":"ldexp","doc":"","typ":"(exp:int, frac:float) => float"},{"name":"lgamma","doc":"","typ":"(x:float) => {sign:int, lgamma:float}"},{"name":"log","doc":"","typ":"(x:float) => float"},{"name":"log10","doc":"","typ":"(x:float) => float"},{"name":"log1p","doc":"","typ":"(x:float) => float"},{"name":"log2","doc":"","typ":"(x:float) => float"},{"name":"logb","doc":"","typ":"(x:float) => float"},{"name":"mMax","doc":"","typ":"(x:float, y:float) => float"},{"name":"mMin","doc":"","typ":"(x:float, y:float) => float"},{"name":"mod","doc":"","typ":"(x:float, y:float) => float"},{"name":"modf","doc":"","typ":"(f:float) => {int:float, frac:float}"},{"name":"NaN","doc":"","typ":"() => float"},{"name":"nextafter","doc":"","typ":"(x:float, y:float) => float"},{"name":"pow","doc":"","typ":"(x:float, y:float) => float"},{"name":"pow10","doc":"","typ":"(n:int) => float"},{"name":"remainder","doc":"","typ":"(x:float, y:float) => float"},{"name":"round","doc":"","typ":"(x:float) => float"},{"name":"roundtoeven","doc":"","typ":"(x:float) => float"},{"name":"signbit","doc":"","typ":"(x:float) => bool"},{"name":"sin","doc":"","typ":"(x:float) => float"},{"name":"sincos","doc":"","typ":"(x:float) => {sin:float, cos:float}"},{"name":"sinh","doc":"","typ":"(x:float) => float"},{"name":"sqrt","doc":"","typ":"(x:float) => float"},{"name":"tan","doc":"","typ":"(x:float) => float"},{"name":"tanh","doc":"","typ":"(x:float) => float"},{"name":"trunc","doc":"","typ":"(x:float) => float"},{"name":"y0","doc":"","typ":"(x:float) => float"},{"name":"y1","doc":"","typ":"(x:float) => float"},{"name":"yn","doc":"","typ":"(n:int, x:float) => float"}],"packages":[]},{"path":"csv","name":"csv","values":[{"name":"from","doc":"","typ":"(?csv:string, ?file:string) => [A]"}],"packages":[]},{"path":"socket","name":"socket","values":[{"name":"from","doc":"","typ":"(url:string, ?decoder:string) => [A]"}],"packages":[]},{"path":"influxdata","name":"influxdata","values":[],"packages":[{"path":"influxdata/influxdb","name":"influxdb","values":[{"name":"from","doc":"","typ":"(?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?token:string) => [{A with _value:B, _time:time, _measurement:string, _field:string}]"},{"name":"to","doc":"","typ":"(<-tables:[A], ?bucket:string, ?bucketID:string, ?fieldFn:(r:A) => B, ?host:string, ?measurementColumn:string, ?org:string, ?orgID:string, ?tagColumns:[string], ?timeColumn:string, ?token:string) => [A]"},{"name":"buckets","doc":"","typ":"(?host:string, ?org:string, ?orgID:string, ?token:string) => [{retentionPolicy:string, retentionPeriod:int, organizationID:string, name:string, id:string}]"},{"name":"cardinality","doc":"// cardinality will return the cardinality of data for a given bucket.\n// If a predicate is specified, then the cardinality only includes series\n// that match the predicate.\n","typ":"(start:A, ?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?predicate:(r:{B with _value:C, _measurement:string, _field:string}) => bool, ?stop:D, ?token:string) => [{_value:int, _stop:time, _start:time}]"}],"packages":[{"path":"influxdata/influxdb/schema","name":"schema","values":[{"name":"fieldsAsCols","doc":"","typ":"(<-tables:[A]) => [B]"},{"name":"tagValues","doc":"","typ":"(bucket:string, tag:string, ?predicate:(r:{A with _value:B, _time:time, _stop:time, _start:time, _measurement:string, _field:string}) => bool, ?start:duration) => [C]"},{"name":"measurementTagValues","doc":"","typ":"(bucket:string, measurement:A, tag:string) => [B]"},{"name":"tagKeys","doc":"","typ":"(bucket:string, ?predicate:(r:{A with _value:B, _time:time, _stop:time, _start:time, _measurement:string, _field:string}) => bool, ?start:duration) => [C]"},{"name":"measurementTagKeys","doc":"","typ":"(bucket:string, measurement:A) => [B]"},{"name":"fieldKeys","doc":"","typ":"(bucket:string, ?predicate:(r:{A with _value:B, _time:time, _stop:time, _start:time, _measurement:string, _field:string}) => bool, ?start:duration) => [C]"},{"name":"measurementFieldKeys","doc":"","typ":"(bucket:string, measurement:A, ?start:duration) => [B]"},{"name":"measurements","doc":"","typ":"(bucket:string) => [A]"}],"packages":[]},{"path":"influxdata/influxdb/internal","name":"internal","values":[],"packages":[{"path":"influxdata/influxdb/internal/testutil","name":"testutil","values":[],"packages":[]}]},{"path":"influxdata/influxdb/secrets","name":"secrets","values":[{"name":"get","doc":"","typ":"(key:string) => string"}],"packages":[]},{"path":"influxdata/influxdb/tasks","name":"tasks","values":[{"name":"_zeroTime","doc":"// _zeroTime is a sentinel value for the zero time.\n// This is used to mark that the lastSuccessTime has not been set.\n","typ":"time"},{"name":"lastSuccessTime","doc":"// lastSuccessTime is the last time this task had run successfully.\n","typ":"time"},{"name":"_lastSuccess","doc":"// _lastSuccess will return the time set on the option lastSuccessTime\n// or it will return the orTime.\n","typ":"(lastSuccessTime:time, orTime:A) => time"},{"name":"lastSuccess","doc":"","typ":"(orTime:A) => time"}],"packages":[]},{"path":"influxdata/influxdb/monitor","name":"monitor","values":[{"name":"bucket","doc":"","typ":"string"},{"name":"write","doc":"// Write persists the check statuses\n","typ":"(<-tables:[A]) => [A]"},{"name":"log","doc":"// Log records notification events\n","typ":"(<-tables:[A]) => [A]"},{"name":"from","doc":"","typ":"(start:A, ?fn:(r:{B with _value:C, _time:time, _stop:time, _start:time, _measurement:string, _field:string}) => bool, ?stop:time) => [D]"},{"name":"levelOK","doc":"","typ":"string"},{"name":"levelInfo","doc":"","typ":"string"},{"name":"levelWarn","doc":"","typ":"string"},{"name":"levelCrit","doc":"","typ":"string"},{"name":"levelUnknown","doc":"","typ":"string"},{"name":"_stateChanges","doc":"","typ":"(<-tables:[{A with _level:B}], ?fromLevel:string, ?toLevel:string) => [C]"},{"name":"stateChangesOnly","doc":"","typ":"(<-tables:[{A with _level:B}]) => [C]"},{"name":"stateChanges","doc":"","typ":"(<-tables:[{A with _level:B}], ?fromLevel:string, ?toLevel:string) => [C]"},{"name":"notify","doc":"","typ":"(<-tables:[E], data:A, endpoint:(<-:[{B with _time:C, _time:time, _status_timestamp:int, _measurement:string}]) => [D]) => [D]"},{"name":"logs","doc":"","typ":"(fn:(r:{A with _value:B, _time:time, _stop:time, _start:time, _measurement:string, _field:string}) => bool, start:C, ?stop:time) => [D]"},{"name":"deadman","doc":"","typ":"(<-tables:[{B with _time:C}], t:A) => [{B with dead:bool, _time:C}]"},{"name":"check","doc":"","typ":"(<-tables:[J], data:{A with tags:E, _type:D, _check_name:C, _check_id:B}, messageFn:(r:{F with _type:D, _time:H, _time:time, _source_timestamp:int, _source_measurement:G, _measurement:G, _measurement:string, _level:string, _check_name:C, _check_id:B}) => I, ?crit:(r:{F with _time:H, _measurement:G}) => bool, ?info:(r:{F with _time:H, _measurement:G}) => bool, ?ok:(r:{F with _time:H, _measurement:G}) => bool, ?warn:(r:{F with _time:H, _measurement:G}) => bool) => [{F with _type:D, _time:H, _time:time, _source_timestamp:int, _source_measurement:G, _message:I, _measurement:G, _measurement:string, _level:string, _check_name:C, _check_id:B}]"}],"packages":[]},{"path":"influxdata/influxdb/v1","name":"v1","values":[{"name":"json","doc":"// Json parses an InfluxDB 1.x json result into a table stream.\n","typ":"(?file:string, ?json:string) => [A]"},{"name":"databases","doc":"// Databases returns the list of available databases, it has no parameters.\n","typ":"(?host:string, ?org:string, ?orgID:string, ?token:string) => [{retentionPolicy:string, retentionPeriod:int, organizationID:string, default:bool, databaseName:string, bucketID:string}]"},{"name":"fieldsAsCols","doc":"","typ":"(<-tables:[A]) => [B]"},{"name":"tagValues","doc":"","typ":"(bucket:string, tag:string, ?predicate:(r:{A with _value:B, _time:time, _stop:time, _start:time, _measurement:string, _field:string}) => bool, ?start:duration) => [C]"},{"name":"measurementTagValues","doc":"","typ":"(bucket:string, measurement:A, tag:string) => [B]"},{"name":"tagKeys","doc":"","typ":"(bucket:string, ?predicate:(r:{A with _value:B, _time:time, _stop:time, _start:time, _measurement:string, _field:string}) => bool, ?start:duration) => [C]"},{"name":"measurementTagKeys","doc":"","typ":"(bucket:string, measurement:A) => [B]"},{"name":"fieldKeys","doc":"","typ":"(bucket:string, ?predicate:(r:{A with _value:B, _time:time, _stop:time, _start:time, _measurement:string, _field:string}) => bool, ?start:duration) => [C]"},{"name":"measurementFieldKeys","doc":"","typ":"(bucket:string, measurement:A, ?start:duration) => [B]"},{"name":"measurements","doc":"","typ":"(bucket:string) => [A]"}],"packages":[]}]}]},{"path":"runtime","name":"runtime","values":[{"name":"version","doc":"","typ":"() => string"}],"packages":[]},{"path":"regexp","name":"regexp","values":[{"name":"compile","doc":"","typ":"(v:string) => regexp"},{"name":"quoteMeta","doc":"","typ":"(v:string) => string"},{"name":"findString","doc":"","typ":"(r:regexp, v:string) => string"},{"name":"findStringIndex","doc":"","typ":"(r:regexp, v:string) => [int]"},{"name":"matchRegexpString","doc":"","typ":"(r:regexp, v:string) => bool"},{"name":"replaceAllString","doc":"","typ":"(r:regexp, t:string, v:string) => string"},{"name":"splitRegexp","doc":"","typ":"(i:int, r:regexp, v:string) => [string]"},{"name":"getString","doc":"","typ":"(r:regexp) => string"}],"packages":[]},{"path":"pagerduty","name":"pagerduty","values":[{"name":"dedupKey","doc":"// `dedupKey` - adds a newline concatinated value of the sorted group key that is then sha256-hashed and hex-encoded to a column with the key `_pagerdutyDedupKey`.\n","typ":"(<-tables:[A]) => [{A with _pagerdutyDedupKey:string}]"},{"name":"defaultURL","doc":"","typ":"string"},{"name":"severityFromLevel","doc":"","typ":"(level:string) => string"},{"name":"actionFromLevel","doc":"","typ":"(level:string) => string"},{"name":"sendEvent","doc":"","typ":"(class:A, client:B, clientURL:C, dedupKey:D, eventAction:E, group:F, routingKey:G, severity:H, source:I, summary:J, timestamp:t10, ?pagerdutyURL:string) => int"},{"name":"endpoint","doc":"","typ":"(?url:string) => (mapFn:(r:{A with _pagerdutyDedupKey:string}) => {B with timestamp:t11, summary:t10, source:J, severity:I, routingKey:H, group:G, eventAction:F, clientURL:E, client:D, class:C}) => (<-tables:[A]) => [{A with _sent:string, _pagerdutyDedupKey:string}]"}],"packages":[]},{"path":"contrib","name":"contrib","values":[],"packages":[{"path":"contrib/jsternberg","name":"jsternberg","values":[],"packages":[{"path":"contrib/jsternberg/influxdb","name":"influxdb","values":[{"name":"_mask","doc":"// _mask will hide the given columns from downstream\n// transformations. It will not perform any copies and\n// it will not regroup. This should only be used when\n// the user knows it can't cause a key conflict.\n","typ":"(<-tables:[A], columns:[string]) => [B]"},{"name":"from","doc":"","typ":"(bucket:string, start:A, ?host:string, ?org:string, ?stop:time, ?token:string) => [{B with _value:C, _time:time, _stop:time, _start:time, _measurement:string, _field:string}]"},{"name":"_from","doc":"","typ":"(bucket:string, start:A, ?host:string, ?org:string, ?stop:time, ?token:string) => [{B with _value:C, _time:time, _stop:time, _start:time, _measurement:string, _field:string}]"},{"name":"select","doc":"","typ":"(from:string, m:A, start:B, ?fields:[string], ?host:string, ?org:string, ?stop:time, ?token:string, ?where:(r:{C with _value:D, _time:time, _stop:time, _start:time, _measurement:string, _field:string}) => bool) => [E]"}],"packages":[]},{"path":"contrib/jsternberg/aggregate","name":"aggregate","values":[{"name":"table","doc":"// table will aggregate columns and create tables with a single\n// row containing the aggregated value.\n//\n// This function takes a single parameter of `columns`. The parameter\n// is an object with the output column name as the key and the aggregate\n// object as the value.\n//\n// The aggregate object is composed of at least the following required attributes:\n//     column = string\n//         The column name for the input.\n//     init = (values) -> state\n//         An initial function to compute the initial state of the\n//         output. This can return either the final aggregate or a\n//         temporary state object that can be used to compute the\n//         final aggregate. The values parameter will always be a\n//         non-empty array of values from the specified column.\n//     reduce = (values, state) -> state\n//         A function that takes in another buffer of values\n//         and the current state of the aggregate and computes\n//         the updated state.\n//     compute = (state) -> value\n//         A function that takes the state and computes the final\n//         aggregate.\n//     fill = value\n//         The value passed to fill, if present, will determine what\n//         the aggregate does when there are no values.\n//         This can either be a value or one of the predefined\n//         identifiers of null or none.\n//         This value must be the same type as the value return from\n//         compute.\n//\n// An example of usage is:\n//     tables |> aggregate.table(columns: {\n//         \"min_bottom_degrees\": aggregate.min(column: \"bottom_degrees\"),\n//     ])\n","typ":"(<-tables:[B], columns:A) => [C]"},{"name":"window","doc":"// window will aggregate columns and create tables by\n// organizing incoming points into windows.\n//\n// Each table will have two additional columns: start and stop.\n// These are the start and stop times for each interval.\n// It is not possible to use start or stop as destination column\n// names with this function. The start and stop columns are not\n// added to the group key.\n//\n// The same options as for table apply to window.\n// In addition to those options, window requires one\n// additional parameter.\n//     every = duration\n//         The duration between the start of each interval.\n//\n// Along with the above required option, there are a few additional\n// optional parameters.\n//     time = string\n//         The column name for the time input.\n//         This defaults to _time or time, whichever is earlier in\n//         the list of columns.\n//     period = duration\n//         The length of the interval. This defaults to the\n//         every duration.\n","typ":"(<-tables:[B], columns:A, every:duration, ?period:duration, ?time:string) => [C]"},{"name":"null","doc":"// null is a sentinel value for fill that will fill\n// in a null value if there were no values for an interval.\n","typ":"A"},{"name":"none","doc":"// none is a sentinel value for fill that will skip\n// emitting a row if there are no values for an interval.\n","typ":"A"},{"name":"define","doc":"","typ":"(compute:A, init:B, reduce:C, ?fill:D) => (?column:string, ?fill:D) => {reduce:C, init:B, fill:D, compute:A, column:string}"},{"name":"_make_selector","doc":"","typ":"(fn:(values:[A]) => A) => (?column:string, ?fill:B) => {reduce:(state:A, values:[A]) => A, init:(values:[A]) => A, fill:B, compute:(state:C) => C, column:string}"},{"name":"min","doc":"","typ":"(?column:string, ?fill:A) => {reduce:(state:C, values:[C]) => C, init:(values:[C]) => C, fill:A, compute:(state:B) => B, column:string}"},{"name":"max","doc":"","typ":"(?column:string, ?fill:A) => {reduce:(state:C, values:[C]) => C, init:(values:[C]) => C, fill:A, compute:(state:B) => B, column:string}"},{"name":"sum","doc":"","typ":"(?column:string, ?fill:A) => {reduce:(state:D, values:[D]) => D, init:(values:[C]) => C, fill:A, compute:(state:B) => B, column:string}"},{"name":"count","doc":"","typ":"(?column:string, ?fill:int) => {reduce:(state:int, values:[C]) => int, init:(values:[B]) => int, fill:int, compute:(state:A) => A, column:string}"},{"name":"mean","doc":"","typ":"(?column:string, ?fill:A) => {reduce:(state:{F with sum:G, count:int}, values:[G]) => {sum:G, count:int}, init:(values:[E]) => {sum:E, count:int}, fill:A, compute:(state:{B with sum:D, count:C}) => float, column:string}"}],"packages":[]},{"path":"contrib/jsternberg/rows","name":"rows","values":[{"name":"map","doc":"// map will map each of the rows to a new value.\n// The function will be invoked for each row and the\n// return value will be used as the values in the output\n// row.\n//\n// The record that is passed to the function will contain\n// all of the keys and values in the record including group\n// keys, but the group key cannot be changed. Attempts to\n// change the group key will be ignored.\n//\n// The returned record does not need to contain values that are\n// part of the group key.\n","typ":"(<-tables:[A], fn:(r:A) => B) => [B]"}],"packages":[]},{"path":"contrib/jsternberg/math","name":"math","values":[{"name":"minIndex","doc":"","typ":"(values:[A]) => int"},{"name":"min","doc":"","typ":"(values:[A]) => A"},{"name":"maxIndex","doc":"","typ":"(values:[A]) => int"},{"name":"max","doc":"","typ":"(values:[A]) => A"},{"name":"sum","doc":"","typ":"(values:[A]) => A"}],"packages":[]}]},{"path":"contrib/sranka","name":"sranka","values":[],"packages":[{"path":"contrib/sranka/telegram","name":"telegram","values":[{"name":"defaultURL","doc":"","typ":"string"},{"name":"defaultParseMode","doc":"","typ":"string"},{"name":"defaultDisableWebPagePreview","doc":"","typ":"bool"},{"name":"defaultSilent","doc":"","typ":"bool"},{"name":"message","doc":"","typ":"(channel:A, text:B, token:string, ?disableWebPagePreview:bool, ?parseMode:string, ?silent:bool, ?url:string) => int"},{"name":"endpoint","doc":"","typ":"(token:string, ?disableWebPagePreview:bool, ?parseMode:string, ?url:string) => (mapFn:(r:A) => {B with text:D, silent:bool, channel:C}) => (<-tables:[A]) => [{A with _sent:string}]"}],"packages":[]},{"path":"contrib/sranka/opsgenie","name":"opsgenie","values":[{"name":"respondersToJSON","doc":"// respondersToJSON converts an array of responder strings to JSON array that can be embedded into an alert message\n","typ":"(v:[string]) => string"},{"name":"sendAlert","doc":"","typ":"(apiKey:string, message:string, ?actions:[A], ?alias:string, ?description:string, ?details:string, ?entity:string, ?priority:string, ?responders:[string], ?tags:[B], ?url:string, ?visibleTo:[string]) => int"},{"name":"endpoint","doc":"","typ":"(apiKey:string, ?entity:string, ?url:string) => (mapFn:(r:A) => {B with visibleTo:[string], tags:[D], responders:[string], priority:string, message:string, details:string, description:string, alias:string, actions:[C]}) => (<-tables:[A]) => [{A with _sent:string}]"}],"packages":[]},{"path":"contrib/sranka/teams","name":"teams","values":[{"name":"summaryCutoff","doc":"// `summaryCutoff` is used \n","typ":"int"},{"name":"message","doc":"","typ":"(text:string, title:A, url:string, ?summary:string) => int"},{"name":"endpoint","doc":"","typ":"(url:string) => (mapFn:(r:A) => {B with title:C, text:string, summary:string}) => (<-tables:[A]) => [{A with _sent:string}]"}],"packages":[]},{"path":"contrib/sranka/sensu","name":"sensu","values":[{"name":"toSensuName","doc":"// toSensuName translates a string value to a Sensu name.\n// Characters not being [a-zA-Z0-9_.\\-] are replaced by underscore.\n","typ":"(v:string) => string"},{"name":"event","doc":"","typ":"(apiKey:string, checkName:string, text:A, url:string, ?entityName:string, ?handlers:[B], ?namespace:string, ?state:string, ?status:int) => int"},{"name":"endpoint","doc":"","typ":"(apiKey:string, url:string, ?entityName:string, ?handlers:[A], ?namespace:string) => (mapFn:(r:B) => {C with text:D, status:int, checkName:string}) => (<-tables:[B]) => [{B with _sent:string}]"}],"packages":[]}]},{"path":"contrib/tomhollingworth","name":"tomhollingworth","values":[],"packages":[{"path":"contrib/tomhollingworth/events","name":"events","values":[{"name":"duration","doc":"// duration will calculate the duration between records\n// for each record. The duration calculated is between\n// the current record and the next. The last record will\n// compare against either the stopColum (default: _stop)\n// or a stop timestamp value.\n//\n// `timeColumn` - Optional string. Default '_time'. The value used to calculate duration\n// `columnName` - Optional string. Default 'duration'. The name of the result column\n// `stopColumn` - Optional string. Default '_stop'. The name of the column to compare the last record on\n// `stop` - Optional Time. Use a fixed time to compare the last record against instead of stop column.\n","typ":"(<-tables:[A], ?columnName:string, ?stop:time, ?stopColumn:string, ?timeColumn:string, ?unit:duration) => [B]"}],"packages":[]}]},{"path":"contrib/chobbs","name":"chobbs","values":[],"packages":[{"path":"contrib/chobbs/discord","name":"discord","values":[{"name":"discordURL","doc":"","typ":"string"},{"name":"send","doc":"","typ":"(content:A, username:B, webhookID:string, webhookToken:string, ?avatar_url:string) => int"},{"name":"endpoint","doc":"","typ":"(username:A, webhookID:string, webhookToken:string, ?avatar_url:string) => (mapFn:(r:B) => {C with content:D}) => (<-tables:[B]) => [{B with _sent:string}]"}],"packages":[]}]},{"path":"contrib/RohanSreerama5","name":"RohanSreerama5","values":[],"packages":[{"path":"contrib/RohanSreerama5/naiveBayesClassifier","name":"naiveBayesClassifier","values":[{"name":"naiveBayes","doc":"","typ":"(<-tables:[{C with _time:time, _measurement:E, _field:D}], myClass:string, myField:A, myMeasurement:B) => [F]"}],"packages":[]},{"path":"contrib/RohanSreerama5/images","name":"images","values":[],"packages":[]}]},{"path":"contrib/anaisdg","name":"anaisdg","values":[],"packages":[{"path":"contrib/anaisdg/anomalydetection","name":"anomalydetection","values":[{"name":"mad","doc":"","typ":"(<-table:[A], ?threshold:float) => [{B with level:string, _value_diff_med:C, _value_diff:C, _value:C}]"}],"packages":[]},{"path":"contrib/anaisdg/statsmodels","name":"statsmodels","values":[{"name":"linearRegression","doc":"","typ":"(<-tables:[A]) => [{B with y_hat:float, y:float, x:float, sy:H, sxy:G, sxx:F, sx:E, slope:D, errors:float, N:C}]"}],"packages":[]}]}]},{"path":"date","name":"date","values":[{"name":"second","doc":"","typ":"(t:A) => int"},{"name":"minute","doc":"","typ":"(t:A) => int"},{"name":"hour","doc":"","typ":"(t:A) => int"},{"name":"weekDay","doc":"","typ":"(t:A) => int"},{"name":"monthDay","doc":"","typ":"(t:A) => int"},{"name":"yearDay","doc":"","typ":"(t:A) => int"},{"name":"month","doc":"","typ":"(t:A) => int"},{"name":"year","doc":"","typ":"(t:A) => int"},{"name":"week","doc":"","typ":"(t:A) => int"},{"name":"quarter","doc":"","typ":"(t:A) => int"},{"name":"millisecond","doc":"","typ":"(t:A) => int"},{"name":"microsecond","doc":"","typ":"(t:A) => int"},{"name":"nanosecond","doc":"","typ":"(t:A) => int"},{"name":"truncate","doc":"","typ":"(t:A, unit:duration) => time"},{"name":"Sunday","doc":"","typ":"int"},{"name":"Monday","doc":"","typ":"int"},{"name":"Tuesday","doc":"","typ":"int"},{"name":"Wednesday","doc":"","typ":"int"},{"name":"Thursday","doc":"","typ":"int"},{"name":"Friday","doc":"","typ":"int"},{"name":"Saturday","doc":"","typ":"int"},{"name":"January","doc":"","typ":"int"},{"name":"February","doc":"","typ":"int"},{"name":"March","doc":"","typ":"int"},{"name":"April","doc":"","typ":"int"},{"name":"May","doc":"","typ":"int"},{"name":"June","doc":"","typ":"int"},{"name":"July","doc":"","typ":"int"},{"name":"August","doc":"","typ":"int"},{"name":"September","doc":"","typ":"int"},{"name":"October","doc":"","typ":"int"},{"name":"November","doc":"","typ":"int"},{"name":"December","doc":"","typ":"int"}],"packages":[]}]}
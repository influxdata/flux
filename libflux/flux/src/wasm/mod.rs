use std::env;
use std::io;

// module for all flux WASM functions
pub use crate::ast::*;
use crate::docs;
pub use crate::formatter::convert_to_string;
pub use crate::{ast, find_var_type};
pub use fluxcore::parser::Parser;
use fluxcore::semantic::bootstrap;
pub use fluxcore::semantic::types::{MonoType, Tvar};
pub use wasm_bindgen::prelude::*;

#[derive(Debug)]
struct Error {
    msg: String,
}

impl From<env::VarError> for Error {
    fn from(err: env::VarError) -> Error {
        Error {
            msg: err.to_string(),
        }
    }
}

impl From<io::Error> for Error {
    fn from(err: io::Error) -> Error {
        Error {
            msg: format!("{:?}", err),
        }
    }
}

impl From<bootstrap::Error> for Error {
    fn from(err: bootstrap::Error) -> Error {
        Error { msg: err.msg }
    }
}

/// (Generated by WASM.)
#[wasm_bindgen]
pub fn parse(s: &str) -> JsValue {
    let mut p = Parser::new(s);
    let file = p.parse_file(String::from(""));

    JsValue::from_serde(&file).unwrap()
}

/// Format a JS file.
#[wasm_bindgen]
pub fn format_from_js_file(js_file: JsValue) -> String {
    if let Ok(file) = js_file.into_serde::<File>() {
        if let Ok(converted) = convert_to_string(&file) {
            return converted;
        }
    }
    "".to_string()
}

/// wasm version of the flux_find_var_type() API. Instead of returning a flat buffer that contains
/// the MonoType, it returns a JsValueã€‚
#[wasm_bindgen]
pub fn wasm_find_var_type(source: &str, file_name: &str, var_name: &str) -> JsValue {
    let mut p = Parser::new(source);
    let pkg: ast::Package = p.parse_file(file_name.to_string()).into();
    let ty = find_var_type(pkg, var_name.to_string()).unwrap_or(MonoType::Var(Tvar(0)));
    JsValue::from_serde(&ty).unwrap()
}

/// Gets json docs from a Flux identifier
#[wasm_bindgen]
pub fn get_json_documentation(flux_identifier: &str) -> JsValue {
    let d = docs();
    let mut doc = JsValue::UNDEFINED;

    for i in &d {
        // look for the given identifier
        if flux_identifier == i.name {
            // return that doc package
            let param = format!("{:?}", i);
            doc = JsValue::from_serde(&param).unwrap();
            break;
        }
    }

    doc
}

#[cfg(test)]
mod tests {
    use super::*;
    use wasm_bindgen_test::*;

    #[wasm_bindgen_test]
    pub fn json_docs_test() {
        let csv_doc = r#"PackageDoc { name: "csv", headline: "Package csv provides tools for working with data in annotated CSV format.", description: None, members: {"from": Function(FunctionDoc { name: "from", headline: "from is a function that retrieves data from a comma separated value (CSV) data source.", description: "A stream of tables are returned, each unique series contained within its own table. Each record in the table represents a single point in the series. Parameters is CSV data. Supports anonotated CSV or raw CSV. Use mode to specify the parsing mode.  is the file path of the CSV file to query. The path can be absolute or relative. If relative, it is relative to the workingdirectory of the  process. The CSV file must exist in the same filesystem running the  process.  is the CSV parsing mode. Default is annotations. Available annotation modes:annotations: Use CSV notations to determine column data types. raw: Parse all columns as strings and use the first row as the header rowand all subsequent rows as data. Query anotated CSV data from fileimport \"csv\"\n\ncsv.from(file: \"path/to/data-file.csv\")\nQuery raw data from CSV fileimport \"csv\"\n\ncsv.from(\n  file: \"/path/to/data-file.csv\",\n  mode: \"raw\"\n)\nQuery an annotated CSV stringimport \"csv\"\n\ncsvData = \"\n#datatype,string,long,dateTime:RFC3339,dateTime:RFC3339,dateTime:RFC3339,string,string,double\n#group,false,false,false,false,false,false,false,false\n#default,,,,,,,,\n,result,table,_start,_stop,_time,region,host,_value\n,mean,0,2018-05-08T20:50:00Z,2018-05-08T20:51:00Z,2018-05-08T20:50:00Z,east,A,15.43\n,mean,0,2018-05-08T20:50:00Z,2018-05-08T20:51:00Z,2018-05-08T20:50:20Z,east,B,59.25\n,mean,0,2018-05-08T20:50:00Z,2018-05-08T20:51:00Z,2018-05-08T20:50:40Z,east,C,52.62\n\"\n\ncsv.from(csv: csvData)\n\nQuery a raw CSV stringimport \"csv\"\n\ncsvData = \"\n_start,_stop,_time,region,host,_value\n2018-05-08T20:50:00Z,2018-05-08T20:51:00Z,2018-05-08T20:50:00Z,east,A,15.43\n2018-05-08T20:50:00Z,2018-05-08T20:51:00Z,2018-05-08T20:50:20Z,east,B,59.25\n2018-05-08T20:50:00Z,2018-05-08T20:51:00Z,2018-05-08T20:50:40Z,east,C,52.62\n\"\n\ncsv.from(\n  csv: csvData,\n  mode: \"raw\"\n)\n", parameters: [], flux_type: "(?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?token:string) => [{A with _value:B, _time:time, _measurement:string, _field:string}]" })} }"#;
        let want = JsValue::from_serde(csv_doc).unwrap();
        let got = get_json_documentation("csv");
        assert_eq!(want, got);
    }
}

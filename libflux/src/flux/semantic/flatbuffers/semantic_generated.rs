// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod fbsemantic {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;

    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum MonoType {
        NONE = 0,
        Basic = 1,
        Var = 2,
        Arr = 3,
        Row = 4,
        Fun = 5,
    }

    const ENUM_MIN_MONO_TYPE: u8 = 0;
    const ENUM_MAX_MONO_TYPE: u8 = 5;

    impl<'a> flatbuffers::Follow<'a> for MonoType {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for MonoType {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const MonoType;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const MonoType;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for MonoType {
        type Output = MonoType;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<MonoType>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_MONO_TYPE: [MonoType; 6] = [
        MonoType::NONE,
        MonoType::Basic,
        MonoType::Var,
        MonoType::Arr,
        MonoType::Row,
        MonoType::Fun,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_MONO_TYPE: [&'static str; 6] = ["NONE", "Basic", "Var", "Arr", "Row", "Fun"];

    pub fn enum_name_mono_type(e: MonoType) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_MONO_TYPE[index as usize]
    }

    pub struct MonoTypeUnionTableOffset {}
    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum Type {
        Bool = 0,
        Int = 1,
        Uint = 2,
        Float = 3,
        String = 4,
        Duration = 5,
        Time = 6,
        Regexp = 7,
        Bytes = 8,
    }

    const ENUM_MIN_TYPE: u8 = 0;
    const ENUM_MAX_TYPE: u8 = 8;

    impl<'a> flatbuffers::Follow<'a> for Type {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for Type {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const Type;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const Type;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for Type {
        type Output = Type;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<Type>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_TYPE: [Type; 9] = [
        Type::Bool,
        Type::Int,
        Type::Uint,
        Type::Float,
        Type::String,
        Type::Duration,
        Type::Time,
        Type::Regexp,
        Type::Bytes,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_TYPE: [&'static str; 9] = [
        "Bool", "Int", "Uint", "Float", "String", "Duration", "Time", "Regexp", "Bytes",
    ];

    pub fn enum_name_type(e: Type) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_TYPE[index as usize]
    }

    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum Kind {
        Addable = 0,
        Subtractable = 1,
        Divisible = 2,
        Numeric = 3,
        Comparable = 4,
        Equatable = 5,
        Nullable = 6,
        Row = 7,
        Signed = 8,
    }

    const ENUM_MIN_KIND: u8 = 0;
    const ENUM_MAX_KIND: u8 = 8;

    impl<'a> flatbuffers::Follow<'a> for Kind {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for Kind {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const Kind;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const Kind;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for Kind {
        type Output = Kind;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<Kind>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_KIND: [Kind; 9] = [
        Kind::Addable,
        Kind::Subtractable,
        Kind::Divisible,
        Kind::Numeric,
        Kind::Comparable,
        Kind::Equatable,
        Kind::Nullable,
        Kind::Row,
        Kind::Signed,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_KIND: [&'static str; 9] = [
        "Addable",
        "Subtractable",
        "Divisible",
        "Numeric",
        "Comparable",
        "Equatable",
        "Nullable",
        "Row",
        "Signed",
    ];

    pub fn enum_name_kind(e: Kind) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_KIND[index as usize]
    }

    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum Statement {
        NONE = 0,
        OptionStatement = 1,
        BuiltinStatement = 2,
        TestStatement = 3,
        ExpressionStatement = 4,
        ReturnStatement = 5,
    }

    const ENUM_MIN_STATEMENT: u8 = 0;
    const ENUM_MAX_STATEMENT: u8 = 5;

    impl<'a> flatbuffers::Follow<'a> for Statement {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for Statement {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const Statement;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const Statement;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for Statement {
        type Output = Statement;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<Statement>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_STATEMENT: [Statement; 6] = [
        Statement::NONE,
        Statement::OptionStatement,
        Statement::BuiltinStatement,
        Statement::TestStatement,
        Statement::ExpressionStatement,
        Statement::ReturnStatement,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_STATEMENT: [&'static str; 6] = [
        "NONE",
        "OptionStatement",
        "BuiltinStatement",
        "TestStatement",
        "ExpressionStatement",
        "ReturnStatement",
    ];

    pub fn enum_name_statement(e: Statement) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_STATEMENT[index as usize]
    }

    pub struct StatementUnionTableOffset {}
    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum Assignment {
        NONE = 0,
        MemberAssignment = 1,
        NativeVariableAssignment = 2,
    }

    const ENUM_MIN_ASSIGNMENT: u8 = 0;
    const ENUM_MAX_ASSIGNMENT: u8 = 2;

    impl<'a> flatbuffers::Follow<'a> for Assignment {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for Assignment {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const Assignment;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const Assignment;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for Assignment {
        type Output = Assignment;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<Assignment>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_ASSIGNMENT: [Assignment; 3] = [
        Assignment::NONE,
        Assignment::MemberAssignment,
        Assignment::NativeVariableAssignment,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_ASSIGNMENT: [&'static str; 3] =
        ["NONE", "MemberAssignment", "NativeVariableAssignment"];

    pub fn enum_name_assignment(e: Assignment) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_ASSIGNMENT[index as usize]
    }

    pub struct AssignmentUnionTableOffset {}
    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum Expression {
        NONE = 0,
        StringExpression = 1,
        ArrayExpression = 2,
        FunctionExpression = 3,
        BinaryExpression = 4,
        CallExpression = 5,
        ConditionalExpression = 6,
        IdentifierExpression = 7,
        LogicalExpression = 8,
        MemberExpression = 9,
        IndexExpression = 10,
        ObjectExpression = 11,
        UnaryExpression = 12,
        BooleanLiteral = 13,
        DateTimeLiteral = 14,
        DurationLiteral = 15,
        FloatLiteral = 16,
        IntegerLiteral = 17,
        StringLiteral = 18,
        RegexpLiteral = 19,
        UnsignedIntegerLiteral = 20,
    }

    const ENUM_MIN_EXPRESSION: u8 = 0;
    const ENUM_MAX_EXPRESSION: u8 = 20;

    impl<'a> flatbuffers::Follow<'a> for Expression {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for Expression {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const Expression;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const Expression;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for Expression {
        type Output = Expression;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<Expression>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_EXPRESSION: [Expression; 21] = [
        Expression::NONE,
        Expression::StringExpression,
        Expression::ArrayExpression,
        Expression::FunctionExpression,
        Expression::BinaryExpression,
        Expression::CallExpression,
        Expression::ConditionalExpression,
        Expression::IdentifierExpression,
        Expression::LogicalExpression,
        Expression::MemberExpression,
        Expression::IndexExpression,
        Expression::ObjectExpression,
        Expression::UnaryExpression,
        Expression::BooleanLiteral,
        Expression::DateTimeLiteral,
        Expression::DurationLiteral,
        Expression::FloatLiteral,
        Expression::IntegerLiteral,
        Expression::StringLiteral,
        Expression::RegexpLiteral,
        Expression::UnsignedIntegerLiteral,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_EXPRESSION: [&'static str; 21] = [
        "NONE",
        "StringExpression",
        "ArrayExpression",
        "FunctionExpression",
        "BinaryExpression",
        "CallExpression",
        "ConditionalExpression",
        "IdentifierExpression",
        "LogicalExpression",
        "MemberExpression",
        "IndexExpression",
        "ObjectExpression",
        "UnaryExpression",
        "BooleanLiteral",
        "DateTimeLiteral",
        "DurationLiteral",
        "FloatLiteral",
        "IntegerLiteral",
        "StringLiteral",
        "RegexpLiteral",
        "UnsignedIntegerLiteral",
    ];

    pub fn enum_name_expression(e: Expression) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_EXPRESSION[index as usize]
    }

    pub struct ExpressionUnionTableOffset {}
    #[allow(non_camel_case_types)]
    #[repr(i8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum Operator {
        MultiplicationOperator = 0,
        DivisionOperator = 1,
        ModuloOperator = 2,
        PowerOperator = 3,
        AdditionOperator = 4,
        SubtractionOperator = 5,
        LessThanEqualOperator = 6,
        LessThanOperator = 7,
        GreaterThanEqualOperator = 8,
        GreaterThanOperator = 9,
        StartsWithOperator = 10,
        InOperator = 11,
        NotOperator = 12,
        ExistsOperator = 13,
        NotEmptyOperator = 14,
        EmptyOperator = 15,
        EqualOperator = 16,
        NotEqualOperator = 17,
        RegexpMatchOperator = 18,
        NotRegexpMatchOperator = 19,
        InvalidOperator = 20,
    }

    const ENUM_MIN_OPERATOR: i8 = 0;
    const ENUM_MAX_OPERATOR: i8 = 20;

    impl<'a> flatbuffers::Follow<'a> for Operator {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for Operator {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = i8::to_le(self as i8);
            let p = &n as *const i8 as *const Operator;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = i8::from_le(self as i8);
            let p = &n as *const i8 as *const Operator;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for Operator {
        type Output = Operator;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<Operator>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_OPERATOR: [Operator; 21] = [
        Operator::MultiplicationOperator,
        Operator::DivisionOperator,
        Operator::ModuloOperator,
        Operator::PowerOperator,
        Operator::AdditionOperator,
        Operator::SubtractionOperator,
        Operator::LessThanEqualOperator,
        Operator::LessThanOperator,
        Operator::GreaterThanEqualOperator,
        Operator::GreaterThanOperator,
        Operator::StartsWithOperator,
        Operator::InOperator,
        Operator::NotOperator,
        Operator::ExistsOperator,
        Operator::NotEmptyOperator,
        Operator::EmptyOperator,
        Operator::EqualOperator,
        Operator::NotEqualOperator,
        Operator::RegexpMatchOperator,
        Operator::NotRegexpMatchOperator,
        Operator::InvalidOperator,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_OPERATOR: [&'static str; 21] = [
        "MultiplicationOperator",
        "DivisionOperator",
        "ModuloOperator",
        "PowerOperator",
        "AdditionOperator",
        "SubtractionOperator",
        "LessThanEqualOperator",
        "LessThanOperator",
        "GreaterThanEqualOperator",
        "GreaterThanOperator",
        "StartsWithOperator",
        "InOperator",
        "NotOperator",
        "ExistsOperator",
        "NotEmptyOperator",
        "EmptyOperator",
        "EqualOperator",
        "NotEqualOperator",
        "RegexpMatchOperator",
        "NotRegexpMatchOperator",
        "InvalidOperator",
    ];

    pub fn enum_name_operator(e: Operator) -> &'static str {
        let index = e as i8;
        ENUM_NAMES_OPERATOR[index as usize]
    }

    #[allow(non_camel_case_types)]
    #[repr(i8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum LogicalOperator {
        AndOperator = 0,
        OrOperator = 1,
    }

    const ENUM_MIN_LOGICAL_OPERATOR: i8 = 0;
    const ENUM_MAX_LOGICAL_OPERATOR: i8 = 1;

    impl<'a> flatbuffers::Follow<'a> for LogicalOperator {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for LogicalOperator {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = i8::to_le(self as i8);
            let p = &n as *const i8 as *const LogicalOperator;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = i8::from_le(self as i8);
            let p = &n as *const i8 as *const LogicalOperator;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for LogicalOperator {
        type Output = LogicalOperator;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<LogicalOperator>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_LOGICAL_OPERATOR: [LogicalOperator; 2] =
        [LogicalOperator::AndOperator, LogicalOperator::OrOperator];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_LOGICAL_OPERATOR: [&'static str; 2] = ["AndOperator", "OrOperator"];

    pub fn enum_name_logical_operator(e: LogicalOperator) -> &'static str {
        let index = e as i8;
        ENUM_NAMES_LOGICAL_OPERATOR[index as usize]
    }

    #[allow(non_camel_case_types)]
    #[repr(i8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum TimeUnit {
        y = 0,
        mo = 1,
        w = 2,
        d = 3,
        h = 4,
        m = 5,
        s = 6,
        ms = 7,
        us = 8,
        ns = 9,
    }

    const ENUM_MIN_TIME_UNIT: i8 = 0;
    const ENUM_MAX_TIME_UNIT: i8 = 9;

    impl<'a> flatbuffers::Follow<'a> for TimeUnit {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for TimeUnit {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = i8::to_le(self as i8);
            let p = &n as *const i8 as *const TimeUnit;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = i8::from_le(self as i8);
            let p = &n as *const i8 as *const TimeUnit;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for TimeUnit {
        type Output = TimeUnit;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<TimeUnit>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_TIME_UNIT: [TimeUnit; 10] = [
        TimeUnit::y,
        TimeUnit::mo,
        TimeUnit::w,
        TimeUnit::d,
        TimeUnit::h,
        TimeUnit::m,
        TimeUnit::s,
        TimeUnit::ms,
        TimeUnit::us,
        TimeUnit::ns,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_TIME_UNIT: [&'static str; 10] =
        ["y", "mo", "w", "d", "h", "m", "s", "ms", "us", "ns"];

    pub fn enum_name_time_unit(e: TimeUnit) -> &'static str {
        let index = e as i8;
        ENUM_NAMES_TIME_UNIT[index as usize]
    }

    // struct Position, aligned to 4
    #[repr(C, align(4))]
    #[derive(Clone, Copy, Debug, PartialEq)]
    pub struct Position {
        line_: i32,
        column_: i32,
    } // pub struct Position
    impl flatbuffers::SafeSliceAccess for Position {}
    impl<'a> flatbuffers::Follow<'a> for Position {
        type Inner = &'a Position;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Position>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Position {
        type Inner = &'a Position;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Position>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Position {
        type Output = Position;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(self as *const Position as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }
    impl<'b> flatbuffers::Push for &'b Position {
        type Output = Position;

        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(*self as *const Position as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }

    impl Position {
        pub fn new<'a>(_line: i32, _column: i32) -> Self {
            Position {
                line_: _line.to_little_endian(),
                column_: _column.to_little_endian(),
            }
        }
        pub fn line<'a>(&'a self) -> i32 {
            self.line_.from_little_endian()
        }
        pub fn column<'a>(&'a self) -> i32 {
            self.column_.from_little_endian()
        }
    }

    pub enum FresherOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Fresher<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Fresher<'a> {
        type Inner = Fresher<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Fresher<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Fresher { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FresherArgs,
        ) -> flatbuffers::WIPOffset<Fresher<'bldr>> {
            let mut builder = FresherBuilder::new(_fbb);
            builder.add_u(args.u);
            builder.finish()
        }

        pub const VT_U: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn u(&self) -> u64 {
            self._tab.get::<u64>(Fresher::VT_U, Some(0)).unwrap()
        }
    }

    pub struct FresherArgs {
        pub u: u64,
    }
    impl<'a> Default for FresherArgs {
        #[inline]
        fn default() -> Self {
            FresherArgs { u: 0 }
        }
    }
    pub struct FresherBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FresherBuilder<'a, 'b> {
        #[inline]
        pub fn add_u(&mut self, u: u64) {
            self.fbb_.push_slot::<u64>(Fresher::VT_U, u, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FresherBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FresherBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Fresher<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum TypeEnvironmentOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct TypeEnvironment<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TypeEnvironment<'a> {
        type Inner = TypeEnvironment<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> TypeEnvironment<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TypeEnvironment { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TypeEnvironmentArgs<'args>,
        ) -> flatbuffers::WIPOffset<TypeEnvironment<'bldr>> {
            let mut builder = TypeEnvironmentBuilder::new(_fbb);
            if let Some(x) = args.assignments {
                builder.add_assignments(x);
            }
            builder.finish()
        }

        pub const VT_ASSIGNMENTS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn assignments(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TypeAssignment<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<TypeAssignment<'a>>>,
            >>(TypeEnvironment::VT_ASSIGNMENTS, None)
        }
    }

    pub struct TypeEnvironmentArgs<'a> {
        pub assignments: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TypeAssignment<'a>>>,
            >,
        >,
    }
    impl<'a> Default for TypeEnvironmentArgs<'a> {
        #[inline]
        fn default() -> Self {
            TypeEnvironmentArgs { assignments: None }
        }
    }
    pub struct TypeEnvironmentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TypeEnvironmentBuilder<'a, 'b> {
        #[inline]
        pub fn add_assignments(
            &mut self,
            assignments: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TypeAssignment<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TypeEnvironment::VT_ASSIGNMENTS,
                assignments,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TypeEnvironmentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TypeEnvironmentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TypeEnvironment<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum TypeAssignmentOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct TypeAssignment<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TypeAssignment<'a> {
        type Inner = TypeAssignment<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> TypeAssignment<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TypeAssignment { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TypeAssignmentArgs<'args>,
        ) -> flatbuffers::WIPOffset<TypeAssignment<'bldr>> {
            let mut builder = TypeAssignmentBuilder::new(_fbb);
            if let Some(x) = args.ty {
                builder.add_ty(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.finish()
        }

        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_TY: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn id(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TypeAssignment::VT_ID, None)
        }
        #[inline]
        pub fn ty(&self) -> Option<PolyType<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<PolyType<'a>>>(TypeAssignment::VT_TY, None)
        }
    }

    pub struct TypeAssignmentArgs<'a> {
        pub id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub ty: Option<flatbuffers::WIPOffset<PolyType<'a>>>,
    }
    impl<'a> Default for TypeAssignmentArgs<'a> {
        #[inline]
        fn default() -> Self {
            TypeAssignmentArgs { id: None, ty: None }
        }
    }
    pub struct TypeAssignmentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TypeAssignmentBuilder<'a, 'b> {
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TypeAssignment::VT_ID, id);
        }
        #[inline]
        pub fn add_ty(&mut self, ty: flatbuffers::WIPOffset<PolyType<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<PolyType>>(TypeAssignment::VT_TY, ty);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TypeAssignmentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TypeAssignmentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TypeAssignment<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum VarOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Var<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Var<'a> {
        type Inner = Var<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Var<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Var { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args VarArgs,
        ) -> flatbuffers::WIPOffset<Var<'bldr>> {
            let mut builder = VarBuilder::new(_fbb);
            builder.add_i(args.i);
            builder.finish()
        }

        pub const VT_I: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn i(&self) -> u64 {
            self._tab.get::<u64>(Var::VT_I, Some(0)).unwrap()
        }
    }

    pub struct VarArgs {
        pub i: u64,
    }
    impl<'a> Default for VarArgs {
        #[inline]
        fn default() -> Self {
            VarArgs { i: 0 }
        }
    }
    pub struct VarBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> VarBuilder<'a, 'b> {
        #[inline]
        pub fn add_i(&mut self, i: u64) {
            self.fbb_.push_slot::<u64>(Var::VT_I, i, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VarBuilder<'a, 'b> {
            let start = _fbb.start_table();
            VarBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Var<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum BasicOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Basic<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Basic<'a> {
        type Inner = Basic<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Basic<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Basic { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BasicArgs,
        ) -> flatbuffers::WIPOffset<Basic<'bldr>> {
            let mut builder = BasicBuilder::new(_fbb);
            builder.add_t(args.t);
            builder.finish()
        }

        pub const VT_T: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn t(&self) -> Type {
            self._tab
                .get::<Type>(Basic::VT_T, Some(Type::Bool))
                .unwrap()
        }
    }

    pub struct BasicArgs {
        pub t: Type,
    }
    impl<'a> Default for BasicArgs {
        #[inline]
        fn default() -> Self {
            BasicArgs { t: Type::Bool }
        }
    }
    pub struct BasicBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BasicBuilder<'a, 'b> {
        #[inline]
        pub fn add_t(&mut self, t: Type) {
            self.fbb_.push_slot::<Type>(Basic::VT_T, t, Type::Bool);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BasicBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BasicBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Basic<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ArrOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Arr<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Arr<'a> {
        type Inner = Arr<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Arr<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Arr { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ArrArgs,
        ) -> flatbuffers::WIPOffset<Arr<'bldr>> {
            let mut builder = ArrBuilder::new(_fbb);
            if let Some(x) = args.t {
                builder.add_t(x);
            }
            builder.add_t_type(args.t_type);
            builder.finish()
        }

        pub const VT_T_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_T: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn t_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(Arr::VT_T_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn t(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Arr::VT_T, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_basic(&self) -> Option<Basic<'a>> {
            if self.t_type() == MonoType::Basic {
                self.t().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_var(&self) -> Option<Var<'a>> {
            if self.t_type() == MonoType::Var {
                self.t().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_arr(&self) -> Option<Arr<'a>> {
            if self.t_type() == MonoType::Arr {
                self.t().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_row(&self) -> Option<Row<'a>> {
            if self.t_type() == MonoType::Row {
                self.t().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_fun(&self) -> Option<Fun<'a>> {
            if self.t_type() == MonoType::Fun {
                self.t().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct ArrArgs {
        pub t_type: MonoType,
        pub t: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ArrArgs {
        #[inline]
        fn default() -> Self {
            ArrArgs {
                t_type: MonoType::NONE,
                t: None,
            }
        }
    }
    pub struct ArrBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ArrBuilder<'a, 'b> {
        #[inline]
        pub fn add_t_type(&mut self, t_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(Arr::VT_T_TYPE, t_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_t(&mut self, t: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Arr::VT_T, t);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ArrBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Arr<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum RowOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Row<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Row<'a> {
        type Inner = Row<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Row<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Row { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RowArgs<'args>,
        ) -> flatbuffers::WIPOffset<Row<'bldr>> {
            let mut builder = RowBuilder::new(_fbb);
            if let Some(x) = args.extends {
                builder.add_extends(x);
            }
            if let Some(x) = args.props {
                builder.add_props(x);
            }
            builder.finish()
        }

        pub const VT_PROPS: flatbuffers::VOffsetT = 4;
        pub const VT_EXTENDS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn props(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Prop<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<Prop<'a>>>,
            >>(Row::VT_PROPS, None)
        }
        #[inline]
        pub fn extends(&self) -> Option<Var<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Var<'a>>>(Row::VT_EXTENDS, None)
        }
    }

    pub struct RowArgs<'a> {
        pub props: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Prop<'a>>>>,
        >,
        pub extends: Option<flatbuffers::WIPOffset<Var<'a>>>,
    }
    impl<'a> Default for RowArgs<'a> {
        #[inline]
        fn default() -> Self {
            RowArgs {
                props: None,
                extends: None,
            }
        }
    }
    pub struct RowBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RowBuilder<'a, 'b> {
        #[inline]
        pub fn add_props(
            &mut self,
            props: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Prop<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Row::VT_PROPS, props);
        }
        #[inline]
        pub fn add_extends(&mut self, extends: flatbuffers::WIPOffset<Var<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Var>>(Row::VT_EXTENDS, extends);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RowBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RowBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Row<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FunOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Fun<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Fun<'a> {
        type Inner = Fun<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Fun<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Fun { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FunArgs<'args>,
        ) -> flatbuffers::WIPOffset<Fun<'bldr>> {
            let mut builder = FunBuilder::new(_fbb);
            if let Some(x) = args.retn {
                builder.add_retn(x);
            }
            if let Some(x) = args.args {
                builder.add_args(x);
            }
            builder.add_retn_type(args.retn_type);
            builder.finish()
        }

        pub const VT_ARGS: flatbuffers::VOffsetT = 4;
        pub const VT_RETN_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_RETN: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn args(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Argument<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<Argument<'a>>>,
            >>(Fun::VT_ARGS, None)
        }
        #[inline]
        pub fn retn_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(Fun::VT_RETN_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn retn(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Fun::VT_RETN, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn retn_as_basic(&self) -> Option<Basic<'a>> {
            if self.retn_type() == MonoType::Basic {
                self.retn().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn retn_as_var(&self) -> Option<Var<'a>> {
            if self.retn_type() == MonoType::Var {
                self.retn().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn retn_as_arr(&self) -> Option<Arr<'a>> {
            if self.retn_type() == MonoType::Arr {
                self.retn().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn retn_as_row(&self) -> Option<Row<'a>> {
            if self.retn_type() == MonoType::Row {
                self.retn().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn retn_as_fun(&self) -> Option<Fun<'a>> {
            if self.retn_type() == MonoType::Fun {
                self.retn().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct FunArgs<'a> {
        pub args: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Argument<'a>>>,
            >,
        >,
        pub retn_type: MonoType,
        pub retn: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for FunArgs<'a> {
        #[inline]
        fn default() -> Self {
            FunArgs {
                args: None,
                retn_type: MonoType::NONE,
                retn: None,
            }
        }
    }
    pub struct FunBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FunBuilder<'a, 'b> {
        #[inline]
        pub fn add_args(
            &mut self,
            args: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Argument<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Fun::VT_ARGS, args);
        }
        #[inline]
        pub fn add_retn_type(&mut self, retn_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(Fun::VT_RETN_TYPE, retn_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_retn(&mut self, retn: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Fun::VT_RETN, retn);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FunBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FunBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Fun<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ArgumentOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Argument<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Argument<'a> {
        type Inner = Argument<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Argument<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Argument { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ArgumentArgs<'args>,
        ) -> flatbuffers::WIPOffset<Argument<'bldr>> {
            let mut builder = ArgumentBuilder::new(_fbb);
            if let Some(x) = args.t {
                builder.add_t(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_optional(args.optional);
            builder.add_pipe(args.pipe);
            builder.add_t_type(args.t_type);
            builder.finish()
        }

        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_T_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_T: flatbuffers::VOffsetT = 8;
        pub const VT_PIPE: flatbuffers::VOffsetT = 10;
        pub const VT_OPTIONAL: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Argument::VT_NAME, None)
        }
        #[inline]
        pub fn t_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(Argument::VT_T_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn t(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Argument::VT_T, None)
        }
        #[inline]
        pub fn pipe(&self) -> bool {
            self._tab
                .get::<bool>(Argument::VT_PIPE, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn optional(&self) -> bool {
            self._tab
                .get::<bool>(Argument::VT_OPTIONAL, Some(false))
                .unwrap()
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_basic(&self) -> Option<Basic<'a>> {
            if self.t_type() == MonoType::Basic {
                self.t().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_var(&self) -> Option<Var<'a>> {
            if self.t_type() == MonoType::Var {
                self.t().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_arr(&self) -> Option<Arr<'a>> {
            if self.t_type() == MonoType::Arr {
                self.t().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_row(&self) -> Option<Row<'a>> {
            if self.t_type() == MonoType::Row {
                self.t().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn t_as_fun(&self) -> Option<Fun<'a>> {
            if self.t_type() == MonoType::Fun {
                self.t().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct ArgumentArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub t_type: MonoType,
        pub t: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub pipe: bool,
        pub optional: bool,
    }
    impl<'a> Default for ArgumentArgs<'a> {
        #[inline]
        fn default() -> Self {
            ArgumentArgs {
                name: None,
                t_type: MonoType::NONE,
                t: None,
                pipe: false,
                optional: false,
            }
        }
    }
    pub struct ArgumentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ArgumentBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Argument::VT_NAME, name);
        }
        #[inline]
        pub fn add_t_type(&mut self, t_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(Argument::VT_T_TYPE, t_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_t(&mut self, t: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Argument::VT_T, t);
        }
        #[inline]
        pub fn add_pipe(&mut self, pipe: bool) {
            self.fbb_.push_slot::<bool>(Argument::VT_PIPE, pipe, false);
        }
        #[inline]
        pub fn add_optional(&mut self, optional: bool) {
            self.fbb_
                .push_slot::<bool>(Argument::VT_OPTIONAL, optional, false);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArgumentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ArgumentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Argument<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum PropOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Prop<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Prop<'a> {
        type Inner = Prop<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Prop<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Prop { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PropArgs<'args>,
        ) -> flatbuffers::WIPOffset<Prop<'bldr>> {
            let mut builder = PropBuilder::new(_fbb);
            if let Some(x) = args.v {
                builder.add_v(x);
            }
            if let Some(x) = args.k {
                builder.add_k(x);
            }
            builder.add_v_type(args.v_type);
            builder.finish()
        }

        pub const VT_K: flatbuffers::VOffsetT = 4;
        pub const VT_V_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_V: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn k(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Prop::VT_K, None)
        }
        #[inline]
        pub fn v_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(Prop::VT_V_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn v(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Prop::VT_V, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_basic(&self) -> Option<Basic<'a>> {
            if self.v_type() == MonoType::Basic {
                self.v().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_var(&self) -> Option<Var<'a>> {
            if self.v_type() == MonoType::Var {
                self.v().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_arr(&self) -> Option<Arr<'a>> {
            if self.v_type() == MonoType::Arr {
                self.v().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_row(&self) -> Option<Row<'a>> {
            if self.v_type() == MonoType::Row {
                self.v().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn v_as_fun(&self) -> Option<Fun<'a>> {
            if self.v_type() == MonoType::Fun {
                self.v().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct PropArgs<'a> {
        pub k: Option<flatbuffers::WIPOffset<&'a str>>,
        pub v_type: MonoType,
        pub v: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for PropArgs<'a> {
        #[inline]
        fn default() -> Self {
            PropArgs {
                k: None,
                v_type: MonoType::NONE,
                v: None,
            }
        }
    }
    pub struct PropBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PropBuilder<'a, 'b> {
        #[inline]
        pub fn add_k(&mut self, k: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Prop::VT_K, k);
        }
        #[inline]
        pub fn add_v_type(&mut self, v_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(Prop::VT_V_TYPE, v_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_v(&mut self, v: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Prop::VT_V, v);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PropBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PropBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Prop<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum PolyTypeOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct PolyType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PolyType<'a> {
        type Inner = PolyType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> PolyType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PolyType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PolyTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<PolyType<'bldr>> {
            let mut builder = PolyTypeBuilder::new(_fbb);
            if let Some(x) = args.expr {
                builder.add_expr(x);
            }
            if let Some(x) = args.cons {
                builder.add_cons(x);
            }
            if let Some(x) = args.vars {
                builder.add_vars(x);
            }
            builder.add_expr_type(args.expr_type);
            builder.finish()
        }

        pub const VT_VARS: flatbuffers::VOffsetT = 4;
        pub const VT_CONS: flatbuffers::VOffsetT = 6;
        pub const VT_EXPR_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_EXPR: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn vars(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Var<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<Var<'a>>>,
            >>(PolyType::VT_VARS, None)
        }
        #[inline]
        pub fn cons(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Constraint<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<Constraint<'a>>>,
            >>(PolyType::VT_CONS, None)
        }
        #[inline]
        pub fn expr_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(PolyType::VT_EXPR_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn expr(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    PolyType::VT_EXPR,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_basic(&self) -> Option<Basic<'a>> {
            if self.expr_type() == MonoType::Basic {
                self.expr().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_var(&self) -> Option<Var<'a>> {
            if self.expr_type() == MonoType::Var {
                self.expr().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_arr(&self) -> Option<Arr<'a>> {
            if self.expr_type() == MonoType::Arr {
                self.expr().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_row(&self) -> Option<Row<'a>> {
            if self.expr_type() == MonoType::Row {
                self.expr().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_fun(&self) -> Option<Fun<'a>> {
            if self.expr_type() == MonoType::Fun {
                self.expr().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct PolyTypeArgs<'a> {
        pub vars: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Var<'a>>>>,
        >,
        pub cons: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Constraint<'a>>>,
            >,
        >,
        pub expr_type: MonoType,
        pub expr: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for PolyTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            PolyTypeArgs {
                vars: None,
                cons: None,
                expr_type: MonoType::NONE,
                expr: None,
            }
        }
    }
    pub struct PolyTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PolyTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_vars(
            &mut self,
            vars: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Var<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PolyType::VT_VARS, vars);
        }
        #[inline]
        pub fn add_cons(
            &mut self,
            cons: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Constraint<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PolyType::VT_CONS, cons);
        }
        #[inline]
        pub fn add_expr_type(&mut self, expr_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(PolyType::VT_EXPR_TYPE, expr_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_expr(&mut self, expr: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PolyType::VT_EXPR, expr);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PolyTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PolyTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PolyType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ConstraintOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Constraint<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Constraint<'a> {
        type Inner = Constraint<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Constraint<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Constraint { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ConstraintArgs<'args>,
        ) -> flatbuffers::WIPOffset<Constraint<'bldr>> {
            let mut builder = ConstraintBuilder::new(_fbb);
            if let Some(x) = args.tvar {
                builder.add_tvar(x);
            }
            builder.add_kind(args.kind);
            builder.finish()
        }

        pub const VT_TVAR: flatbuffers::VOffsetT = 4;
        pub const VT_KIND: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn tvar(&self) -> Option<Var<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Var<'a>>>(Constraint::VT_TVAR, None)
        }
        #[inline]
        pub fn kind(&self) -> Kind {
            self._tab
                .get::<Kind>(Constraint::VT_KIND, Some(Kind::Addable))
                .unwrap()
        }
    }

    pub struct ConstraintArgs<'a> {
        pub tvar: Option<flatbuffers::WIPOffset<Var<'a>>>,
        pub kind: Kind,
    }
    impl<'a> Default for ConstraintArgs<'a> {
        #[inline]
        fn default() -> Self {
            ConstraintArgs {
                tvar: None,
                kind: Kind::Addable,
            }
        }
    }
    pub struct ConstraintBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ConstraintBuilder<'a, 'b> {
        #[inline]
        pub fn add_tvar(&mut self, tvar: flatbuffers::WIPOffset<Var<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Var>>(Constraint::VT_TVAR, tvar);
        }
        #[inline]
        pub fn add_kind(&mut self, kind: Kind) {
            self.fbb_
                .push_slot::<Kind>(Constraint::VT_KIND, kind, Kind::Addable);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConstraintBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ConstraintBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Constraint<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum PackageOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Package<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Package<'a> {
        type Inner = Package<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Package<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Package { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PackageArgs<'args>,
        ) -> flatbuffers::WIPOffset<Package<'bldr>> {
            let mut builder = PackageBuilder::new(_fbb);
            if let Some(x) = args.files {
                builder.add_files(x);
            }
            if let Some(x) = args.package {
                builder.add_package(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_PACKAGE: flatbuffers::VOffsetT = 6;
        pub const VT_FILES: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(Package::VT_LOC, None)
        }
        #[inline]
        pub fn package(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Package::VT_PACKAGE, None)
        }
        #[inline]
        pub fn files(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<File<'a>>>,
            >>(Package::VT_FILES, None)
        }
    }

    pub struct PackageArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub package: Option<flatbuffers::WIPOffset<&'a str>>,
        pub files: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File<'a>>>>,
        >,
    }
    impl<'a> Default for PackageArgs<'a> {
        #[inline]
        fn default() -> Self {
            PackageArgs {
                loc: None,
                package: None,
                files: None,
            }
        }
    }
    pub struct PackageBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PackageBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(Package::VT_LOC, loc);
        }
        #[inline]
        pub fn add_package(&mut self, package: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_PACKAGE, package);
        }
        #[inline]
        pub fn add_files(
            &mut self,
            files: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<File<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_FILES, files);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PackageBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PackageBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Package<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FileOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct File<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for File<'a> {
        type Inner = File<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> File<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            File { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FileArgs<'args>,
        ) -> flatbuffers::WIPOffset<File<'bldr>> {
            let mut builder = FileBuilder::new(_fbb);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.imports {
                builder.add_imports(x);
            }
            if let Some(x) = args.package {
                builder.add_package(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_PACKAGE: flatbuffers::VOffsetT = 6;
        pub const VT_IMPORTS: flatbuffers::VOffsetT = 8;
        pub const VT_BODY: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(File::VT_LOC, None)
        }
        #[inline]
        pub fn package(&self) -> Option<PackageClause<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<PackageClause<'a>>>(File::VT_PACKAGE, None)
        }
        #[inline]
        pub fn imports(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ImportDeclaration<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<ImportDeclaration<'a>>>,
            >>(File::VT_IMPORTS, None)
        }
        #[inline]
        pub fn body(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>,
            >>(File::VT_BODY, None)
        }
    }

    pub struct FileArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub package: Option<flatbuffers::WIPOffset<PackageClause<'a>>>,
        pub imports: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ImportDeclaration<'a>>>,
            >,
        >,
        pub body: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>,
            >,
        >,
    }
    impl<'a> Default for FileArgs<'a> {
        #[inline]
        fn default() -> Self {
            FileArgs {
                loc: None,
                package: None,
                imports: None,
                body: None,
            }
        }
    }
    pub struct FileBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FileBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(File::VT_LOC, loc);
        }
        #[inline]
        pub fn add_package(&mut self, package: flatbuffers::WIPOffset<PackageClause<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<PackageClause>>(
                    File::VT_PACKAGE,
                    package,
                );
        }
        #[inline]
        pub fn add_imports(
            &mut self,
            imports: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ImportDeclaration<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_IMPORTS, imports);
        }
        #[inline]
        pub fn add_body(
            &mut self,
            body: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<WrappedStatement<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_BODY, body);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FileBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FileBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<File<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum PackageClauseOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct PackageClause<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PackageClause<'a> {
        type Inner = PackageClause<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> PackageClause<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PackageClause { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PackageClauseArgs<'args>,
        ) -> flatbuffers::WIPOffset<PackageClause<'bldr>> {
            let mut builder = PackageClauseBuilder::new(_fbb);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    PackageClause::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn name(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(PackageClause::VT_NAME, None)
        }
    }

    pub struct PackageClauseArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub name: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    }
    impl<'a> Default for PackageClauseArgs<'a> {
        #[inline]
        fn default() -> Self {
            PackageClauseArgs {
                loc: None,
                name: None,
            }
        }
    }
    pub struct PackageClauseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PackageClauseBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    PackageClause::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    PackageClause::VT_NAME,
                    name,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> PackageClauseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PackageClauseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PackageClause<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ImportDeclarationOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct ImportDeclaration<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ImportDeclaration<'a> {
        type Inner = ImportDeclaration<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> ImportDeclaration<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ImportDeclaration { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ImportDeclarationArgs<'args>,
        ) -> flatbuffers::WIPOffset<ImportDeclaration<'bldr>> {
            let mut builder = ImportDeclarationBuilder::new(_fbb);
            if let Some(x) = args.path {
                builder.add_path(x);
            }
            if let Some(x) = args.alias {
                builder.add_alias(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ALIAS: flatbuffers::VOffsetT = 6;
        pub const VT_PATH: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    ImportDeclaration::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn alias(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(
                    ImportDeclaration::VT_ALIAS,
                    None,
                )
        }
        #[inline]
        pub fn path(&self) -> Option<StringLiteral<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<StringLiteral<'a>>>(
                    ImportDeclaration::VT_PATH,
                    None,
                )
        }
    }

    pub struct ImportDeclarationArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub alias: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub path: Option<flatbuffers::WIPOffset<StringLiteral<'a>>>,
    }
    impl<'a> Default for ImportDeclarationArgs<'a> {
        #[inline]
        fn default() -> Self {
            ImportDeclarationArgs {
                loc: None,
                alias: None,
                path: None,
            }
        }
    }
    pub struct ImportDeclarationBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ImportDeclarationBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    ImportDeclaration::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_alias(&mut self, alias: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    ImportDeclaration::VT_ALIAS,
                    alias,
                );
        }
        #[inline]
        pub fn add_path(&mut self, path: flatbuffers::WIPOffset<StringLiteral<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<StringLiteral>>(
                    ImportDeclaration::VT_PATH,
                    path,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ImportDeclarationBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ImportDeclarationBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ImportDeclaration<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum SourceLocationOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct SourceLocation<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SourceLocation<'a> {
        type Inner = SourceLocation<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> SourceLocation<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SourceLocation { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SourceLocationArgs<'args>,
        ) -> flatbuffers::WIPOffset<SourceLocation<'bldr>> {
            let mut builder = SourceLocationBuilder::new(_fbb);
            if let Some(x) = args.source {
                builder.add_source(x);
            }
            if let Some(x) = args.end {
                builder.add_end(x);
            }
            if let Some(x) = args.start {
                builder.add_start(x);
            }
            if let Some(x) = args.file {
                builder.add_file(x);
            }
            builder.finish()
        }

        pub const VT_FILE: flatbuffers::VOffsetT = 4;
        pub const VT_START: flatbuffers::VOffsetT = 6;
        pub const VT_END: flatbuffers::VOffsetT = 8;
        pub const VT_SOURCE: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn file(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SourceLocation::VT_FILE, None)
        }
        #[inline]
        pub fn start(&self) -> Option<&'a Position> {
            self._tab.get::<Position>(SourceLocation::VT_START, None)
        }
        #[inline]
        pub fn end(&self) -> Option<&'a Position> {
            self._tab.get::<Position>(SourceLocation::VT_END, None)
        }
        #[inline]
        pub fn source(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SourceLocation::VT_SOURCE, None)
        }
    }

    pub struct SourceLocationArgs<'a> {
        pub file: Option<flatbuffers::WIPOffset<&'a str>>,
        pub start: Option<&'a Position>,
        pub end: Option<&'a Position>,
        pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for SourceLocationArgs<'a> {
        #[inline]
        fn default() -> Self {
            SourceLocationArgs {
                file: None,
                start: None,
                end: None,
                source: None,
            }
        }
    }
    pub struct SourceLocationBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SourceLocationBuilder<'a, 'b> {
        #[inline]
        pub fn add_file(&mut self, file: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SourceLocation::VT_FILE, file);
        }
        #[inline]
        pub fn add_start(&mut self, start: &'b Position) {
            self.fbb_
                .push_slot_always::<&Position>(SourceLocation::VT_START, start);
        }
        #[inline]
        pub fn add_end(&mut self, end: &'b Position) {
            self.fbb_
                .push_slot_always::<&Position>(SourceLocation::VT_END, end);
        }
        #[inline]
        pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SourceLocation::VT_SOURCE, source);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SourceLocationBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SourceLocationBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SourceLocation<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum WrappedStatementOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct WrappedStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for WrappedStatement<'a> {
        type Inner = WrappedStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> WrappedStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            WrappedStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args WrappedStatementArgs,
        ) -> flatbuffers::WIPOffset<WrappedStatement<'bldr>> {
            let mut builder = WrappedStatementBuilder::new(_fbb);
            if let Some(x) = args.statement {
                builder.add_statement(x);
            }
            builder.add_statement_type(args.statement_type);
            builder.finish()
        }

        pub const VT_STATEMENT_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_STATEMENT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn statement_type(&self) -> Statement {
            self._tab
                .get::<Statement>(WrappedStatement::VT_STATEMENT_TYPE, Some(Statement::NONE))
                .unwrap()
        }
        #[inline]
        pub fn statement(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    WrappedStatement::VT_STATEMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_option_statement(&self) -> Option<OptionStatement<'a>> {
            if self.statement_type() == Statement::OptionStatement {
                self.statement()
                    .map(|u| OptionStatement::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_builtin_statement(&self) -> Option<BuiltinStatement<'a>> {
            if self.statement_type() == Statement::BuiltinStatement {
                self.statement()
                    .map(|u| BuiltinStatement::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_test_statement(&self) -> Option<TestStatement<'a>> {
            if self.statement_type() == Statement::TestStatement {
                self.statement().map(|u| TestStatement::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_expression_statement(&self) -> Option<ExpressionStatement<'a>> {
            if self.statement_type() == Statement::ExpressionStatement {
                self.statement()
                    .map(|u| ExpressionStatement::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_return_statement(&self) -> Option<ReturnStatement<'a>> {
            if self.statement_type() == Statement::ReturnStatement {
                self.statement()
                    .map(|u| ReturnStatement::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct WrappedStatementArgs {
        pub statement_type: Statement,
        pub statement: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for WrappedStatementArgs {
        #[inline]
        fn default() -> Self {
            WrappedStatementArgs {
                statement_type: Statement::NONE,
                statement: None,
            }
        }
    }
    pub struct WrappedStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> WrappedStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_statement_type(&mut self, statement_type: Statement) {
            self.fbb_.push_slot::<Statement>(
                WrappedStatement::VT_STATEMENT_TYPE,
                statement_type,
                Statement::NONE,
            );
        }
        #[inline]
        pub fn add_statement(
            &mut self,
            statement: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                WrappedStatement::VT_STATEMENT,
                statement,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> WrappedStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            WrappedStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<WrappedStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum OptionStatementOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct OptionStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for OptionStatement<'a> {
        type Inner = OptionStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> OptionStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            OptionStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args OptionStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<OptionStatement<'bldr>> {
            let mut builder = OptionStatementBuilder::new(_fbb);
            if let Some(x) = args.assignment {
                builder.add_assignment(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_assignment_type(args.assignment_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ASSIGNMENT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ASSIGNMENT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    OptionStatement::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn assignment_type(&self) -> Assignment {
            self._tab
                .get::<Assignment>(OptionStatement::VT_ASSIGNMENT_TYPE, Some(Assignment::NONE))
                .unwrap()
        }
        #[inline]
        pub fn assignment(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    OptionStatement::VT_ASSIGNMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn assignment_as_member_assignment(&self) -> Option<MemberAssignment<'a>> {
            if self.assignment_type() == Assignment::MemberAssignment {
                self.assignment()
                    .map(|u| MemberAssignment::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn assignment_as_native_variable_assignment(
            &self,
        ) -> Option<NativeVariableAssignment<'a>> {
            if self.assignment_type() == Assignment::NativeVariableAssignment {
                self.assignment()
                    .map(|u| NativeVariableAssignment::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct OptionStatementArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub assignment_type: Assignment,
        pub assignment: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for OptionStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            OptionStatementArgs {
                loc: None,
                assignment_type: Assignment::NONE,
                assignment: None,
            }
        }
    }
    pub struct OptionStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> OptionStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    OptionStatement::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_assignment_type(&mut self, assignment_type: Assignment) {
            self.fbb_.push_slot::<Assignment>(
                OptionStatement::VT_ASSIGNMENT_TYPE,
                assignment_type,
                Assignment::NONE,
            );
        }
        #[inline]
        pub fn add_assignment(
            &mut self,
            assignment: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                OptionStatement::VT_ASSIGNMENT,
                assignment,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> OptionStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            OptionStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<OptionStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum BuiltinStatementOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct BuiltinStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BuiltinStatement<'a> {
        type Inner = BuiltinStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> BuiltinStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BuiltinStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BuiltinStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<BuiltinStatement<'bldr>> {
            let mut builder = BuiltinStatementBuilder::new(_fbb);
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    BuiltinStatement::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn id(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(BuiltinStatement::VT_ID, None)
        }
    }

    pub struct BuiltinStatementArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    }
    impl<'a> Default for BuiltinStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            BuiltinStatementArgs {
                loc: None,
                id: None,
            }
        }
    }
    pub struct BuiltinStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BuiltinStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    BuiltinStatement::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    BuiltinStatement::VT_ID,
                    id,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BuiltinStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BuiltinStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BuiltinStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum TestStatementOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct TestStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TestStatement<'a> {
        type Inner = TestStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> TestStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TestStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TestStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<TestStatement<'bldr>> {
            let mut builder = TestStatementBuilder::new(_fbb);
            if let Some(x) = args.assignment {
                builder.add_assignment(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ASSIGNMENT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    TestStatement::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn assignment(&self) -> Option<NativeVariableAssignment<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<NativeVariableAssignment<'a>>>(
                    TestStatement::VT_ASSIGNMENT,
                    None,
                )
        }
    }

    pub struct TestStatementArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub assignment: Option<flatbuffers::WIPOffset<NativeVariableAssignment<'a>>>,
    }
    impl<'a> Default for TestStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            TestStatementArgs {
                loc: None,
                assignment: None,
            }
        }
    }
    pub struct TestStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TestStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    TestStatement::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_assignment(
            &mut self,
            assignment: flatbuffers::WIPOffset<NativeVariableAssignment<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<NativeVariableAssignment>>(
                    TestStatement::VT_ASSIGNMENT,
                    assignment,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TestStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TestStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TestStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ExpressionStatementOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct ExpressionStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ExpressionStatement<'a> {
        type Inner = ExpressionStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> ExpressionStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ExpressionStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ExpressionStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<ExpressionStatement<'bldr>> {
            let mut builder = ExpressionStatementBuilder::new(_fbb);
            if let Some(x) = args.expression {
                builder.add_expression(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_expression_type(args.expression_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_EXPRESSION_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_EXPRESSION: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    ExpressionStatement::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn expression_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    ExpressionStatement::VT_EXPRESSION_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn expression(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ExpressionStatement::VT_EXPRESSION,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.expression_type() == Expression::StringExpression {
                self.expression()
                    .map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.expression_type() == Expression::ArrayExpression {
                self.expression()
                    .map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.expression_type() == Expression::FunctionExpression {
                self.expression()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.expression_type() == Expression::BinaryExpression {
                self.expression()
                    .map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.expression_type() == Expression::CallExpression {
                self.expression()
                    .map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.expression_type() == Expression::ConditionalExpression {
                self.expression()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.expression_type() == Expression::IdentifierExpression {
                self.expression()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.expression_type() == Expression::LogicalExpression {
                self.expression()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.expression_type() == Expression::MemberExpression {
                self.expression()
                    .map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.expression_type() == Expression::IndexExpression {
                self.expression()
                    .map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.expression_type() == Expression::ObjectExpression {
                self.expression()
                    .map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.expression_type() == Expression::UnaryExpression {
                self.expression()
                    .map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.expression_type() == Expression::BooleanLiteral {
                self.expression()
                    .map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.expression_type() == Expression::DateTimeLiteral {
                self.expression()
                    .map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.expression_type() == Expression::DurationLiteral {
                self.expression()
                    .map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.expression_type() == Expression::FloatLiteral {
                self.expression().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.expression_type() == Expression::IntegerLiteral {
                self.expression()
                    .map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.expression_type() == Expression::StringLiteral {
                self.expression().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.expression_type() == Expression::RegexpLiteral {
                self.expression().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.expression_type() == Expression::UnsignedIntegerLiteral {
                self.expression()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct ExpressionStatementArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub expression_type: Expression,
        pub expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ExpressionStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            ExpressionStatementArgs {
                loc: None,
                expression_type: Expression::NONE,
                expression: None,
            }
        }
    }
    pub struct ExpressionStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ExpressionStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    ExpressionStatement::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_expression_type(&mut self, expression_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ExpressionStatement::VT_EXPRESSION_TYPE,
                expression_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_expression(
            &mut self,
            expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ExpressionStatement::VT_EXPRESSION,
                expression,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ExpressionStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ExpressionStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ExpressionStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ReturnStatementOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct ReturnStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ReturnStatement<'a> {
        type Inner = ReturnStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> ReturnStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ReturnStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ReturnStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<ReturnStatement<'bldr>> {
            let mut builder = ReturnStatementBuilder::new(_fbb);
            if let Some(x) = args.argument {
                builder.add_argument(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_argument_type(args.argument_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ARGUMENT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ARGUMENT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    ReturnStatement::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn argument_type(&self) -> Expression {
            self._tab
                .get::<Expression>(ReturnStatement::VT_ARGUMENT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn argument(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ReturnStatement::VT_ARGUMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.argument_type() == Expression::StringExpression {
                self.argument()
                    .map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.argument_type() == Expression::ArrayExpression {
                self.argument().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.argument_type() == Expression::FunctionExpression {
                self.argument()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.argument_type() == Expression::BinaryExpression {
                self.argument()
                    .map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.argument_type() == Expression::CallExpression {
                self.argument().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.argument_type() == Expression::ConditionalExpression {
                self.argument()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.argument_type() == Expression::IdentifierExpression {
                self.argument()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.argument_type() == Expression::LogicalExpression {
                self.argument()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.argument_type() == Expression::MemberExpression {
                self.argument()
                    .map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.argument_type() == Expression::IndexExpression {
                self.argument().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.argument_type() == Expression::ObjectExpression {
                self.argument()
                    .map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.argument_type() == Expression::UnaryExpression {
                self.argument().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.argument_type() == Expression::BooleanLiteral {
                self.argument().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.argument_type() == Expression::DateTimeLiteral {
                self.argument().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.argument_type() == Expression::DurationLiteral {
                self.argument().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.argument_type() == Expression::FloatLiteral {
                self.argument().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.argument_type() == Expression::IntegerLiteral {
                self.argument().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.argument_type() == Expression::StringLiteral {
                self.argument().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.argument_type() == Expression::RegexpLiteral {
                self.argument().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.argument_type() == Expression::UnsignedIntegerLiteral {
                self.argument()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct ReturnStatementArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub argument_type: Expression,
        pub argument: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ReturnStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            ReturnStatementArgs {
                loc: None,
                argument_type: Expression::NONE,
                argument: None,
            }
        }
    }
    pub struct ReturnStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ReturnStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    ReturnStatement::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_argument_type(&mut self, argument_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ReturnStatement::VT_ARGUMENT_TYPE,
                argument_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_argument(
            &mut self,
            argument: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ReturnStatement::VT_ARGUMENT,
                argument,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ReturnStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ReturnStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ReturnStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum NativeVariableAssignmentOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct NativeVariableAssignment<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NativeVariableAssignment<'a> {
        type Inner = NativeVariableAssignment<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> NativeVariableAssignment<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NativeVariableAssignment { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args NativeVariableAssignmentArgs<'args>,
        ) -> flatbuffers::WIPOffset<NativeVariableAssignment<'bldr>> {
            let mut builder = NativeVariableAssignmentBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.init_ {
                builder.add_init_(x);
            }
            if let Some(x) = args.identifier {
                builder.add_identifier(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_init__type(args.init__type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_IDENTIFIER: flatbuffers::VOffsetT = 6;
        pub const VT_INIT__TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_INIT_: flatbuffers::VOffsetT = 10;
        pub const VT_TYP: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    NativeVariableAssignment::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn identifier(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(
                    NativeVariableAssignment::VT_IDENTIFIER,
                    None,
                )
        }
        #[inline]
        pub fn init__type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    NativeVariableAssignment::VT_INIT__TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn init_(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    NativeVariableAssignment::VT_INIT_,
                    None,
                )
        }
        #[inline]
        pub fn typ(&self) -> Option<PolyType<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<PolyType<'a>>>(
                NativeVariableAssignment::VT_TYP,
                None,
            )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.init__type() == Expression::StringExpression {
                self.init_().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.init__type() == Expression::ArrayExpression {
                self.init_().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.init__type() == Expression::FunctionExpression {
                self.init_().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.init__type() == Expression::BinaryExpression {
                self.init_().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.init__type() == Expression::CallExpression {
                self.init_().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.init__type() == Expression::ConditionalExpression {
                self.init_()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.init__type() == Expression::IdentifierExpression {
                self.init_()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.init__type() == Expression::LogicalExpression {
                self.init_().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.init__type() == Expression::MemberExpression {
                self.init_().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.init__type() == Expression::IndexExpression {
                self.init_().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.init__type() == Expression::ObjectExpression {
                self.init_().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.init__type() == Expression::UnaryExpression {
                self.init_().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.init__type() == Expression::BooleanLiteral {
                self.init_().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.init__type() == Expression::DateTimeLiteral {
                self.init_().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.init__type() == Expression::DurationLiteral {
                self.init_().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.init__type() == Expression::FloatLiteral {
                self.init_().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.init__type() == Expression::IntegerLiteral {
                self.init_().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.init__type() == Expression::StringLiteral {
                self.init_().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.init__type() == Expression::RegexpLiteral {
                self.init_().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.init__type() == Expression::UnsignedIntegerLiteral {
                self.init_()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct NativeVariableAssignmentArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub identifier: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub init__type: Expression,
        pub init_: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub typ: Option<flatbuffers::WIPOffset<PolyType<'a>>>,
    }
    impl<'a> Default for NativeVariableAssignmentArgs<'a> {
        #[inline]
        fn default() -> Self {
            NativeVariableAssignmentArgs {
                loc: None,
                identifier: None,
                init__type: Expression::NONE,
                init_: None,
                typ: None,
            }
        }
    }
    pub struct NativeVariableAssignmentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NativeVariableAssignmentBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    NativeVariableAssignment::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_identifier(&mut self, identifier: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    NativeVariableAssignment::VT_IDENTIFIER,
                    identifier,
                );
        }
        #[inline]
        pub fn add_init__type(&mut self, init__type: Expression) {
            self.fbb_.push_slot::<Expression>(
                NativeVariableAssignment::VT_INIT__TYPE,
                init__type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_init_(&mut self, init_: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NativeVariableAssignment::VT_INIT_,
                init_,
            );
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<PolyType<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<PolyType>>(
                    NativeVariableAssignment::VT_TYP,
                    typ,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> NativeVariableAssignmentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            NativeVariableAssignmentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NativeVariableAssignment<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum MemberAssignmentOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct MemberAssignment<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MemberAssignment<'a> {
        type Inner = MemberAssignment<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> MemberAssignment<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MemberAssignment { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MemberAssignmentArgs<'args>,
        ) -> flatbuffers::WIPOffset<MemberAssignment<'bldr>> {
            let mut builder = MemberAssignmentBuilder::new(_fbb);
            if let Some(x) = args.init_ {
                builder.add_init_(x);
            }
            if let Some(x) = args.member {
                builder.add_member(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_init__type(args.init__type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_MEMBER: flatbuffers::VOffsetT = 6;
        pub const VT_INIT__TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_INIT_: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    MemberAssignment::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn member(&self) -> Option<MemberExpression<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<MemberExpression<'a>>>(
                    MemberAssignment::VT_MEMBER,
                    None,
                )
        }
        #[inline]
        pub fn init__type(&self) -> Expression {
            self._tab
                .get::<Expression>(MemberAssignment::VT_INIT__TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn init_(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    MemberAssignment::VT_INIT_,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.init__type() == Expression::StringExpression {
                self.init_().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.init__type() == Expression::ArrayExpression {
                self.init_().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.init__type() == Expression::FunctionExpression {
                self.init_().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.init__type() == Expression::BinaryExpression {
                self.init_().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.init__type() == Expression::CallExpression {
                self.init_().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.init__type() == Expression::ConditionalExpression {
                self.init_()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.init__type() == Expression::IdentifierExpression {
                self.init_()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.init__type() == Expression::LogicalExpression {
                self.init_().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.init__type() == Expression::MemberExpression {
                self.init_().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.init__type() == Expression::IndexExpression {
                self.init_().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.init__type() == Expression::ObjectExpression {
                self.init_().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.init__type() == Expression::UnaryExpression {
                self.init_().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.init__type() == Expression::BooleanLiteral {
                self.init_().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.init__type() == Expression::DateTimeLiteral {
                self.init_().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.init__type() == Expression::DurationLiteral {
                self.init_().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.init__type() == Expression::FloatLiteral {
                self.init_().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.init__type() == Expression::IntegerLiteral {
                self.init_().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.init__type() == Expression::StringLiteral {
                self.init_().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.init__type() == Expression::RegexpLiteral {
                self.init_().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.init__type() == Expression::UnsignedIntegerLiteral {
                self.init_()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct MemberAssignmentArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub member: Option<flatbuffers::WIPOffset<MemberExpression<'a>>>,
        pub init__type: Expression,
        pub init_: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for MemberAssignmentArgs<'a> {
        #[inline]
        fn default() -> Self {
            MemberAssignmentArgs {
                loc: None,
                member: None,
                init__type: Expression::NONE,
                init_: None,
            }
        }
    }
    pub struct MemberAssignmentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MemberAssignmentBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    MemberAssignment::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_member(&mut self, member: flatbuffers::WIPOffset<MemberExpression<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<MemberExpression>>(
                    MemberAssignment::VT_MEMBER,
                    member,
                );
        }
        #[inline]
        pub fn add_init__type(&mut self, init__type: Expression) {
            self.fbb_.push_slot::<Expression>(
                MemberAssignment::VT_INIT__TYPE,
                init__type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_init_(&mut self, init_: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MemberAssignment::VT_INIT_, init_);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MemberAssignmentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MemberAssignmentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MemberAssignment<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum WrappedExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct WrappedExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for WrappedExpression<'a> {
        type Inner = WrappedExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> WrappedExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            WrappedExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args WrappedExpressionArgs,
        ) -> flatbuffers::WIPOffset<WrappedExpression<'bldr>> {
            let mut builder = WrappedExpressionBuilder::new(_fbb);
            if let Some(x) = args.expression {
                builder.add_expression(x);
            }
            builder.add_expression_type(args.expression_type);
            builder.finish()
        }

        pub const VT_EXPRESSION_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_EXPRESSION: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn expression_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    WrappedExpression::VT_EXPRESSION_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn expression(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    WrappedExpression::VT_EXPRESSION,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.expression_type() == Expression::StringExpression {
                self.expression()
                    .map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.expression_type() == Expression::ArrayExpression {
                self.expression()
                    .map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.expression_type() == Expression::FunctionExpression {
                self.expression()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.expression_type() == Expression::BinaryExpression {
                self.expression()
                    .map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.expression_type() == Expression::CallExpression {
                self.expression()
                    .map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.expression_type() == Expression::ConditionalExpression {
                self.expression()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.expression_type() == Expression::IdentifierExpression {
                self.expression()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.expression_type() == Expression::LogicalExpression {
                self.expression()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.expression_type() == Expression::MemberExpression {
                self.expression()
                    .map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.expression_type() == Expression::IndexExpression {
                self.expression()
                    .map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.expression_type() == Expression::ObjectExpression {
                self.expression()
                    .map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.expression_type() == Expression::UnaryExpression {
                self.expression()
                    .map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.expression_type() == Expression::BooleanLiteral {
                self.expression()
                    .map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.expression_type() == Expression::DateTimeLiteral {
                self.expression()
                    .map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.expression_type() == Expression::DurationLiteral {
                self.expression()
                    .map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.expression_type() == Expression::FloatLiteral {
                self.expression().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.expression_type() == Expression::IntegerLiteral {
                self.expression()
                    .map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.expression_type() == Expression::StringLiteral {
                self.expression().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.expression_type() == Expression::RegexpLiteral {
                self.expression().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.expression_type() == Expression::UnsignedIntegerLiteral {
                self.expression()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct WrappedExpressionArgs {
        pub expression_type: Expression,
        pub expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for WrappedExpressionArgs {
        #[inline]
        fn default() -> Self {
            WrappedExpressionArgs {
                expression_type: Expression::NONE,
                expression: None,
            }
        }
    }
    pub struct WrappedExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> WrappedExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_expression_type(&mut self, expression_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                WrappedExpression::VT_EXPRESSION_TYPE,
                expression_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_expression(
            &mut self,
            expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                WrappedExpression::VT_EXPRESSION,
                expression,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> WrappedExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            WrappedExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<WrappedExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum StringExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct StringExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StringExpression<'a> {
        type Inner = StringExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> StringExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StringExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StringExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<StringExpression<'bldr>> {
            let mut builder = StringExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.parts {
                builder.add_parts(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_PARTS: flatbuffers::VOffsetT = 6;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_TYP: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    StringExpression::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn parts(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringExpressionPart<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<StringExpressionPart<'a>>>,
            >>(StringExpression::VT_PARTS, None)
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(StringExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    StringExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct StringExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub parts: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringExpressionPart<'a>>>,
            >,
        >,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for StringExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            StringExpressionArgs {
                loc: None,
                parts: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct StringExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StringExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    StringExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_parts(
            &mut self,
            parts: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<StringExpressionPart<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(StringExpression::VT_PARTS, parts);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                StringExpression::VT_TYP_TYPE,
                typ_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(StringExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> StringExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StringExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StringExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum StringExpressionPartOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct StringExpressionPart<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StringExpressionPart<'a> {
        type Inner = StringExpressionPart<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> StringExpressionPart<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StringExpressionPart { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StringExpressionPartArgs<'args>,
        ) -> flatbuffers::WIPOffset<StringExpressionPart<'bldr>> {
            let mut builder = StringExpressionPartBuilder::new(_fbb);
            if let Some(x) = args.interpolated_expression {
                builder.add_interpolated_expression(x);
            }
            if let Some(x) = args.text_value {
                builder.add_text_value(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_interpolated_expression_type(args.interpolated_expression_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_TEXT_VALUE: flatbuffers::VOffsetT = 6;
        pub const VT_INTERPOLATED_EXPRESSION_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_INTERPOLATED_EXPRESSION: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    StringExpressionPart::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn text_value(&self) -> Option<&'a str> {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                StringExpressionPart::VT_TEXT_VALUE,
                None,
            )
        }
        #[inline]
        pub fn interpolated_expression_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    StringExpressionPart::VT_INTERPOLATED_EXPRESSION_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn interpolated_expression(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    StringExpressionPart::VT_INTERPOLATED_EXPRESSION,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.interpolated_expression_type() == Expression::StringExpression {
                self.interpolated_expression()
                    .map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.interpolated_expression_type() == Expression::ArrayExpression {
                self.interpolated_expression()
                    .map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_function_expression(
            &self,
        ) -> Option<FunctionExpression<'a>> {
            if self.interpolated_expression_type() == Expression::FunctionExpression {
                self.interpolated_expression()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.interpolated_expression_type() == Expression::BinaryExpression {
                self.interpolated_expression()
                    .map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.interpolated_expression_type() == Expression::CallExpression {
                self.interpolated_expression()
                    .map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_conditional_expression(
            &self,
        ) -> Option<ConditionalExpression<'a>> {
            if self.interpolated_expression_type() == Expression::ConditionalExpression {
                self.interpolated_expression()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_identifier_expression(
            &self,
        ) -> Option<IdentifierExpression<'a>> {
            if self.interpolated_expression_type() == Expression::IdentifierExpression {
                self.interpolated_expression()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_logical_expression(
            &self,
        ) -> Option<LogicalExpression<'a>> {
            if self.interpolated_expression_type() == Expression::LogicalExpression {
                self.interpolated_expression()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.interpolated_expression_type() == Expression::MemberExpression {
                self.interpolated_expression()
                    .map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.interpolated_expression_type() == Expression::IndexExpression {
                self.interpolated_expression()
                    .map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.interpolated_expression_type() == Expression::ObjectExpression {
                self.interpolated_expression()
                    .map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.interpolated_expression_type() == Expression::UnaryExpression {
                self.interpolated_expression()
                    .map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::BooleanLiteral {
                self.interpolated_expression()
                    .map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::DateTimeLiteral {
                self.interpolated_expression()
                    .map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::DurationLiteral {
                self.interpolated_expression()
                    .map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::FloatLiteral {
                self.interpolated_expression()
                    .map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::IntegerLiteral {
                self.interpolated_expression()
                    .map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::StringLiteral {
                self.interpolated_expression()
                    .map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::RegexpLiteral {
                self.interpolated_expression()
                    .map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_unsigned_integer_literal(
            &self,
        ) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::UnsignedIntegerLiteral {
                self.interpolated_expression()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct StringExpressionPartArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub text_value: Option<flatbuffers::WIPOffset<&'a str>>,
        pub interpolated_expression_type: Expression,
        pub interpolated_expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for StringExpressionPartArgs<'a> {
        #[inline]
        fn default() -> Self {
            StringExpressionPartArgs {
                loc: None,
                text_value: None,
                interpolated_expression_type: Expression::NONE,
                interpolated_expression: None,
            }
        }
    }
    pub struct StringExpressionPartBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StringExpressionPartBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    StringExpressionPart::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_text_value(&mut self, text_value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                StringExpressionPart::VT_TEXT_VALUE,
                text_value,
            );
        }
        #[inline]
        pub fn add_interpolated_expression_type(
            &mut self,
            interpolated_expression_type: Expression,
        ) {
            self.fbb_.push_slot::<Expression>(
                StringExpressionPart::VT_INTERPOLATED_EXPRESSION_TYPE,
                interpolated_expression_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_interpolated_expression(
            &mut self,
            interpolated_expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                StringExpressionPart::VT_INTERPOLATED_EXPRESSION,
                interpolated_expression,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> StringExpressionPartBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StringExpressionPartBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StringExpressionPart<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ArrayExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct ArrayExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ArrayExpression<'a> {
        type Inner = ArrayExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> ArrayExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ArrayExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ArrayExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<ArrayExpression<'bldr>> {
            let mut builder = ArrayExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.elements {
                builder.add_elements(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ELEMENTS: flatbuffers::VOffsetT = 6;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_TYP: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    ArrayExpression::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn elements(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedExpression<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<WrappedExpression<'a>>>,
            >>(ArrayExpression::VT_ELEMENTS, None)
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(ArrayExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ArrayExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct ArrayExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub elements: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedExpression<'a>>>,
            >,
        >,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ArrayExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            ArrayExpressionArgs {
                loc: None,
                elements: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct ArrayExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ArrayExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    ArrayExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_elements(
            &mut self,
            elements: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<WrappedExpression<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ArrayExpression::VT_ELEMENTS,
                elements,
            );
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(ArrayExpression::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ArrayExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ArrayExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ArrayExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FunctionExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct FunctionExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FunctionExpression<'a> {
        type Inner = FunctionExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> FunctionExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FunctionExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FunctionExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<FunctionExpression<'bldr>> {
            let mut builder = FunctionExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.params {
                builder.add_params(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_PARAMS: flatbuffers::VOffsetT = 6;
        pub const VT_BODY: flatbuffers::VOffsetT = 8;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_TYP: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    FunctionExpression::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn params(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctionParameter<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<FunctionParameter<'a>>>,
            >>(FunctionExpression::VT_PARAMS, None)
        }
        #[inline]
        pub fn body(&self) -> Option<Block<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Block<'a>>>(FunctionExpression::VT_BODY, None)
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(FunctionExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    FunctionExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct FunctionExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub params: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctionParameter<'a>>>,
            >,
        >,
        pub body: Option<flatbuffers::WIPOffset<Block<'a>>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for FunctionExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            FunctionExpressionArgs {
                loc: None,
                params: None,
                body: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct FunctionExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FunctionExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    FunctionExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_params(
            &mut self,
            params: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<FunctionParameter<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                FunctionExpression::VT_PARAMS,
                params,
            );
        }
        #[inline]
        pub fn add_body(&mut self, body: flatbuffers::WIPOffset<Block<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Block>>(
                FunctionExpression::VT_BODY,
                body,
            );
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                FunctionExpression::VT_TYP_TYPE,
                typ_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FunctionExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FunctionExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FunctionExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FunctionParameterOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct FunctionParameter<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FunctionParameter<'a> {
        type Inner = FunctionParameter<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> FunctionParameter<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FunctionParameter { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FunctionParameterArgs<'args>,
        ) -> flatbuffers::WIPOffset<FunctionParameter<'bldr>> {
            let mut builder = FunctionParameterBuilder::new(_fbb);
            if let Some(x) = args.default {
                builder.add_default(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_default_type(args.default_type);
            builder.add_is_pipe(args.is_pipe);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_IS_PIPE: flatbuffers::VOffsetT = 6;
        pub const VT_KEY: flatbuffers::VOffsetT = 8;
        pub const VT_DEFAULT_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_DEFAULT: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    FunctionParameter::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn is_pipe(&self) -> bool {
            self._tab
                .get::<bool>(FunctionParameter::VT_IS_PIPE, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn key(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(
                    FunctionParameter::VT_KEY,
                    None,
                )
        }
        #[inline]
        pub fn default_type(&self) -> Expression {
            self._tab
                .get::<Expression>(FunctionParameter::VT_DEFAULT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn default(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    FunctionParameter::VT_DEFAULT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.default_type() == Expression::StringExpression {
                self.default().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.default_type() == Expression::ArrayExpression {
                self.default().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.default_type() == Expression::FunctionExpression {
                self.default()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.default_type() == Expression::BinaryExpression {
                self.default().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.default_type() == Expression::CallExpression {
                self.default().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.default_type() == Expression::ConditionalExpression {
                self.default()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.default_type() == Expression::IdentifierExpression {
                self.default()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.default_type() == Expression::LogicalExpression {
                self.default()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.default_type() == Expression::MemberExpression {
                self.default().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.default_type() == Expression::IndexExpression {
                self.default().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.default_type() == Expression::ObjectExpression {
                self.default().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.default_type() == Expression::UnaryExpression {
                self.default().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.default_type() == Expression::BooleanLiteral {
                self.default().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.default_type() == Expression::DateTimeLiteral {
                self.default().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.default_type() == Expression::DurationLiteral {
                self.default().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.default_type() == Expression::FloatLiteral {
                self.default().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.default_type() == Expression::IntegerLiteral {
                self.default().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.default_type() == Expression::StringLiteral {
                self.default().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.default_type() == Expression::RegexpLiteral {
                self.default().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn default_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.default_type() == Expression::UnsignedIntegerLiteral {
                self.default()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct FunctionParameterArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub is_pipe: bool,
        pub key: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub default_type: Expression,
        pub default: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for FunctionParameterArgs<'a> {
        #[inline]
        fn default() -> Self {
            FunctionParameterArgs {
                loc: None,
                is_pipe: false,
                key: None,
                default_type: Expression::NONE,
                default: None,
            }
        }
    }
    pub struct FunctionParameterBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FunctionParameterBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    FunctionParameter::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_is_pipe(&mut self, is_pipe: bool) {
            self.fbb_
                .push_slot::<bool>(FunctionParameter::VT_IS_PIPE, is_pipe, false);
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    FunctionParameter::VT_KEY,
                    key,
                );
        }
        #[inline]
        pub fn add_default_type(&mut self, default_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                FunctionParameter::VT_DEFAULT_TYPE,
                default_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_default(
            &mut self,
            default: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                FunctionParameter::VT_DEFAULT,
                default,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FunctionParameterBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FunctionParameterBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FunctionParameter<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum BlockOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Block<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Block<'a> {
        type Inner = Block<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Block<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Block { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BlockArgs<'args>,
        ) -> flatbuffers::WIPOffset<Block<'bldr>> {
            let mut builder = BlockBuilder::new(_fbb);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_BODY: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(Block::VT_LOC, None)
        }
        #[inline]
        pub fn body(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>,
            >>(Block::VT_BODY, None)
        }
    }

    pub struct BlockArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub body: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>,
            >,
        >,
    }
    impl<'a> Default for BlockArgs<'a> {
        #[inline]
        fn default() -> Self {
            BlockArgs {
                loc: None,
                body: None,
            }
        }
    }
    pub struct BlockBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BlockBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(Block::VT_LOC, loc);
        }
        #[inline]
        pub fn add_body(
            &mut self,
            body: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<WrappedStatement<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_BODY, body);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BlockBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Block<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum BinaryExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct BinaryExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BinaryExpression<'a> {
        type Inner = BinaryExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> BinaryExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BinaryExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BinaryExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<BinaryExpression<'bldr>> {
            let mut builder = BinaryExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.right {
                builder.add_right(x);
            }
            if let Some(x) = args.left {
                builder.add_left(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.add_right_type(args.right_type);
            builder.add_left_type(args.left_type);
            builder.add_operator(args.operator);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_OPERATOR: flatbuffers::VOffsetT = 6;
        pub const VT_LEFT_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_LEFT: flatbuffers::VOffsetT = 10;
        pub const VT_RIGHT_TYPE: flatbuffers::VOffsetT = 12;
        pub const VT_RIGHT: flatbuffers::VOffsetT = 14;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 16;
        pub const VT_TYP: flatbuffers::VOffsetT = 18;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    BinaryExpression::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn operator(&self) -> Operator {
            self._tab
                .get::<Operator>(
                    BinaryExpression::VT_OPERATOR,
                    Some(Operator::MultiplicationOperator),
                )
                .unwrap()
        }
        #[inline]
        pub fn left_type(&self) -> Expression {
            self._tab
                .get::<Expression>(BinaryExpression::VT_LEFT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn left(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    BinaryExpression::VT_LEFT,
                    None,
                )
        }
        #[inline]
        pub fn right_type(&self) -> Expression {
            self._tab
                .get::<Expression>(BinaryExpression::VT_RIGHT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn right(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    BinaryExpression::VT_RIGHT,
                    None,
                )
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(BinaryExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    BinaryExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.left_type() == Expression::StringExpression {
                self.left().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.left_type() == Expression::ArrayExpression {
                self.left().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.left_type() == Expression::FunctionExpression {
                self.left().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.left_type() == Expression::BinaryExpression {
                self.left().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.left_type() == Expression::CallExpression {
                self.left().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.left_type() == Expression::ConditionalExpression {
                self.left()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.left_type() == Expression::IdentifierExpression {
                self.left()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.left_type() == Expression::LogicalExpression {
                self.left().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.left_type() == Expression::MemberExpression {
                self.left().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.left_type() == Expression::IndexExpression {
                self.left().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.left_type() == Expression::ObjectExpression {
                self.left().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.left_type() == Expression::UnaryExpression {
                self.left().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.left_type() == Expression::BooleanLiteral {
                self.left().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.left_type() == Expression::DateTimeLiteral {
                self.left().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.left_type() == Expression::DurationLiteral {
                self.left().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.left_type() == Expression::FloatLiteral {
                self.left().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.left_type() == Expression::IntegerLiteral {
                self.left().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.left_type() == Expression::StringLiteral {
                self.left().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.left_type() == Expression::RegexpLiteral {
                self.left().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.left_type() == Expression::UnsignedIntegerLiteral {
                self.left()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.right_type() == Expression::StringExpression {
                self.right().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.right_type() == Expression::ArrayExpression {
                self.right().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.right_type() == Expression::FunctionExpression {
                self.right().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.right_type() == Expression::BinaryExpression {
                self.right().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.right_type() == Expression::CallExpression {
                self.right().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.right_type() == Expression::ConditionalExpression {
                self.right()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.right_type() == Expression::IdentifierExpression {
                self.right()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.right_type() == Expression::LogicalExpression {
                self.right().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.right_type() == Expression::MemberExpression {
                self.right().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.right_type() == Expression::IndexExpression {
                self.right().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.right_type() == Expression::ObjectExpression {
                self.right().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.right_type() == Expression::UnaryExpression {
                self.right().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.right_type() == Expression::BooleanLiteral {
                self.right().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.right_type() == Expression::DateTimeLiteral {
                self.right().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.right_type() == Expression::DurationLiteral {
                self.right().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.right_type() == Expression::FloatLiteral {
                self.right().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.right_type() == Expression::IntegerLiteral {
                self.right().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.right_type() == Expression::StringLiteral {
                self.right().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.right_type() == Expression::RegexpLiteral {
                self.right().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.right_type() == Expression::UnsignedIntegerLiteral {
                self.right()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct BinaryExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub operator: Operator,
        pub left_type: Expression,
        pub left: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub right_type: Expression,
        pub right: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for BinaryExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            BinaryExpressionArgs {
                loc: None,
                operator: Operator::MultiplicationOperator,
                left_type: Expression::NONE,
                left: None,
                right_type: Expression::NONE,
                right: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct BinaryExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BinaryExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    BinaryExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_operator(&mut self, operator: Operator) {
            self.fbb_.push_slot::<Operator>(
                BinaryExpression::VT_OPERATOR,
                operator,
                Operator::MultiplicationOperator,
            );
        }
        #[inline]
        pub fn add_left_type(&mut self, left_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                BinaryExpression::VT_LEFT_TYPE,
                left_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_left(&mut self, left: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryExpression::VT_LEFT, left);
        }
        #[inline]
        pub fn add_right_type(&mut self, right_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                BinaryExpression::VT_RIGHT_TYPE,
                right_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_right(&mut self, right: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryExpression::VT_RIGHT, right);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                BinaryExpression::VT_TYP_TYPE,
                typ_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BinaryExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BinaryExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BinaryExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum CallExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct CallExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CallExpression<'a> {
        type Inner = CallExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> CallExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CallExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CallExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<CallExpression<'bldr>> {
            let mut builder = CallExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.pipe {
                builder.add_pipe(x);
            }
            if let Some(x) = args.arguments {
                builder.add_arguments(x);
            }
            if let Some(x) = args.callee {
                builder.add_callee(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.add_pipe_type(args.pipe_type);
            builder.add_callee_type(args.callee_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_CALLEE_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_CALLEE: flatbuffers::VOffsetT = 8;
        pub const VT_ARGUMENTS: flatbuffers::VOffsetT = 10;
        pub const VT_PIPE_TYPE: flatbuffers::VOffsetT = 12;
        pub const VT_PIPE: flatbuffers::VOffsetT = 14;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 16;
        pub const VT_TYP: flatbuffers::VOffsetT = 18;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    CallExpression::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn callee_type(&self) -> Expression {
            self._tab
                .get::<Expression>(CallExpression::VT_CALLEE_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn callee(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    CallExpression::VT_CALLEE,
                    None,
                )
        }
        #[inline]
        pub fn arguments(&self) -> Option<ObjectExpression<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<ObjectExpression<'a>>>(
                    CallExpression::VT_ARGUMENTS,
                    None,
                )
        }
        #[inline]
        pub fn pipe_type(&self) -> Expression {
            self._tab
                .get::<Expression>(CallExpression::VT_PIPE_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn pipe(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    CallExpression::VT_PIPE,
                    None,
                )
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(CallExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    CallExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.callee_type() == Expression::StringExpression {
                self.callee().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.callee_type() == Expression::ArrayExpression {
                self.callee().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.callee_type() == Expression::FunctionExpression {
                self.callee()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.callee_type() == Expression::BinaryExpression {
                self.callee().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.callee_type() == Expression::CallExpression {
                self.callee().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.callee_type() == Expression::ConditionalExpression {
                self.callee()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.callee_type() == Expression::IdentifierExpression {
                self.callee()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.callee_type() == Expression::LogicalExpression {
                self.callee().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.callee_type() == Expression::MemberExpression {
                self.callee().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.callee_type() == Expression::IndexExpression {
                self.callee().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.callee_type() == Expression::ObjectExpression {
                self.callee().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.callee_type() == Expression::UnaryExpression {
                self.callee().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.callee_type() == Expression::BooleanLiteral {
                self.callee().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.callee_type() == Expression::DateTimeLiteral {
                self.callee().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.callee_type() == Expression::DurationLiteral {
                self.callee().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.callee_type() == Expression::FloatLiteral {
                self.callee().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.callee_type() == Expression::IntegerLiteral {
                self.callee().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.callee_type() == Expression::StringLiteral {
                self.callee().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.callee_type() == Expression::RegexpLiteral {
                self.callee().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.callee_type() == Expression::UnsignedIntegerLiteral {
                self.callee()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.pipe_type() == Expression::StringExpression {
                self.pipe().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.pipe_type() == Expression::ArrayExpression {
                self.pipe().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.pipe_type() == Expression::FunctionExpression {
                self.pipe().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.pipe_type() == Expression::BinaryExpression {
                self.pipe().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.pipe_type() == Expression::CallExpression {
                self.pipe().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.pipe_type() == Expression::ConditionalExpression {
                self.pipe()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.pipe_type() == Expression::IdentifierExpression {
                self.pipe()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.pipe_type() == Expression::LogicalExpression {
                self.pipe().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.pipe_type() == Expression::MemberExpression {
                self.pipe().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.pipe_type() == Expression::IndexExpression {
                self.pipe().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.pipe_type() == Expression::ObjectExpression {
                self.pipe().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.pipe_type() == Expression::UnaryExpression {
                self.pipe().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.pipe_type() == Expression::BooleanLiteral {
                self.pipe().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.pipe_type() == Expression::DateTimeLiteral {
                self.pipe().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.pipe_type() == Expression::DurationLiteral {
                self.pipe().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.pipe_type() == Expression::FloatLiteral {
                self.pipe().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.pipe_type() == Expression::IntegerLiteral {
                self.pipe().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.pipe_type() == Expression::StringLiteral {
                self.pipe().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.pipe_type() == Expression::RegexpLiteral {
                self.pipe().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn pipe_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.pipe_type() == Expression::UnsignedIntegerLiteral {
                self.pipe()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct CallExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub callee_type: Expression,
        pub callee: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub arguments: Option<flatbuffers::WIPOffset<ObjectExpression<'a>>>,
        pub pipe_type: Expression,
        pub pipe: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for CallExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            CallExpressionArgs {
                loc: None,
                callee_type: Expression::NONE,
                callee: None,
                arguments: None,
                pipe_type: Expression::NONE,
                pipe: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct CallExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CallExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    CallExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_callee_type(&mut self, callee_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                CallExpression::VT_CALLEE_TYPE,
                callee_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_callee(&mut self, callee: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CallExpression::VT_CALLEE, callee);
        }
        #[inline]
        pub fn add_arguments(&mut self, arguments: flatbuffers::WIPOffset<ObjectExpression<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<ObjectExpression>>(
                    CallExpression::VT_ARGUMENTS,
                    arguments,
                );
        }
        #[inline]
        pub fn add_pipe_type(&mut self, pipe_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                CallExpression::VT_PIPE_TYPE,
                pipe_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_pipe(&mut self, pipe: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CallExpression::VT_PIPE, pipe);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(CallExpression::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CallExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CallExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CallExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CallExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ConditionalExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct ConditionalExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ConditionalExpression<'a> {
        type Inner = ConditionalExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> ConditionalExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ConditionalExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ConditionalExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<ConditionalExpression<'bldr>> {
            let mut builder = ConditionalExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.consequent {
                builder.add_consequent(x);
            }
            if let Some(x) = args.alternate {
                builder.add_alternate(x);
            }
            if let Some(x) = args.test {
                builder.add_test(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.add_consequent_type(args.consequent_type);
            builder.add_alternate_type(args.alternate_type);
            builder.add_test_type(args.test_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_TEST_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_TEST: flatbuffers::VOffsetT = 8;
        pub const VT_ALTERNATE_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_ALTERNATE: flatbuffers::VOffsetT = 12;
        pub const VT_CONSEQUENT_TYPE: flatbuffers::VOffsetT = 14;
        pub const VT_CONSEQUENT: flatbuffers::VOffsetT = 16;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 18;
        pub const VT_TYP: flatbuffers::VOffsetT = 20;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    ConditionalExpression::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn test_type(&self) -> Expression {
            self._tab
                .get::<Expression>(ConditionalExpression::VT_TEST_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn test(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConditionalExpression::VT_TEST,
                    None,
                )
        }
        #[inline]
        pub fn alternate_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    ConditionalExpression::VT_ALTERNATE_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn alternate(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConditionalExpression::VT_ALTERNATE,
                    None,
                )
        }
        #[inline]
        pub fn consequent_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    ConditionalExpression::VT_CONSEQUENT_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn consequent(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConditionalExpression::VT_CONSEQUENT,
                    None,
                )
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(ConditionalExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConditionalExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.test_type() == Expression::StringExpression {
                self.test().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.test_type() == Expression::ArrayExpression {
                self.test().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.test_type() == Expression::FunctionExpression {
                self.test().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.test_type() == Expression::BinaryExpression {
                self.test().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.test_type() == Expression::CallExpression {
                self.test().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.test_type() == Expression::ConditionalExpression {
                self.test()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.test_type() == Expression::IdentifierExpression {
                self.test()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.test_type() == Expression::LogicalExpression {
                self.test().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.test_type() == Expression::MemberExpression {
                self.test().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.test_type() == Expression::IndexExpression {
                self.test().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.test_type() == Expression::ObjectExpression {
                self.test().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.test_type() == Expression::UnaryExpression {
                self.test().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.test_type() == Expression::BooleanLiteral {
                self.test().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.test_type() == Expression::DateTimeLiteral {
                self.test().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.test_type() == Expression::DurationLiteral {
                self.test().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.test_type() == Expression::FloatLiteral {
                self.test().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.test_type() == Expression::IntegerLiteral {
                self.test().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.test_type() == Expression::StringLiteral {
                self.test().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.test_type() == Expression::RegexpLiteral {
                self.test().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.test_type() == Expression::UnsignedIntegerLiteral {
                self.test()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.alternate_type() == Expression::StringExpression {
                self.alternate()
                    .map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.alternate_type() == Expression::ArrayExpression {
                self.alternate()
                    .map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.alternate_type() == Expression::FunctionExpression {
                self.alternate()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.alternate_type() == Expression::BinaryExpression {
                self.alternate()
                    .map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.alternate_type() == Expression::CallExpression {
                self.alternate().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.alternate_type() == Expression::ConditionalExpression {
                self.alternate()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.alternate_type() == Expression::IdentifierExpression {
                self.alternate()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.alternate_type() == Expression::LogicalExpression {
                self.alternate()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.alternate_type() == Expression::MemberExpression {
                self.alternate()
                    .map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.alternate_type() == Expression::IndexExpression {
                self.alternate()
                    .map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.alternate_type() == Expression::ObjectExpression {
                self.alternate()
                    .map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.alternate_type() == Expression::UnaryExpression {
                self.alternate()
                    .map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.alternate_type() == Expression::BooleanLiteral {
                self.alternate().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.alternate_type() == Expression::DateTimeLiteral {
                self.alternate()
                    .map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.alternate_type() == Expression::DurationLiteral {
                self.alternate()
                    .map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.alternate_type() == Expression::FloatLiteral {
                self.alternate().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.alternate_type() == Expression::IntegerLiteral {
                self.alternate().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.alternate_type() == Expression::StringLiteral {
                self.alternate().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.alternate_type() == Expression::RegexpLiteral {
                self.alternate().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.alternate_type() == Expression::UnsignedIntegerLiteral {
                self.alternate()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.consequent_type() == Expression::StringExpression {
                self.consequent()
                    .map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.consequent_type() == Expression::ArrayExpression {
                self.consequent()
                    .map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.consequent_type() == Expression::FunctionExpression {
                self.consequent()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.consequent_type() == Expression::BinaryExpression {
                self.consequent()
                    .map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.consequent_type() == Expression::CallExpression {
                self.consequent()
                    .map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.consequent_type() == Expression::ConditionalExpression {
                self.consequent()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.consequent_type() == Expression::IdentifierExpression {
                self.consequent()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.consequent_type() == Expression::LogicalExpression {
                self.consequent()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.consequent_type() == Expression::MemberExpression {
                self.consequent()
                    .map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.consequent_type() == Expression::IndexExpression {
                self.consequent()
                    .map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.consequent_type() == Expression::ObjectExpression {
                self.consequent()
                    .map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.consequent_type() == Expression::UnaryExpression {
                self.consequent()
                    .map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.consequent_type() == Expression::BooleanLiteral {
                self.consequent()
                    .map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.consequent_type() == Expression::DateTimeLiteral {
                self.consequent()
                    .map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.consequent_type() == Expression::DurationLiteral {
                self.consequent()
                    .map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.consequent_type() == Expression::FloatLiteral {
                self.consequent().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.consequent_type() == Expression::IntegerLiteral {
                self.consequent()
                    .map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.consequent_type() == Expression::StringLiteral {
                self.consequent().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.consequent_type() == Expression::RegexpLiteral {
                self.consequent().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.consequent_type() == Expression::UnsignedIntegerLiteral {
                self.consequent()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct ConditionalExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub test_type: Expression,
        pub test: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub alternate_type: Expression,
        pub alternate: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub consequent_type: Expression,
        pub consequent: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ConditionalExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            ConditionalExpressionArgs {
                loc: None,
                test_type: Expression::NONE,
                test: None,
                alternate_type: Expression::NONE,
                alternate: None,
                consequent_type: Expression::NONE,
                consequent: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct ConditionalExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ConditionalExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    ConditionalExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_test_type(&mut self, test_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ConditionalExpression::VT_TEST_TYPE,
                test_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_test(&mut self, test: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ConditionalExpression::VT_TEST,
                test,
            );
        }
        #[inline]
        pub fn add_alternate_type(&mut self, alternate_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ConditionalExpression::VT_ALTERNATE_TYPE,
                alternate_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_alternate(
            &mut self,
            alternate: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ConditionalExpression::VT_ALTERNATE,
                alternate,
            );
        }
        #[inline]
        pub fn add_consequent_type(&mut self, consequent_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ConditionalExpression::VT_CONSEQUENT_TYPE,
                consequent_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_consequent(
            &mut self,
            consequent: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ConditionalExpression::VT_CONSEQUENT,
                consequent,
            );
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                ConditionalExpression::VT_TYP_TYPE,
                typ_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ConditionalExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ConditionalExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ConditionalExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ConditionalExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum LogicalExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct LogicalExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LogicalExpression<'a> {
        type Inner = LogicalExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> LogicalExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LogicalExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LogicalExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<LogicalExpression<'bldr>> {
            let mut builder = LogicalExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.right {
                builder.add_right(x);
            }
            if let Some(x) = args.left {
                builder.add_left(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.add_right_type(args.right_type);
            builder.add_left_type(args.left_type);
            builder.add_operator(args.operator);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_OPERATOR: flatbuffers::VOffsetT = 6;
        pub const VT_LEFT_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_LEFT: flatbuffers::VOffsetT = 10;
        pub const VT_RIGHT_TYPE: flatbuffers::VOffsetT = 12;
        pub const VT_RIGHT: flatbuffers::VOffsetT = 14;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 16;
        pub const VT_TYP: flatbuffers::VOffsetT = 18;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    LogicalExpression::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn operator(&self) -> LogicalOperator {
            self._tab
                .get::<LogicalOperator>(
                    LogicalExpression::VT_OPERATOR,
                    Some(LogicalOperator::AndOperator),
                )
                .unwrap()
        }
        #[inline]
        pub fn left_type(&self) -> Expression {
            self._tab
                .get::<Expression>(LogicalExpression::VT_LEFT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn left(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    LogicalExpression::VT_LEFT,
                    None,
                )
        }
        #[inline]
        pub fn right_type(&self) -> Expression {
            self._tab
                .get::<Expression>(LogicalExpression::VT_RIGHT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn right(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    LogicalExpression::VT_RIGHT,
                    None,
                )
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(LogicalExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    LogicalExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.left_type() == Expression::StringExpression {
                self.left().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.left_type() == Expression::ArrayExpression {
                self.left().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.left_type() == Expression::FunctionExpression {
                self.left().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.left_type() == Expression::BinaryExpression {
                self.left().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.left_type() == Expression::CallExpression {
                self.left().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.left_type() == Expression::ConditionalExpression {
                self.left()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.left_type() == Expression::IdentifierExpression {
                self.left()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.left_type() == Expression::LogicalExpression {
                self.left().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.left_type() == Expression::MemberExpression {
                self.left().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.left_type() == Expression::IndexExpression {
                self.left().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.left_type() == Expression::ObjectExpression {
                self.left().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.left_type() == Expression::UnaryExpression {
                self.left().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.left_type() == Expression::BooleanLiteral {
                self.left().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.left_type() == Expression::DateTimeLiteral {
                self.left().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.left_type() == Expression::DurationLiteral {
                self.left().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.left_type() == Expression::FloatLiteral {
                self.left().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.left_type() == Expression::IntegerLiteral {
                self.left().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.left_type() == Expression::StringLiteral {
                self.left().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.left_type() == Expression::RegexpLiteral {
                self.left().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.left_type() == Expression::UnsignedIntegerLiteral {
                self.left()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.right_type() == Expression::StringExpression {
                self.right().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.right_type() == Expression::ArrayExpression {
                self.right().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.right_type() == Expression::FunctionExpression {
                self.right().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.right_type() == Expression::BinaryExpression {
                self.right().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.right_type() == Expression::CallExpression {
                self.right().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.right_type() == Expression::ConditionalExpression {
                self.right()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.right_type() == Expression::IdentifierExpression {
                self.right()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.right_type() == Expression::LogicalExpression {
                self.right().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.right_type() == Expression::MemberExpression {
                self.right().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.right_type() == Expression::IndexExpression {
                self.right().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.right_type() == Expression::ObjectExpression {
                self.right().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.right_type() == Expression::UnaryExpression {
                self.right().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.right_type() == Expression::BooleanLiteral {
                self.right().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.right_type() == Expression::DateTimeLiteral {
                self.right().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.right_type() == Expression::DurationLiteral {
                self.right().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.right_type() == Expression::FloatLiteral {
                self.right().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.right_type() == Expression::IntegerLiteral {
                self.right().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.right_type() == Expression::StringLiteral {
                self.right().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.right_type() == Expression::RegexpLiteral {
                self.right().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.right_type() == Expression::UnsignedIntegerLiteral {
                self.right()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct LogicalExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub operator: LogicalOperator,
        pub left_type: Expression,
        pub left: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub right_type: Expression,
        pub right: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for LogicalExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            LogicalExpressionArgs {
                loc: None,
                operator: LogicalOperator::AndOperator,
                left_type: Expression::NONE,
                left: None,
                right_type: Expression::NONE,
                right: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct LogicalExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LogicalExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    LogicalExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_operator(&mut self, operator: LogicalOperator) {
            self.fbb_.push_slot::<LogicalOperator>(
                LogicalExpression::VT_OPERATOR,
                operator,
                LogicalOperator::AndOperator,
            );
        }
        #[inline]
        pub fn add_left_type(&mut self, left_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                LogicalExpression::VT_LEFT_TYPE,
                left_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_left(&mut self, left: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(LogicalExpression::VT_LEFT, left);
        }
        #[inline]
        pub fn add_right_type(&mut self, right_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                LogicalExpression::VT_RIGHT_TYPE,
                right_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_right(&mut self, right: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(LogicalExpression::VT_RIGHT, right);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                LogicalExpression::VT_TYP_TYPE,
                typ_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(LogicalExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LogicalExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LogicalExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LogicalExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum MemberExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct MemberExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MemberExpression<'a> {
        type Inner = MemberExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> MemberExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MemberExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MemberExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<MemberExpression<'bldr>> {
            let mut builder = MemberExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.property {
                builder.add_property(x);
            }
            if let Some(x) = args.object {
                builder.add_object(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.add_object_type(args.object_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_OBJECT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_OBJECT: flatbuffers::VOffsetT = 8;
        pub const VT_PROPERTY: flatbuffers::VOffsetT = 10;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 12;
        pub const VT_TYP: flatbuffers::VOffsetT = 14;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    MemberExpression::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn object_type(&self) -> Expression {
            self._tab
                .get::<Expression>(MemberExpression::VT_OBJECT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn object(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    MemberExpression::VT_OBJECT,
                    None,
                )
        }
        #[inline]
        pub fn property(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(MemberExpression::VT_PROPERTY, None)
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(MemberExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    MemberExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.object_type() == Expression::StringExpression {
                self.object().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.object_type() == Expression::ArrayExpression {
                self.object().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.object_type() == Expression::FunctionExpression {
                self.object()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.object_type() == Expression::BinaryExpression {
                self.object().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.object_type() == Expression::CallExpression {
                self.object().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.object_type() == Expression::ConditionalExpression {
                self.object()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.object_type() == Expression::IdentifierExpression {
                self.object()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.object_type() == Expression::LogicalExpression {
                self.object().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.object_type() == Expression::MemberExpression {
                self.object().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.object_type() == Expression::IndexExpression {
                self.object().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.object_type() == Expression::ObjectExpression {
                self.object().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.object_type() == Expression::UnaryExpression {
                self.object().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.object_type() == Expression::BooleanLiteral {
                self.object().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.object_type() == Expression::DateTimeLiteral {
                self.object().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.object_type() == Expression::DurationLiteral {
                self.object().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.object_type() == Expression::FloatLiteral {
                self.object().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.object_type() == Expression::IntegerLiteral {
                self.object().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.object_type() == Expression::StringLiteral {
                self.object().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.object_type() == Expression::RegexpLiteral {
                self.object().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.object_type() == Expression::UnsignedIntegerLiteral {
                self.object()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct MemberExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub object_type: Expression,
        pub object: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub property: Option<flatbuffers::WIPOffset<&'a str>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for MemberExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            MemberExpressionArgs {
                loc: None,
                object_type: Expression::NONE,
                object: None,
                property: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct MemberExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MemberExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    MemberExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_object_type(&mut self, object_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                MemberExpression::VT_OBJECT_TYPE,
                object_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_object(&mut self, object: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MemberExpression::VT_OBJECT, object);
        }
        #[inline]
        pub fn add_property(&mut self, property: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MemberExpression::VT_PROPERTY,
                property,
            );
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                MemberExpression::VT_TYP_TYPE,
                typ_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MemberExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MemberExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MemberExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MemberExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum IndexExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct IndexExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for IndexExpression<'a> {
        type Inner = IndexExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> IndexExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            IndexExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IndexExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<IndexExpression<'bldr>> {
            let mut builder = IndexExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.index {
                builder.add_index(x);
            }
            if let Some(x) = args.array {
                builder.add_array(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.add_index_type(args.index_type);
            builder.add_array_type(args.array_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ARRAY_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ARRAY: flatbuffers::VOffsetT = 8;
        pub const VT_INDEX_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_INDEX: flatbuffers::VOffsetT = 12;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 14;
        pub const VT_TYP: flatbuffers::VOffsetT = 16;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    IndexExpression::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn array_type(&self) -> Expression {
            self._tab
                .get::<Expression>(IndexExpression::VT_ARRAY_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn array(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    IndexExpression::VT_ARRAY,
                    None,
                )
        }
        #[inline]
        pub fn index_type(&self) -> Expression {
            self._tab
                .get::<Expression>(IndexExpression::VT_INDEX_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn index(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    IndexExpression::VT_INDEX,
                    None,
                )
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(IndexExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    IndexExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.array_type() == Expression::StringExpression {
                self.array().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.array_type() == Expression::ArrayExpression {
                self.array().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.array_type() == Expression::FunctionExpression {
                self.array().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.array_type() == Expression::BinaryExpression {
                self.array().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.array_type() == Expression::CallExpression {
                self.array().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.array_type() == Expression::ConditionalExpression {
                self.array()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.array_type() == Expression::IdentifierExpression {
                self.array()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.array_type() == Expression::LogicalExpression {
                self.array().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.array_type() == Expression::MemberExpression {
                self.array().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.array_type() == Expression::IndexExpression {
                self.array().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.array_type() == Expression::ObjectExpression {
                self.array().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.array_type() == Expression::UnaryExpression {
                self.array().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.array_type() == Expression::BooleanLiteral {
                self.array().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.array_type() == Expression::DateTimeLiteral {
                self.array().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.array_type() == Expression::DurationLiteral {
                self.array().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.array_type() == Expression::FloatLiteral {
                self.array().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.array_type() == Expression::IntegerLiteral {
                self.array().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.array_type() == Expression::StringLiteral {
                self.array().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.array_type() == Expression::RegexpLiteral {
                self.array().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.array_type() == Expression::UnsignedIntegerLiteral {
                self.array()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.index_type() == Expression::StringExpression {
                self.index().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.index_type() == Expression::ArrayExpression {
                self.index().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.index_type() == Expression::FunctionExpression {
                self.index().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.index_type() == Expression::BinaryExpression {
                self.index().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.index_type() == Expression::CallExpression {
                self.index().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.index_type() == Expression::ConditionalExpression {
                self.index()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.index_type() == Expression::IdentifierExpression {
                self.index()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.index_type() == Expression::LogicalExpression {
                self.index().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.index_type() == Expression::MemberExpression {
                self.index().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.index_type() == Expression::IndexExpression {
                self.index().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.index_type() == Expression::ObjectExpression {
                self.index().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.index_type() == Expression::UnaryExpression {
                self.index().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.index_type() == Expression::BooleanLiteral {
                self.index().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.index_type() == Expression::DateTimeLiteral {
                self.index().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.index_type() == Expression::DurationLiteral {
                self.index().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.index_type() == Expression::FloatLiteral {
                self.index().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.index_type() == Expression::IntegerLiteral {
                self.index().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.index_type() == Expression::StringLiteral {
                self.index().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.index_type() == Expression::RegexpLiteral {
                self.index().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.index_type() == Expression::UnsignedIntegerLiteral {
                self.index()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct IndexExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub array_type: Expression,
        pub array: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub index_type: Expression,
        pub index: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for IndexExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            IndexExpressionArgs {
                loc: None,
                array_type: Expression::NONE,
                array: None,
                index_type: Expression::NONE,
                index: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct IndexExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IndexExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    IndexExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_array_type(&mut self, array_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                IndexExpression::VT_ARRAY_TYPE,
                array_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_array(&mut self, array: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IndexExpression::VT_ARRAY, array);
        }
        #[inline]
        pub fn add_index_type(&mut self, index_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                IndexExpression::VT_INDEX_TYPE,
                index_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_index(&mut self, index: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IndexExpression::VT_INDEX, index);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(IndexExpression::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IndexExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> IndexExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IndexExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<IndexExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ObjectExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct ObjectExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ObjectExpression<'a> {
        type Inner = ObjectExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> ObjectExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ObjectExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ObjectExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<ObjectExpression<'bldr>> {
            let mut builder = ObjectExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.properties {
                builder.add_properties(x);
            }
            if let Some(x) = args.with {
                builder.add_with(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_WITH: flatbuffers::VOffsetT = 6;
        pub const VT_PROPERTIES: flatbuffers::VOffsetT = 8;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_TYP: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    ObjectExpression::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn with(&self) -> Option<IdentifierExpression<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<IdentifierExpression<'a>>>(
                    ObjectExpression::VT_WITH,
                    None,
                )
        }
        #[inline]
        pub fn properties(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<Property<'a>>>,
            >>(ObjectExpression::VT_PROPERTIES, None)
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(ObjectExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ObjectExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct ObjectExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub with: Option<flatbuffers::WIPOffset<IdentifierExpression<'a>>>,
        pub properties: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>,
            >,
        >,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ObjectExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            ObjectExpressionArgs {
                loc: None,
                with: None,
                properties: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct ObjectExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ObjectExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    ObjectExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_with(&mut self, with: flatbuffers::WIPOffset<IdentifierExpression<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<IdentifierExpression>>(
                    ObjectExpression::VT_WITH,
                    with,
                );
        }
        #[inline]
        pub fn add_properties(
            &mut self,
            properties: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Property<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ObjectExpression::VT_PROPERTIES,
                properties,
            );
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                ObjectExpression::VT_TYP_TYPE,
                typ_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ObjectExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ObjectExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ObjectExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ObjectExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum UnaryExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct UnaryExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnaryExpression<'a> {
        type Inner = UnaryExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> UnaryExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnaryExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UnaryExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<UnaryExpression<'bldr>> {
            let mut builder = UnaryExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.argument {
                builder.add_argument(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.add_argument_type(args.argument_type);
            builder.add_operator(args.operator);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_OPERATOR: flatbuffers::VOffsetT = 6;
        pub const VT_ARGUMENT_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_ARGUMENT: flatbuffers::VOffsetT = 10;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 12;
        pub const VT_TYP: flatbuffers::VOffsetT = 14;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    UnaryExpression::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn operator(&self) -> Operator {
            self._tab
                .get::<Operator>(
                    UnaryExpression::VT_OPERATOR,
                    Some(Operator::MultiplicationOperator),
                )
                .unwrap()
        }
        #[inline]
        pub fn argument_type(&self) -> Expression {
            self._tab
                .get::<Expression>(UnaryExpression::VT_ARGUMENT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn argument(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    UnaryExpression::VT_ARGUMENT,
                    None,
                )
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(UnaryExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    UnaryExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.argument_type() == Expression::StringExpression {
                self.argument()
                    .map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.argument_type() == Expression::ArrayExpression {
                self.argument().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.argument_type() == Expression::FunctionExpression {
                self.argument()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.argument_type() == Expression::BinaryExpression {
                self.argument()
                    .map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.argument_type() == Expression::CallExpression {
                self.argument().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.argument_type() == Expression::ConditionalExpression {
                self.argument()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.argument_type() == Expression::IdentifierExpression {
                self.argument()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.argument_type() == Expression::LogicalExpression {
                self.argument()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.argument_type() == Expression::MemberExpression {
                self.argument()
                    .map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.argument_type() == Expression::IndexExpression {
                self.argument().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.argument_type() == Expression::ObjectExpression {
                self.argument()
                    .map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.argument_type() == Expression::UnaryExpression {
                self.argument().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.argument_type() == Expression::BooleanLiteral {
                self.argument().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.argument_type() == Expression::DateTimeLiteral {
                self.argument().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.argument_type() == Expression::DurationLiteral {
                self.argument().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.argument_type() == Expression::FloatLiteral {
                self.argument().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.argument_type() == Expression::IntegerLiteral {
                self.argument().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.argument_type() == Expression::StringLiteral {
                self.argument().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.argument_type() == Expression::RegexpLiteral {
                self.argument().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.argument_type() == Expression::UnsignedIntegerLiteral {
                self.argument()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct UnaryExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub operator: Operator,
        pub argument_type: Expression,
        pub argument: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for UnaryExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            UnaryExpressionArgs {
                loc: None,
                operator: Operator::MultiplicationOperator,
                argument_type: Expression::NONE,
                argument: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct UnaryExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UnaryExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    UnaryExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_operator(&mut self, operator: Operator) {
            self.fbb_.push_slot::<Operator>(
                UnaryExpression::VT_OPERATOR,
                operator,
                Operator::MultiplicationOperator,
            );
        }
        #[inline]
        pub fn add_argument_type(&mut self, argument_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                UnaryExpression::VT_ARGUMENT_TYPE,
                argument_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_argument(
            &mut self,
            argument: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UnaryExpression::VT_ARGUMENT,
                argument,
            );
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(UnaryExpression::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UnaryExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UnaryExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UnaryExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnaryExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum PropertyOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Property<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Property<'a> {
        type Inner = Property<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Property<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Property { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PropertyArgs<'args>,
        ) -> flatbuffers::WIPOffset<Property<'bldr>> {
            let mut builder = PropertyBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_value_type(args.value_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_KEY: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_VALUE: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(Property::VT_LOC, None)
        }
        #[inline]
        pub fn key(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(Property::VT_KEY, None)
        }
        #[inline]
        pub fn value_type(&self) -> Expression {
            self._tab
                .get::<Expression>(Property::VT_VALUE_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    Property::VT_VALUE,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.value_type() == Expression::StringExpression {
                self.value().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.value_type() == Expression::ArrayExpression {
                self.value().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.value_type() == Expression::FunctionExpression {
                self.value().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.value_type() == Expression::BinaryExpression {
                self.value().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.value_type() == Expression::CallExpression {
                self.value().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.value_type() == Expression::ConditionalExpression {
                self.value()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
            if self.value_type() == Expression::IdentifierExpression {
                self.value()
                    .map(|u| IdentifierExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.value_type() == Expression::LogicalExpression {
                self.value().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.value_type() == Expression::MemberExpression {
                self.value().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.value_type() == Expression::IndexExpression {
                self.value().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.value_type() == Expression::ObjectExpression {
                self.value().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.value_type() == Expression::UnaryExpression {
                self.value().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.value_type() == Expression::BooleanLiteral {
                self.value().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.value_type() == Expression::DateTimeLiteral {
                self.value().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.value_type() == Expression::DurationLiteral {
                self.value().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.value_type() == Expression::FloatLiteral {
                self.value().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.value_type() == Expression::IntegerLiteral {
                self.value().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.value_type() == Expression::StringLiteral {
                self.value().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.value_type() == Expression::RegexpLiteral {
                self.value().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.value_type() == Expression::UnsignedIntegerLiteral {
                self.value()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct PropertyArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub key: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub value_type: Expression,
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for PropertyArgs<'a> {
        #[inline]
        fn default() -> Self {
            PropertyArgs {
                loc: None,
                key: None,
                value_type: Expression::NONE,
                value: None,
            }
        }
    }
    pub struct PropertyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PropertyBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(Property::VT_LOC, loc);
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(Property::VT_KEY, key);
        }
        #[inline]
        pub fn add_value_type(&mut self, value_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                Property::VT_VALUE_TYPE,
                value_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Property::VT_VALUE, value);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PropertyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PropertyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Property<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum IdentifierExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct IdentifierExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for IdentifierExpression<'a> {
        type Inner = IdentifierExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> IdentifierExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            IdentifierExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IdentifierExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<IdentifierExpression<'bldr>> {
            let mut builder = IdentifierExpressionBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_TYP: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    IdentifierExpression::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(IdentifierExpression::VT_NAME, None)
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(IdentifierExpression::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    IdentifierExpression::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct IdentifierExpressionArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for IdentifierExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            IdentifierExpressionArgs {
                loc: None,
                name: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct IdentifierExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IdentifierExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    IdentifierExpression::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IdentifierExpression::VT_NAME, name);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                IdentifierExpression::VT_TYP_TYPE,
                typ_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IdentifierExpression::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> IdentifierExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IdentifierExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<IdentifierExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum IdentifierOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Identifier<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Identifier<'a> {
        type Inner = Identifier<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Identifier<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Identifier { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IdentifierArgs<'args>,
        ) -> flatbuffers::WIPOffset<Identifier<'bldr>> {
            let mut builder = IdentifierBuilder::new(_fbb);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(Identifier::VT_LOC, None)
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Identifier::VT_NAME, None)
        }
    }

    pub struct IdentifierArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for IdentifierArgs<'a> {
        #[inline]
        fn default() -> Self {
            IdentifierArgs {
                loc: None,
                name: None,
            }
        }
    }
    pub struct IdentifierBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IdentifierBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    Identifier::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Identifier::VT_NAME, name);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IdentifierBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IdentifierBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Identifier<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum BooleanLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct BooleanLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BooleanLiteral<'a> {
        type Inner = BooleanLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> BooleanLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BooleanLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BooleanLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<BooleanLiteral<'bldr>> {
            let mut builder = BooleanLiteralBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.add_value(args.value);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_TYP: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    BooleanLiteral::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn value(&self) -> bool {
            self._tab
                .get::<bool>(BooleanLiteral::VT_VALUE, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(BooleanLiteral::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    BooleanLiteral::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct BooleanLiteralArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub value: bool,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for BooleanLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            BooleanLiteralArgs {
                loc: None,
                value: false,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct BooleanLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BooleanLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    BooleanLiteral::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: bool) {
            self.fbb_
                .push_slot::<bool>(BooleanLiteral::VT_VALUE, value, false);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(BooleanLiteral::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BooleanLiteral::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BooleanLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BooleanLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BooleanLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum DateTimeLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct DateTimeLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DateTimeLiteral<'a> {
        type Inner = DateTimeLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> DateTimeLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DateTimeLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DateTimeLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<DateTimeLiteral<'bldr>> {
            let mut builder = DateTimeLiteralBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_TYP: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    DateTimeLiteral::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn value(&self) -> Option<Time<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Time<'a>>>(DateTimeLiteral::VT_VALUE, None)
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(DateTimeLiteral::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    DateTimeLiteral::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct DateTimeLiteralArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub value: Option<flatbuffers::WIPOffset<Time<'a>>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for DateTimeLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            DateTimeLiteralArgs {
                loc: None,
                value: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct DateTimeLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DateTimeLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    DateTimeLiteral::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<Time<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Time>>(DateTimeLiteral::VT_VALUE, value);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(DateTimeLiteral::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DateTimeLiteral::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DateTimeLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DateTimeLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DateTimeLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum TimeOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Time<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Time<'a> {
        type Inner = Time<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Time<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Time { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TimeArgs,
        ) -> flatbuffers::WIPOffset<Time<'bldr>> {
            let mut builder = TimeBuilder::new(_fbb);
            builder.add_secs(args.secs);
            builder.add_offset(args.offset);
            builder.add_nsecs(args.nsecs);
            builder.finish()
        }

        pub const VT_SECS: flatbuffers::VOffsetT = 4;
        pub const VT_NSECS: flatbuffers::VOffsetT = 6;
        pub const VT_OFFSET: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn secs(&self) -> i64 {
            self._tab.get::<i64>(Time::VT_SECS, Some(0)).unwrap()
        }
        #[inline]
        pub fn nsecs(&self) -> u32 {
            self._tab.get::<u32>(Time::VT_NSECS, Some(0)).unwrap()
        }
        #[inline]
        pub fn offset(&self) -> i32 {
            self._tab.get::<i32>(Time::VT_OFFSET, Some(0)).unwrap()
        }
    }

    pub struct TimeArgs {
        pub secs: i64,
        pub nsecs: u32,
        pub offset: i32,
    }
    impl<'a> Default for TimeArgs {
        #[inline]
        fn default() -> Self {
            TimeArgs {
                secs: 0,
                nsecs: 0,
                offset: 0,
            }
        }
    }
    pub struct TimeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TimeBuilder<'a, 'b> {
        #[inline]
        pub fn add_secs(&mut self, secs: i64) {
            self.fbb_.push_slot::<i64>(Time::VT_SECS, secs, 0);
        }
        #[inline]
        pub fn add_nsecs(&mut self, nsecs: u32) {
            self.fbb_.push_slot::<u32>(Time::VT_NSECS, nsecs, 0);
        }
        #[inline]
        pub fn add_offset(&mut self, offset: i32) {
            self.fbb_.push_slot::<i32>(Time::VT_OFFSET, offset, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TimeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TimeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Time<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum DurationLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct DurationLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DurationLiteral<'a> {
        type Inner = DurationLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> DurationLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DurationLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DurationLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<DurationLiteral<'bldr>> {
            let mut builder = DurationLiteralBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_TYP: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    DurationLiteral::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn value(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Duration<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<Duration<'a>>>,
            >>(DurationLiteral::VT_VALUE, None)
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(DurationLiteral::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    DurationLiteral::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct DurationLiteralArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub value: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Duration<'a>>>,
            >,
        >,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for DurationLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            DurationLiteralArgs {
                loc: None,
                value: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct DurationLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DurationLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    DurationLiteral::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_value(
            &mut self,
            value: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Duration<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DurationLiteral::VT_VALUE, value);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(DurationLiteral::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DurationLiteral::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DurationLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DurationLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DurationLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum DurationOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Duration<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Duration<'a> {
        type Inner = Duration<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Duration<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Duration { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DurationArgs,
        ) -> flatbuffers::WIPOffset<Duration<'bldr>> {
            let mut builder = DurationBuilder::new(_fbb);
            builder.add_magnitude(args.magnitude);
            builder.add_unit(args.unit);
            builder.finish()
        }

        pub const VT_MAGNITUDE: flatbuffers::VOffsetT = 4;
        pub const VT_UNIT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn magnitude(&self) -> i64 {
            self._tab
                .get::<i64>(Duration::VT_MAGNITUDE, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn unit(&self) -> TimeUnit {
            self._tab
                .get::<TimeUnit>(Duration::VT_UNIT, Some(TimeUnit::y))
                .unwrap()
        }
    }

    pub struct DurationArgs {
        pub magnitude: i64,
        pub unit: TimeUnit,
    }
    impl<'a> Default for DurationArgs {
        #[inline]
        fn default() -> Self {
            DurationArgs {
                magnitude: 0,
                unit: TimeUnit::y,
            }
        }
    }
    pub struct DurationBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DurationBuilder<'a, 'b> {
        #[inline]
        pub fn add_magnitude(&mut self, magnitude: i64) {
            self.fbb_
                .push_slot::<i64>(Duration::VT_MAGNITUDE, magnitude, 0);
        }
        #[inline]
        pub fn add_unit(&mut self, unit: TimeUnit) {
            self.fbb_
                .push_slot::<TimeUnit>(Duration::VT_UNIT, unit, TimeUnit::y);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DurationBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DurationBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Duration<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum IntegerLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct IntegerLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for IntegerLiteral<'a> {
        type Inner = IntegerLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> IntegerLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            IntegerLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IntegerLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<IntegerLiteral<'bldr>> {
            let mut builder = IntegerLiteralBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_TYP: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    IntegerLiteral::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn value(&self) -> i64 {
            self._tab
                .get::<i64>(IntegerLiteral::VT_VALUE, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(IntegerLiteral::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    IntegerLiteral::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct IntegerLiteralArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub value: i64,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for IntegerLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            IntegerLiteralArgs {
                loc: None,
                value: 0,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct IntegerLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IntegerLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    IntegerLiteral::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: i64) {
            self.fbb_
                .push_slot::<i64>(IntegerLiteral::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(IntegerLiteral::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IntegerLiteral::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> IntegerLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IntegerLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<IntegerLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FloatLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct FloatLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FloatLiteral<'a> {
        type Inner = FloatLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> FloatLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FloatLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FloatLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<FloatLiteral<'bldr>> {
            let mut builder = FloatLiteralBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_TYP: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(FloatLiteral::VT_LOC, None)
        }
        #[inline]
        pub fn value(&self) -> f64 {
            self._tab
                .get::<f64>(FloatLiteral::VT_VALUE, Some(0.0))
                .unwrap()
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(FloatLiteral::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    FloatLiteral::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct FloatLiteralArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub value: f64,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for FloatLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            FloatLiteralArgs {
                loc: None,
                value: 0.0,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct FloatLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FloatLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    FloatLiteral::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: f64) {
            self.fbb_
                .push_slot::<f64>(FloatLiteral::VT_VALUE, value, 0.0);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(FloatLiteral::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FloatLiteral::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FloatLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FloatLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FloatLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum RegexpLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct RegexpLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RegexpLiteral<'a> {
        type Inner = RegexpLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> RegexpLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RegexpLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RegexpLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<RegexpLiteral<'bldr>> {
            let mut builder = RegexpLiteralBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_TYP: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    RegexpLiteral::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn value(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(RegexpLiteral::VT_VALUE, None)
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(RegexpLiteral::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    RegexpLiteral::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct RegexpLiteralArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub value: Option<flatbuffers::WIPOffset<&'a str>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for RegexpLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            RegexpLiteralArgs {
                loc: None,
                value: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct RegexpLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RegexpLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    RegexpLiteral::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(RegexpLiteral::VT_VALUE, value);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(RegexpLiteral::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(RegexpLiteral::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> RegexpLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RegexpLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RegexpLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum StringLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct StringLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StringLiteral<'a> {
        type Inner = StringLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> StringLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StringLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StringLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<StringLiteral<'bldr>> {
            let mut builder = StringLiteralBuilder::new(_fbb);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_TYP: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    StringLiteral::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn value(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(StringLiteral::VT_VALUE, None)
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(StringLiteral::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    StringLiteral::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct StringLiteralArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub value: Option<flatbuffers::WIPOffset<&'a str>>,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for StringLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            StringLiteralArgs {
                loc: None,
                value: None,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct StringLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StringLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    StringLiteral::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(StringLiteral::VT_VALUE, value);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_
                .push_slot::<MonoType>(StringLiteral::VT_TYP_TYPE, typ_type, MonoType::NONE);
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(StringLiteral::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> StringLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StringLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StringLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum UnsignedIntegerLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct UnsignedIntegerLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnsignedIntegerLiteral<'a> {
        type Inner = UnsignedIntegerLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> UnsignedIntegerLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnsignedIntegerLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UnsignedIntegerLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<UnsignedIntegerLiteral<'bldr>> {
            let mut builder = UnsignedIntegerLiteralBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.typ {
                builder.add_typ(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.add_typ_type(args.typ_type);
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;
        pub const VT_TYP_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_TYP: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(
                    UnsignedIntegerLiteral::VT_LOC,
                    None,
                )
        }
        #[inline]
        pub fn value(&self) -> u64 {
            self._tab
                .get::<u64>(UnsignedIntegerLiteral::VT_VALUE, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn typ_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(UnsignedIntegerLiteral::VT_TYP_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typ(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    UnsignedIntegerLiteral::VT_TYP,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_basic(&self) -> Option<Basic<'a>> {
            if self.typ_type() == MonoType::Basic {
                self.typ().map(|u| Basic::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_var(&self) -> Option<Var<'a>> {
            if self.typ_type() == MonoType::Var {
                self.typ().map(|u| Var::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_arr(&self) -> Option<Arr<'a>> {
            if self.typ_type() == MonoType::Arr {
                self.typ().map(|u| Arr::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_row(&self) -> Option<Row<'a>> {
            if self.typ_type() == MonoType::Row {
                self.typ().map(|u| Row::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typ_as_fun(&self) -> Option<Fun<'a>> {
            if self.typ_type() == MonoType::Fun {
                self.typ().map(|u| Fun::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct UnsignedIntegerLiteralArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub value: u64,
        pub typ_type: MonoType,
        pub typ: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for UnsignedIntegerLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            UnsignedIntegerLiteralArgs {
                loc: None,
                value: 0,
                typ_type: MonoType::NONE,
                typ: None,
            }
        }
    }
    pub struct UnsignedIntegerLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UnsignedIntegerLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(
                    UnsignedIntegerLiteral::VT_LOC,
                    loc,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_
                .push_slot::<u64>(UnsignedIntegerLiteral::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn add_typ_type(&mut self, typ_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                UnsignedIntegerLiteral::VT_TYP_TYPE,
                typ_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_typ(&mut self, typ: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UnsignedIntegerLiteral::VT_TYP, typ);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UnsignedIntegerLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UnsignedIntegerLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnsignedIntegerLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    #[inline]
    pub fn get_root_as_package<'a>(buf: &'a [u8]) -> Package<'a> {
        flatbuffers::get_root::<Package<'a>>(buf)
    }

    #[inline]
    pub fn get_size_prefixed_root_as_package<'a>(buf: &'a [u8]) -> Package<'a> {
        flatbuffers::get_size_prefixed_root::<Package<'a>>(buf)
    }

    #[inline]
    pub fn finish_package_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Package<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_package_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Package<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod fbsemantic

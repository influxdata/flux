// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod fbast {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;

    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum MonoType {
        NONE = 0,
        NamedType = 1,
        TvarType = 2,
        ArrayType = 3,
        RecordType = 4,
        FunctionType = 5,
    }

    const ENUM_MIN_MONO_TYPE: u8 = 0;
    const ENUM_MAX_MONO_TYPE: u8 = 5;

    impl<'a> flatbuffers::Follow<'a> for MonoType {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for MonoType {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const MonoType;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const MonoType;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for MonoType {
        type Output = MonoType;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<MonoType>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_MONO_TYPE: [MonoType; 6] = [
        MonoType::NONE,
        MonoType::NamedType,
        MonoType::TvarType,
        MonoType::ArrayType,
        MonoType::RecordType,
        MonoType::FunctionType,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_MONO_TYPE: [&'static str; 6] = [
        "NONE",
        "NamedType",
        "TvarType",
        "ArrayType",
        "RecordType",
        "FunctionType",
    ];

    pub fn enum_name_mono_type(e: MonoType) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_MONO_TYPE[index as usize]
    }

    pub struct MonoTypeUnionTableOffset {}
    #[allow(non_camel_case_types)]
    #[repr(i8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum ParameterKind {
        Required = 0,
        Optional = 1,
        Pipe = 2,
    }

    const ENUM_MIN_PARAMETER_KIND: i8 = 0;
    const ENUM_MAX_PARAMETER_KIND: i8 = 2;

    impl<'a> flatbuffers::Follow<'a> for ParameterKind {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for ParameterKind {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = i8::to_le(self as i8);
            let p = &n as *const i8 as *const ParameterKind;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = i8::from_le(self as i8);
            let p = &n as *const i8 as *const ParameterKind;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for ParameterKind {
        type Output = ParameterKind;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<ParameterKind>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_PARAMETER_KIND: [ParameterKind; 3] = [
        ParameterKind::Required,
        ParameterKind::Optional,
        ParameterKind::Pipe,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_PARAMETER_KIND: [&'static str; 3] = ["Required", "Optional", "Pipe"];

    pub fn enum_name_parameter_kind(e: ParameterKind) -> &'static str {
        let index = e as i8;
        ENUM_NAMES_PARAMETER_KIND[index as usize]
    }

    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum Statement {
        NONE = 0,
        BadStatement = 1,
        VariableAssignment = 2,
        MemberAssignment = 3,
        ExpressionStatement = 4,
        ReturnStatement = 5,
        OptionStatement = 6,
        BuiltinStatement = 7,
        TestStatement = 8,
    }

    const ENUM_MIN_STATEMENT: u8 = 0;
    const ENUM_MAX_STATEMENT: u8 = 8;

    impl<'a> flatbuffers::Follow<'a> for Statement {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for Statement {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const Statement;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const Statement;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for Statement {
        type Output = Statement;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<Statement>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_STATEMENT: [Statement; 9] = [
        Statement::NONE,
        Statement::BadStatement,
        Statement::VariableAssignment,
        Statement::MemberAssignment,
        Statement::ExpressionStatement,
        Statement::ReturnStatement,
        Statement::OptionStatement,
        Statement::BuiltinStatement,
        Statement::TestStatement,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_STATEMENT: [&'static str; 9] = [
        "NONE",
        "BadStatement",
        "VariableAssignment",
        "MemberAssignment",
        "ExpressionStatement",
        "ReturnStatement",
        "OptionStatement",
        "BuiltinStatement",
        "TestStatement",
    ];

    pub fn enum_name_statement(e: Statement) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_STATEMENT[index as usize]
    }

    pub struct StatementUnionTableOffset {}
    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum Assignment {
        NONE = 0,
        MemberAssignment = 1,
        VariableAssignment = 2,
    }

    const ENUM_MIN_ASSIGNMENT: u8 = 0;
    const ENUM_MAX_ASSIGNMENT: u8 = 2;

    impl<'a> flatbuffers::Follow<'a> for Assignment {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for Assignment {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const Assignment;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const Assignment;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for Assignment {
        type Output = Assignment;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<Assignment>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_ASSIGNMENT: [Assignment; 3] = [
        Assignment::NONE,
        Assignment::MemberAssignment,
        Assignment::VariableAssignment,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_ASSIGNMENT: [&'static str; 3] =
        ["NONE", "MemberAssignment", "VariableAssignment"];

    pub fn enum_name_assignment(e: Assignment) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_ASSIGNMENT[index as usize]
    }

    pub struct AssignmentUnionTableOffset {}
    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum Expression {
        NONE = 0,
        StringExpression = 1,
        ParenExpression = 2,
        ArrayExpression = 3,
        FunctionExpression = 4,
        BinaryExpression = 5,
        BooleanLiteral = 6,
        CallExpression = 7,
        ConditionalExpression = 8,
        DateTimeLiteral = 9,
        DurationLiteral = 10,
        FloatLiteral = 11,
        Identifier = 12,
        IntegerLiteral = 13,
        LogicalExpression = 14,
        MemberExpression = 15,
        IndexExpression = 16,
        ObjectExpression = 17,
        PipeExpression = 18,
        PipeLiteral = 19,
        RegexpLiteral = 20,
        StringLiteral = 21,
        UnaryExpression = 22,
        UnsignedIntegerLiteral = 23,
        BadExpression = 24,
    }

    const ENUM_MIN_EXPRESSION: u8 = 0;
    const ENUM_MAX_EXPRESSION: u8 = 24;

    impl<'a> flatbuffers::Follow<'a> for Expression {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for Expression {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const Expression;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const Expression;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for Expression {
        type Output = Expression;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<Expression>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_EXPRESSION: [Expression; 25] = [
        Expression::NONE,
        Expression::StringExpression,
        Expression::ParenExpression,
        Expression::ArrayExpression,
        Expression::FunctionExpression,
        Expression::BinaryExpression,
        Expression::BooleanLiteral,
        Expression::CallExpression,
        Expression::ConditionalExpression,
        Expression::DateTimeLiteral,
        Expression::DurationLiteral,
        Expression::FloatLiteral,
        Expression::Identifier,
        Expression::IntegerLiteral,
        Expression::LogicalExpression,
        Expression::MemberExpression,
        Expression::IndexExpression,
        Expression::ObjectExpression,
        Expression::PipeExpression,
        Expression::PipeLiteral,
        Expression::RegexpLiteral,
        Expression::StringLiteral,
        Expression::UnaryExpression,
        Expression::UnsignedIntegerLiteral,
        Expression::BadExpression,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_EXPRESSION: [&'static str; 25] = [
        "NONE",
        "StringExpression",
        "ParenExpression",
        "ArrayExpression",
        "FunctionExpression",
        "BinaryExpression",
        "BooleanLiteral",
        "CallExpression",
        "ConditionalExpression",
        "DateTimeLiteral",
        "DurationLiteral",
        "FloatLiteral",
        "Identifier",
        "IntegerLiteral",
        "LogicalExpression",
        "MemberExpression",
        "IndexExpression",
        "ObjectExpression",
        "PipeExpression",
        "PipeLiteral",
        "RegexpLiteral",
        "StringLiteral",
        "UnaryExpression",
        "UnsignedIntegerLiteral",
        "BadExpression",
    ];

    pub fn enum_name_expression(e: Expression) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_EXPRESSION[index as usize]
    }

    pub struct ExpressionUnionTableOffset {}
    #[allow(non_camel_case_types)]
    #[repr(i8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum Operator {
        InvalidOperator = 0,
        MultiplicationOperator = 1,
        DivisionOperator = 2,
        ModuloOperator = 3,
        PowerOperator = 4,
        AdditionOperator = 5,
        SubtractionOperator = 6,
        LessThanEqualOperator = 7,
        LessThanOperator = 8,
        GreaterThanEqualOperator = 9,
        GreaterThanOperator = 10,
        StartsWithOperator = 11,
        InOperator = 12,
        NotOperator = 13,
        ExistsOperator = 14,
        NotEmptyOperator = 15,
        EmptyOperator = 16,
        EqualOperator = 17,
        NotEqualOperator = 18,
        RegexpMatchOperator = 19,
        NotRegexpMatchOperator = 20,
    }

    const ENUM_MIN_OPERATOR: i8 = 0;
    const ENUM_MAX_OPERATOR: i8 = 20;

    impl<'a> flatbuffers::Follow<'a> for Operator {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for Operator {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = i8::to_le(self as i8);
            let p = &n as *const i8 as *const Operator;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = i8::from_le(self as i8);
            let p = &n as *const i8 as *const Operator;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for Operator {
        type Output = Operator;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<Operator>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_OPERATOR: [Operator; 21] = [
        Operator::InvalidOperator,
        Operator::MultiplicationOperator,
        Operator::DivisionOperator,
        Operator::ModuloOperator,
        Operator::PowerOperator,
        Operator::AdditionOperator,
        Operator::SubtractionOperator,
        Operator::LessThanEqualOperator,
        Operator::LessThanOperator,
        Operator::GreaterThanEqualOperator,
        Operator::GreaterThanOperator,
        Operator::StartsWithOperator,
        Operator::InOperator,
        Operator::NotOperator,
        Operator::ExistsOperator,
        Operator::NotEmptyOperator,
        Operator::EmptyOperator,
        Operator::EqualOperator,
        Operator::NotEqualOperator,
        Operator::RegexpMatchOperator,
        Operator::NotRegexpMatchOperator,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_OPERATOR: [&'static str; 21] = [
        "InvalidOperator",
        "MultiplicationOperator",
        "DivisionOperator",
        "ModuloOperator",
        "PowerOperator",
        "AdditionOperator",
        "SubtractionOperator",
        "LessThanEqualOperator",
        "LessThanOperator",
        "GreaterThanEqualOperator",
        "GreaterThanOperator",
        "StartsWithOperator",
        "InOperator",
        "NotOperator",
        "ExistsOperator",
        "NotEmptyOperator",
        "EmptyOperator",
        "EqualOperator",
        "NotEqualOperator",
        "RegexpMatchOperator",
        "NotRegexpMatchOperator",
    ];

    pub fn enum_name_operator(e: Operator) -> &'static str {
        let index = e as i8;
        ENUM_NAMES_OPERATOR[index as usize]
    }

    #[allow(non_camel_case_types)]
    #[repr(i8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum LogicalOperator {
        AndOperator = 0,
        OrOperator = 1,
    }

    const ENUM_MIN_LOGICAL_OPERATOR: i8 = 0;
    const ENUM_MAX_LOGICAL_OPERATOR: i8 = 1;

    impl<'a> flatbuffers::Follow<'a> for LogicalOperator {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for LogicalOperator {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = i8::to_le(self as i8);
            let p = &n as *const i8 as *const LogicalOperator;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = i8::from_le(self as i8);
            let p = &n as *const i8 as *const LogicalOperator;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for LogicalOperator {
        type Output = LogicalOperator;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<LogicalOperator>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_LOGICAL_OPERATOR: [LogicalOperator; 2] =
        [LogicalOperator::AndOperator, LogicalOperator::OrOperator];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_LOGICAL_OPERATOR: [&'static str; 2] = ["AndOperator", "OrOperator"];

    pub fn enum_name_logical_operator(e: LogicalOperator) -> &'static str {
        let index = e as i8;
        ENUM_NAMES_LOGICAL_OPERATOR[index as usize]
    }

    #[allow(non_camel_case_types)]
    #[repr(i8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum TimeUnit {
        y = 0,
        mo = 1,
        w = 2,
        d = 3,
        h = 4,
        m = 5,
        s = 6,
        ms = 7,
        us = 8,
        ns = 9,
    }

    const ENUM_MIN_TIME_UNIT: i8 = 0;
    const ENUM_MAX_TIME_UNIT: i8 = 9;

    impl<'a> flatbuffers::Follow<'a> for TimeUnit {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for TimeUnit {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = i8::to_le(self as i8);
            let p = &n as *const i8 as *const TimeUnit;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = i8::from_le(self as i8);
            let p = &n as *const i8 as *const TimeUnit;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for TimeUnit {
        type Output = TimeUnit;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<TimeUnit>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_TIME_UNIT: [TimeUnit; 10] = [
        TimeUnit::y,
        TimeUnit::mo,
        TimeUnit::w,
        TimeUnit::d,
        TimeUnit::h,
        TimeUnit::m,
        TimeUnit::s,
        TimeUnit::ms,
        TimeUnit::us,
        TimeUnit::ns,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_TIME_UNIT: [&'static str; 10] =
        ["y", "mo", "w", "d", "h", "m", "s", "ms", "us", "ns"];

    pub fn enum_name_time_unit(e: TimeUnit) -> &'static str {
        let index = e as i8;
        ENUM_NAMES_TIME_UNIT[index as usize]
    }

    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum ExpressionOrBlock {
        NONE = 0,
        Block = 1,
        WrappedExpression = 2,
    }

    const ENUM_MIN_EXPRESSION_OR_BLOCK: u8 = 0;
    const ENUM_MAX_EXPRESSION_OR_BLOCK: u8 = 2;

    impl<'a> flatbuffers::Follow<'a> for ExpressionOrBlock {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for ExpressionOrBlock {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const ExpressionOrBlock;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const ExpressionOrBlock;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for ExpressionOrBlock {
        type Output = ExpressionOrBlock;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<ExpressionOrBlock>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_EXPRESSION_OR_BLOCK: [ExpressionOrBlock; 3] = [
        ExpressionOrBlock::NONE,
        ExpressionOrBlock::Block,
        ExpressionOrBlock::WrappedExpression,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_EXPRESSION_OR_BLOCK: [&'static str; 3] =
        ["NONE", "Block", "WrappedExpression"];

    pub fn enum_name_expression_or_block(e: ExpressionOrBlock) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_EXPRESSION_OR_BLOCK[index as usize]
    }

    pub struct ExpressionOrBlockUnionTableOffset {}
    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum PropertyKey {
        NONE = 0,
        Identifier = 1,
        StringLiteral = 2,
    }

    const ENUM_MIN_PROPERTY_KEY: u8 = 0;
    const ENUM_MAX_PROPERTY_KEY: u8 = 2;

    impl<'a> flatbuffers::Follow<'a> for PropertyKey {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for PropertyKey {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const PropertyKey;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const PropertyKey;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for PropertyKey {
        type Output = PropertyKey;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<PropertyKey>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_PROPERTY_KEY: [PropertyKey; 3] = [
        PropertyKey::NONE,
        PropertyKey::Identifier,
        PropertyKey::StringLiteral,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_PROPERTY_KEY: [&'static str; 3] = ["NONE", "Identifier", "StringLiteral"];

    pub fn enum_name_property_key(e: PropertyKey) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_PROPERTY_KEY[index as usize]
    }

    pub struct PropertyKeyUnionTableOffset {}
    // struct Position, aligned to 4
    #[repr(C, align(4))]
    #[derive(Clone, Copy, Debug, PartialEq)]
    pub struct Position {
        line_: i32,
        column_: i32,
    } // pub struct Position
    impl flatbuffers::SafeSliceAccess for Position {}
    impl<'a> flatbuffers::Follow<'a> for Position {
        type Inner = &'a Position;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Position>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Position {
        type Inner = &'a Position;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Position>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Position {
        type Output = Position;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(self as *const Position as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }
    impl<'b> flatbuffers::Push for &'b Position {
        type Output = Position;

        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(*self as *const Position as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }

    impl Position {
        pub fn new<'a>(_line: i32, _column: i32) -> Self {
            Position {
                line_: _line.to_little_endian(),
                column_: _column.to_little_endian(),
            }
        }
        pub fn line<'a>(&'a self) -> i32 {
            self.line_.from_little_endian()
        }
        pub fn column<'a>(&'a self) -> i32 {
            self.column_.from_little_endian()
        }
    }

    pub enum NamedTypeOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct NamedType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NamedType<'a> {
        type Inner = NamedType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> NamedType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NamedType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args NamedTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<NamedType<'bldr>> {
            let mut builder = NamedTypeBuilder::new(_fbb);
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(NamedType::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn id(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(NamedType::VT_ID, None)
        }
    }

    pub struct NamedTypeArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    }
    impl<'a> Default for NamedTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            NamedTypeArgs {
                base_node: None,
                id: None,
            }
        }
    }
    pub struct NamedTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NamedTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    NamedType::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(NamedType::VT_ID, id);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NamedTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            NamedTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NamedType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum TvarTypeOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct TvarType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TvarType<'a> {
        type Inner = TvarType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> TvarType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TvarType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TvarTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<TvarType<'bldr>> {
            let mut builder = TvarTypeBuilder::new(_fbb);
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(TvarType::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn id(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(TvarType::VT_ID, None)
        }
    }

    pub struct TvarTypeArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    }
    impl<'a> Default for TvarTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            TvarTypeArgs {
                base_node: None,
                id: None,
            }
        }
    }
    pub struct TvarTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TvarTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    TvarType::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(TvarType::VT_ID, id);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TvarTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TvarTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TvarType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ArrayTypeOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct ArrayType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ArrayType<'a> {
        type Inner = ArrayType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> ArrayType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ArrayType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ArrayTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<ArrayType<'bldr>> {
            let mut builder = ArrayTypeBuilder::new(_fbb);
            if let Some(x) = args.element {
                builder.add_element(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_element_type(args.element_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ELEMENT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ELEMENT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(ArrayType::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn element_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(ArrayType::VT_ELEMENT_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn element(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ArrayType::VT_ELEMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn element_as_named_type(&self) -> Option<NamedType<'a>> {
            if self.element_type() == MonoType::NamedType {
                self.element().map(|u| NamedType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn element_as_tvar_type(&self) -> Option<TvarType<'a>> {
            if self.element_type() == MonoType::TvarType {
                self.element().map(|u| TvarType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn element_as_array_type(&self) -> Option<ArrayType<'a>> {
            if self.element_type() == MonoType::ArrayType {
                self.element().map(|u| ArrayType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn element_as_record_type(&self) -> Option<RecordType<'a>> {
            if self.element_type() == MonoType::RecordType {
                self.element().map(|u| RecordType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn element_as_function_type(&self) -> Option<FunctionType<'a>> {
            if self.element_type() == MonoType::FunctionType {
                self.element().map(|u| FunctionType::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct ArrayTypeArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub element_type: MonoType,
        pub element: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ArrayTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            ArrayTypeArgs {
                base_node: None,
                element_type: MonoType::NONE,
                element: None,
            }
        }
    }
    pub struct ArrayTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ArrayTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ArrayType::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_element_type(&mut self, element_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                ArrayType::VT_ELEMENT_TYPE,
                element_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_element(
            &mut self,
            element: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayType::VT_ELEMENT, element);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrayTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ArrayTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ArrayType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum PropertyTypeOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct PropertyType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PropertyType<'a> {
        type Inner = PropertyType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> PropertyType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PropertyType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PropertyTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<PropertyType<'bldr>> {
            let mut builder = PropertyTypeBuilder::new(_fbb);
            if let Some(x) = args.monotype {
                builder.add_monotype(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_monotype_type(args.monotype_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;
        pub const VT_MONOTYPE_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_MONOTYPE: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(PropertyType::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn id(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(PropertyType::VT_ID, None)
        }
        #[inline]
        pub fn monotype_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(PropertyType::VT_MONOTYPE_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn monotype(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    PropertyType::VT_MONOTYPE,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_named_type(&self) -> Option<NamedType<'a>> {
            if self.monotype_type() == MonoType::NamedType {
                self.monotype().map(|u| NamedType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_tvar_type(&self) -> Option<TvarType<'a>> {
            if self.monotype_type() == MonoType::TvarType {
                self.monotype().map(|u| TvarType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_array_type(&self) -> Option<ArrayType<'a>> {
            if self.monotype_type() == MonoType::ArrayType {
                self.monotype().map(|u| ArrayType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_record_type(&self) -> Option<RecordType<'a>> {
            if self.monotype_type() == MonoType::RecordType {
                self.monotype().map(|u| RecordType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_function_type(&self) -> Option<FunctionType<'a>> {
            if self.monotype_type() == MonoType::FunctionType {
                self.monotype().map(|u| FunctionType::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct PropertyTypeArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub monotype_type: MonoType,
        pub monotype: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for PropertyTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            PropertyTypeArgs {
                base_node: None,
                id: None,
                monotype_type: MonoType::NONE,
                monotype: None,
            }
        }
    }
    pub struct PropertyTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PropertyTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    PropertyType::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(PropertyType::VT_ID, id);
        }
        #[inline]
        pub fn add_monotype_type(&mut self, monotype_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                PropertyType::VT_MONOTYPE_TYPE,
                monotype_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_monotype(
            &mut self,
            monotype: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PropertyType::VT_MONOTYPE, monotype);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> PropertyTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PropertyTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PropertyType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum RecordTypeOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct RecordType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RecordType<'a> {
        type Inner = RecordType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> RecordType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RecordType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RecordTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<RecordType<'bldr>> {
            let mut builder = RecordTypeBuilder::new(_fbb);
            if let Some(x) = args.tvar {
                builder.add_tvar(x);
            }
            if let Some(x) = args.properties {
                builder.add_properties(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_PROPERTIES: flatbuffers::VOffsetT = 6;
        pub const VT_TVAR: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(RecordType::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn properties(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PropertyType<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<PropertyType<'a>>>,
            >>(RecordType::VT_PROPERTIES, None)
        }
        #[inline]
        pub fn tvar(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(RecordType::VT_TVAR, None)
        }
    }

    pub struct RecordTypeArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub properties: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PropertyType<'a>>>,
            >,
        >,
        pub tvar: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    }
    impl<'a> Default for RecordTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            RecordTypeArgs {
                base_node: None,
                properties: None,
                tvar: None,
            }
        }
    }
    pub struct RecordTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RecordTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    RecordType::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_properties(
            &mut self,
            properties: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PropertyType<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                RecordType::VT_PROPERTIES,
                properties,
            );
        }
        #[inline]
        pub fn add_tvar(&mut self, tvar: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(RecordType::VT_TVAR, tvar);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RecordTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RecordTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RecordType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ParameterTypeOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct ParameterType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ParameterType<'a> {
        type Inner = ParameterType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> ParameterType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ParameterType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ParameterTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<ParameterType<'bldr>> {
            let mut builder = ParameterTypeBuilder::new(_fbb);
            if let Some(x) = args.monotype {
                builder.add_monotype(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_kind(args.kind);
            builder.add_monotype_type(args.monotype_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;
        pub const VT_MONOTYPE_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_MONOTYPE: flatbuffers::VOffsetT = 10;
        pub const VT_KIND: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                ParameterType::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn id(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(ParameterType::VT_ID, None)
        }
        #[inline]
        pub fn monotype_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(ParameterType::VT_MONOTYPE_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn monotype(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ParameterType::VT_MONOTYPE,
                    None,
                )
        }
        #[inline]
        pub fn kind(&self) -> ParameterKind {
            self._tab
                .get::<ParameterKind>(ParameterType::VT_KIND, Some(ParameterKind::Required))
                .unwrap()
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_named_type(&self) -> Option<NamedType<'a>> {
            if self.monotype_type() == MonoType::NamedType {
                self.monotype().map(|u| NamedType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_tvar_type(&self) -> Option<TvarType<'a>> {
            if self.monotype_type() == MonoType::TvarType {
                self.monotype().map(|u| TvarType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_array_type(&self) -> Option<ArrayType<'a>> {
            if self.monotype_type() == MonoType::ArrayType {
                self.monotype().map(|u| ArrayType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_record_type(&self) -> Option<RecordType<'a>> {
            if self.monotype_type() == MonoType::RecordType {
                self.monotype().map(|u| RecordType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_function_type(&self) -> Option<FunctionType<'a>> {
            if self.monotype_type() == MonoType::FunctionType {
                self.monotype().map(|u| FunctionType::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct ParameterTypeArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub monotype_type: MonoType,
        pub monotype: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub kind: ParameterKind,
    }
    impl<'a> Default for ParameterTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            ParameterTypeArgs {
                base_node: None,
                id: None,
                monotype_type: MonoType::NONE,
                monotype: None,
                kind: ParameterKind::Required,
            }
        }
    }
    pub struct ParameterTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ParameterTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ParameterType::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(ParameterType::VT_ID, id);
        }
        #[inline]
        pub fn add_monotype_type(&mut self, monotype_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                ParameterType::VT_MONOTYPE_TYPE,
                monotype_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_monotype(
            &mut self,
            monotype: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ParameterType::VT_MONOTYPE,
                monotype,
            );
        }
        #[inline]
        pub fn add_kind(&mut self, kind: ParameterKind) {
            self.fbb_.push_slot::<ParameterKind>(
                ParameterType::VT_KIND,
                kind,
                ParameterKind::Required,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ParameterTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ParameterTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ParameterType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FunctionTypeOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct FunctionType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FunctionType<'a> {
        type Inner = FunctionType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> FunctionType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FunctionType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FunctionTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<FunctionType<'bldr>> {
            let mut builder = FunctionTypeBuilder::new(_fbb);
            if let Some(x) = args.monotype {
                builder.add_monotype(x);
            }
            if let Some(x) = args.parameters {
                builder.add_parameters(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_monotype_type(args.monotype_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_PARAMETERS: flatbuffers::VOffsetT = 6;
        pub const VT_MONOTYPE_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_MONOTYPE: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(FunctionType::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn parameters(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParameterType<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<ParameterType<'a>>>,
            >>(FunctionType::VT_PARAMETERS, None)
        }
        #[inline]
        pub fn monotype_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(FunctionType::VT_MONOTYPE_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn monotype(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    FunctionType::VT_MONOTYPE,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_named_type(&self) -> Option<NamedType<'a>> {
            if self.monotype_type() == MonoType::NamedType {
                self.monotype().map(|u| NamedType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_tvar_type(&self) -> Option<TvarType<'a>> {
            if self.monotype_type() == MonoType::TvarType {
                self.monotype().map(|u| TvarType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_array_type(&self) -> Option<ArrayType<'a>> {
            if self.monotype_type() == MonoType::ArrayType {
                self.monotype().map(|u| ArrayType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_record_type(&self) -> Option<RecordType<'a>> {
            if self.monotype_type() == MonoType::RecordType {
                self.monotype().map(|u| RecordType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_function_type(&self) -> Option<FunctionType<'a>> {
            if self.monotype_type() == MonoType::FunctionType {
                self.monotype().map(|u| FunctionType::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct FunctionTypeArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub parameters: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParameterType<'a>>>,
            >,
        >,
        pub monotype_type: MonoType,
        pub monotype: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for FunctionTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            FunctionTypeArgs {
                base_node: None,
                parameters: None,
                monotype_type: MonoType::NONE,
                monotype: None,
            }
        }
    }
    pub struct FunctionTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FunctionTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    FunctionType::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_parameters(
            &mut self,
            parameters: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ParameterType<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                FunctionType::VT_PARAMETERS,
                parameters,
            );
        }
        #[inline]
        pub fn add_monotype_type(&mut self, monotype_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                FunctionType::VT_MONOTYPE_TYPE,
                monotype_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_monotype(
            &mut self,
            monotype: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionType::VT_MONOTYPE, monotype);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FunctionTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FunctionTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FunctionType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum TypeConstraintOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct TypeConstraint<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TypeConstraint<'a> {
        type Inner = TypeConstraint<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> TypeConstraint<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TypeConstraint { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TypeConstraintArgs<'args>,
        ) -> flatbuffers::WIPOffset<TypeConstraint<'bldr>> {
            let mut builder = TypeConstraintBuilder::new(_fbb);
            if let Some(x) = args.kinds {
                builder.add_kinds(x);
            }
            if let Some(x) = args.tvar {
                builder.add_tvar(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_TVAR: flatbuffers::VOffsetT = 6;
        pub const VT_KINDS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                TypeConstraint::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn tvar(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(TypeConstraint::VT_TVAR, None)
        }
        #[inline]
        pub fn kinds(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Identifier<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<Identifier<'a>>>,
            >>(TypeConstraint::VT_KINDS, None)
        }
    }

    pub struct TypeConstraintArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub tvar: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub kinds: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Identifier<'a>>>,
            >,
        >,
    }
    impl<'a> Default for TypeConstraintArgs<'a> {
        #[inline]
        fn default() -> Self {
            TypeConstraintArgs {
                base_node: None,
                tvar: None,
                kinds: None,
            }
        }
    }
    pub struct TypeConstraintBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TypeConstraintBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    TypeConstraint::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_tvar(&mut self, tvar: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    TypeConstraint::VT_TVAR,
                    tvar,
                );
        }
        #[inline]
        pub fn add_kinds(
            &mut self,
            kinds: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Identifier<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TypeConstraint::VT_KINDS, kinds);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TypeConstraintBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TypeConstraintBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TypeConstraint<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum TypeExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct TypeExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TypeExpression<'a> {
        type Inner = TypeExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> TypeExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TypeExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TypeExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<TypeExpression<'bldr>> {
            let mut builder = TypeExpressionBuilder::new(_fbb);
            if let Some(x) = args.constraints {
                builder.add_constraints(x);
            }
            if let Some(x) = args.monotype {
                builder.add_monotype(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_monotype_type(args.monotype_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_MONOTYPE_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_MONOTYPE: flatbuffers::VOffsetT = 8;
        pub const VT_CONSTRAINTS: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                TypeExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn monotype_type(&self) -> MonoType {
            self._tab
                .get::<MonoType>(TypeExpression::VT_MONOTYPE_TYPE, Some(MonoType::NONE))
                .unwrap()
        }
        #[inline]
        pub fn monotype(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    TypeExpression::VT_MONOTYPE,
                    None,
                )
        }
        #[inline]
        pub fn constraints(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TypeConstraint<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<TypeConstraint<'a>>>,
            >>(TypeExpression::VT_CONSTRAINTS, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_named_type(&self) -> Option<NamedType<'a>> {
            if self.monotype_type() == MonoType::NamedType {
                self.monotype().map(|u| NamedType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_tvar_type(&self) -> Option<TvarType<'a>> {
            if self.monotype_type() == MonoType::TvarType {
                self.monotype().map(|u| TvarType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_array_type(&self) -> Option<ArrayType<'a>> {
            if self.monotype_type() == MonoType::ArrayType {
                self.monotype().map(|u| ArrayType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_record_type(&self) -> Option<RecordType<'a>> {
            if self.monotype_type() == MonoType::RecordType {
                self.monotype().map(|u| RecordType::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn monotype_as_function_type(&self) -> Option<FunctionType<'a>> {
            if self.monotype_type() == MonoType::FunctionType {
                self.monotype().map(|u| FunctionType::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct TypeExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub monotype_type: MonoType,
        pub monotype: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub constraints: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TypeConstraint<'a>>>,
            >,
        >,
    }
    impl<'a> Default for TypeExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            TypeExpressionArgs {
                base_node: None,
                monotype_type: MonoType::NONE,
                monotype: None,
                constraints: None,
            }
        }
    }
    pub struct TypeExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TypeExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    TypeExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_monotype_type(&mut self, monotype_type: MonoType) {
            self.fbb_.push_slot::<MonoType>(
                TypeExpression::VT_MONOTYPE_TYPE,
                monotype_type,
                MonoType::NONE,
            );
        }
        #[inline]
        pub fn add_monotype(
            &mut self,
            monotype: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TypeExpression::VT_MONOTYPE,
                monotype,
            );
        }
        #[inline]
        pub fn add_constraints(
            &mut self,
            constraints: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TypeConstraint<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TypeExpression::VT_CONSTRAINTS,
                constraints,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TypeExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TypeExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TypeExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum SourceLocationOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct SourceLocation<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SourceLocation<'a> {
        type Inner = SourceLocation<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> SourceLocation<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SourceLocation { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SourceLocationArgs<'args>,
        ) -> flatbuffers::WIPOffset<SourceLocation<'bldr>> {
            let mut builder = SourceLocationBuilder::new(_fbb);
            if let Some(x) = args.source {
                builder.add_source(x);
            }
            if let Some(x) = args.end {
                builder.add_end(x);
            }
            if let Some(x) = args.start {
                builder.add_start(x);
            }
            if let Some(x) = args.file {
                builder.add_file(x);
            }
            builder.finish()
        }

        pub const VT_FILE: flatbuffers::VOffsetT = 4;
        pub const VT_START: flatbuffers::VOffsetT = 6;
        pub const VT_END: flatbuffers::VOffsetT = 8;
        pub const VT_SOURCE: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn file(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SourceLocation::VT_FILE, None)
        }
        #[inline]
        pub fn start(&self) -> Option<&'a Position> {
            self._tab.get::<Position>(SourceLocation::VT_START, None)
        }
        #[inline]
        pub fn end(&self) -> Option<&'a Position> {
            self._tab.get::<Position>(SourceLocation::VT_END, None)
        }
        #[inline]
        pub fn source(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SourceLocation::VT_SOURCE, None)
        }
    }

    pub struct SourceLocationArgs<'a> {
        pub file: Option<flatbuffers::WIPOffset<&'a str>>,
        pub start: Option<&'a Position>,
        pub end: Option<&'a Position>,
        pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for SourceLocationArgs<'a> {
        #[inline]
        fn default() -> Self {
            SourceLocationArgs {
                file: None,
                start: None,
                end: None,
                source: None,
            }
        }
    }
    pub struct SourceLocationBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SourceLocationBuilder<'a, 'b> {
        #[inline]
        pub fn add_file(&mut self, file: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SourceLocation::VT_FILE, file);
        }
        #[inline]
        pub fn add_start(&mut self, start: &'b Position) {
            self.fbb_
                .push_slot_always::<&Position>(SourceLocation::VT_START, start);
        }
        #[inline]
        pub fn add_end(&mut self, end: &'b Position) {
            self.fbb_
                .push_slot_always::<&Position>(SourceLocation::VT_END, end);
        }
        #[inline]
        pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SourceLocation::VT_SOURCE, source);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SourceLocationBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SourceLocationBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SourceLocation<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum BaseNodeOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct BaseNode<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BaseNode<'a> {
        type Inner = BaseNode<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> BaseNode<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BaseNode { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BaseNodeArgs<'args>,
        ) -> flatbuffers::WIPOffset<BaseNode<'bldr>> {
            let mut builder = BaseNodeBuilder::new(_fbb);
            if let Some(x) = args.errors {
                builder.add_errors(x);
            }
            if let Some(x) = args.loc {
                builder.add_loc(x);
            }
            builder.finish()
        }

        pub const VT_LOC: flatbuffers::VOffsetT = 4;
        pub const VT_ERRORS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn loc(&self) -> Option<SourceLocation<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(BaseNode::VT_LOC, None)
        }
        #[inline]
        pub fn errors(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
            >>(BaseNode::VT_ERRORS, None)
        }
    }

    pub struct BaseNodeArgs<'a> {
        pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a>>>,
        pub errors: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
    }
    impl<'a> Default for BaseNodeArgs<'a> {
        #[inline]
        fn default() -> Self {
            BaseNodeArgs {
                loc: None,
                errors: None,
            }
        }
    }
    pub struct BaseNodeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BaseNodeBuilder<'a, 'b> {
        #[inline]
        pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(BaseNode::VT_LOC, loc);
        }
        #[inline]
        pub fn add_errors(
            &mut self,
            errors: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BaseNode::VT_ERRORS, errors);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BaseNodeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BaseNodeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BaseNode<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum PackageOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Package<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Package<'a> {
        type Inner = Package<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Package<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Package { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PackageArgs<'args>,
        ) -> flatbuffers::WIPOffset<Package<'bldr>> {
            let mut builder = PackageBuilder::new(_fbb);
            if let Some(x) = args.files {
                builder.add_files(x);
            }
            if let Some(x) = args.package {
                builder.add_package(x);
            }
            if let Some(x) = args.path {
                builder.add_path(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_PATH: flatbuffers::VOffsetT = 6;
        pub const VT_PACKAGE: flatbuffers::VOffsetT = 8;
        pub const VT_FILES: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(Package::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn path(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Package::VT_PATH, None)
        }
        #[inline]
        pub fn package(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Package::VT_PACKAGE, None)
        }
        #[inline]
        pub fn files(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<File<'a>>>,
            >>(Package::VT_FILES, None)
        }
    }

    pub struct PackageArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub path: Option<flatbuffers::WIPOffset<&'a str>>,
        pub package: Option<flatbuffers::WIPOffset<&'a str>>,
        pub files: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File<'a>>>>,
        >,
    }
    impl<'a> Default for PackageArgs<'a> {
        #[inline]
        fn default() -> Self {
            PackageArgs {
                base_node: None,
                path: None,
                package: None,
                files: None,
            }
        }
    }
    pub struct PackageBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PackageBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    Package::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_PATH, path);
        }
        #[inline]
        pub fn add_package(&mut self, package: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_PACKAGE, package);
        }
        #[inline]
        pub fn add_files(
            &mut self,
            files: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<File<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_FILES, files);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PackageBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PackageBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Package<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FileOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct File<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for File<'a> {
        type Inner = File<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> File<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            File { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FileArgs<'args>,
        ) -> flatbuffers::WIPOffset<File<'bldr>> {
            let mut builder = FileBuilder::new(_fbb);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.imports {
                builder.add_imports(x);
            }
            if let Some(x) = args.package {
                builder.add_package(x);
            }
            if let Some(x) = args.metadata {
                builder.add_metadata(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;
        pub const VT_METADATA: flatbuffers::VOffsetT = 8;
        pub const VT_PACKAGE: flatbuffers::VOffsetT = 10;
        pub const VT_IMPORTS: flatbuffers::VOffsetT = 12;
        pub const VT_BODY: flatbuffers::VOffsetT = 14;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(File::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(File::VT_NAME, None)
        }
        #[inline]
        pub fn metadata(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(File::VT_METADATA, None)
        }
        #[inline]
        pub fn package(&self) -> Option<PackageClause<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<PackageClause<'a>>>(File::VT_PACKAGE, None)
        }
        #[inline]
        pub fn imports(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ImportDeclaration<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<ImportDeclaration<'a>>>,
            >>(File::VT_IMPORTS, None)
        }
        #[inline]
        pub fn body(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>,
            >>(File::VT_BODY, None)
        }
    }

    pub struct FileArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub metadata: Option<flatbuffers::WIPOffset<&'a str>>,
        pub package: Option<flatbuffers::WIPOffset<PackageClause<'a>>>,
        pub imports: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ImportDeclaration<'a>>>,
            >,
        >,
        pub body: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>,
            >,
        >,
    }
    impl<'a> Default for FileArgs<'a> {
        #[inline]
        fn default() -> Self {
            FileArgs {
                base_node: None,
                name: None,
                metadata: None,
                package: None,
                imports: None,
                body: None,
            }
        }
    }
    pub struct FileBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FileBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    File::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_NAME, name);
        }
        #[inline]
        pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_METADATA, metadata);
        }
        #[inline]
        pub fn add_package(&mut self, package: flatbuffers::WIPOffset<PackageClause<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<PackageClause>>(
                    File::VT_PACKAGE,
                    package,
                );
        }
        #[inline]
        pub fn add_imports(
            &mut self,
            imports: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ImportDeclaration<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_IMPORTS, imports);
        }
        #[inline]
        pub fn add_body(
            &mut self,
            body: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<WrappedStatement<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_BODY, body);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FileBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FileBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<File<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum PackageClauseOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct PackageClause<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PackageClause<'a> {
        type Inner = PackageClause<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> PackageClause<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PackageClause { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PackageClauseArgs<'args>,
        ) -> flatbuffers::WIPOffset<PackageClause<'bldr>> {
            let mut builder = PackageClauseBuilder::new(_fbb);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                PackageClause::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn name(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(PackageClause::VT_NAME, None)
        }
    }

    pub struct PackageClauseArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub name: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    }
    impl<'a> Default for PackageClauseArgs<'a> {
        #[inline]
        fn default() -> Self {
            PackageClauseArgs {
                base_node: None,
                name: None,
            }
        }
    }
    pub struct PackageClauseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PackageClauseBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    PackageClause::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    PackageClause::VT_NAME,
                    name,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> PackageClauseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PackageClauseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PackageClause<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ImportDeclarationOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct ImportDeclaration<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ImportDeclaration<'a> {
        type Inner = ImportDeclaration<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> ImportDeclaration<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ImportDeclaration { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ImportDeclarationArgs<'args>,
        ) -> flatbuffers::WIPOffset<ImportDeclaration<'bldr>> {
            let mut builder = ImportDeclarationBuilder::new(_fbb);
            if let Some(x) = args.path {
                builder.add_path(x);
            }
            if let Some(x) = args.as_ {
                builder.add_as_(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_AS_: flatbuffers::VOffsetT = 6;
        pub const VT_PATH: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                ImportDeclaration::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn as_(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(
                    ImportDeclaration::VT_AS_,
                    None,
                )
        }
        #[inline]
        pub fn path(&self) -> Option<StringLiteral<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<StringLiteral<'a>>>(
                    ImportDeclaration::VT_PATH,
                    None,
                )
        }
    }

    pub struct ImportDeclarationArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub as_: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub path: Option<flatbuffers::WIPOffset<StringLiteral<'a>>>,
    }
    impl<'a> Default for ImportDeclarationArgs<'a> {
        #[inline]
        fn default() -> Self {
            ImportDeclarationArgs {
                base_node: None,
                as_: None,
                path: None,
            }
        }
    }
    pub struct ImportDeclarationBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ImportDeclarationBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ImportDeclaration::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_as_(&mut self, as_: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    ImportDeclaration::VT_AS_,
                    as_,
                );
        }
        #[inline]
        pub fn add_path(&mut self, path: flatbuffers::WIPOffset<StringLiteral<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<StringLiteral>>(
                    ImportDeclaration::VT_PATH,
                    path,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ImportDeclarationBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ImportDeclarationBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ImportDeclaration<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum WrappedStatementOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct WrappedStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for WrappedStatement<'a> {
        type Inner = WrappedStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> WrappedStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            WrappedStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args WrappedStatementArgs,
        ) -> flatbuffers::WIPOffset<WrappedStatement<'bldr>> {
            let mut builder = WrappedStatementBuilder::new(_fbb);
            if let Some(x) = args.statement {
                builder.add_statement(x);
            }
            builder.add_statement_type(args.statement_type);
            builder.finish()
        }

        pub const VT_STATEMENT_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_STATEMENT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn statement_type(&self) -> Statement {
            self._tab
                .get::<Statement>(WrappedStatement::VT_STATEMENT_TYPE, Some(Statement::NONE))
                .unwrap()
        }
        #[inline]
        pub fn statement(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    WrappedStatement::VT_STATEMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_bad_statement(&self) -> Option<BadStatement<'a>> {
            if self.statement_type() == Statement::BadStatement {
                self.statement().map(|u| BadStatement::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_variable_assignment(&self) -> Option<VariableAssignment<'a>> {
            if self.statement_type() == Statement::VariableAssignment {
                self.statement()
                    .map(|u| VariableAssignment::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_member_assignment(&self) -> Option<MemberAssignment<'a>> {
            if self.statement_type() == Statement::MemberAssignment {
                self.statement()
                    .map(|u| MemberAssignment::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_expression_statement(&self) -> Option<ExpressionStatement<'a>> {
            if self.statement_type() == Statement::ExpressionStatement {
                self.statement()
                    .map(|u| ExpressionStatement::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_return_statement(&self) -> Option<ReturnStatement<'a>> {
            if self.statement_type() == Statement::ReturnStatement {
                self.statement()
                    .map(|u| ReturnStatement::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_option_statement(&self) -> Option<OptionStatement<'a>> {
            if self.statement_type() == Statement::OptionStatement {
                self.statement()
                    .map(|u| OptionStatement::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_builtin_statement(&self) -> Option<BuiltinStatement<'a>> {
            if self.statement_type() == Statement::BuiltinStatement {
                self.statement()
                    .map(|u| BuiltinStatement::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn statement_as_test_statement(&self) -> Option<TestStatement<'a>> {
            if self.statement_type() == Statement::TestStatement {
                self.statement().map(|u| TestStatement::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct WrappedStatementArgs {
        pub statement_type: Statement,
        pub statement: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for WrappedStatementArgs {
        #[inline]
        fn default() -> Self {
            WrappedStatementArgs {
                statement_type: Statement::NONE,
                statement: None,
            }
        }
    }
    pub struct WrappedStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> WrappedStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_statement_type(&mut self, statement_type: Statement) {
            self.fbb_.push_slot::<Statement>(
                WrappedStatement::VT_STATEMENT_TYPE,
                statement_type,
                Statement::NONE,
            );
        }
        #[inline]
        pub fn add_statement(
            &mut self,
            statement: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                WrappedStatement::VT_STATEMENT,
                statement,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> WrappedStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            WrappedStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<WrappedStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum BadStatementOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct BadStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BadStatement<'a> {
        type Inner = BadStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> BadStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BadStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BadStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<BadStatement<'bldr>> {
            let mut builder = BadStatementBuilder::new(_fbb);
            if let Some(x) = args.text {
                builder.add_text(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_TEXT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(BadStatement::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn text(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(BadStatement::VT_TEXT, None)
        }
    }

    pub struct BadStatementArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for BadStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            BadStatementArgs {
                base_node: None,
                text: None,
            }
        }
    }
    pub struct BadStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BadStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    BadStatement::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BadStatement::VT_TEXT, text);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BadStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BadStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BadStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum VariableAssignmentOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct VariableAssignment<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for VariableAssignment<'a> {
        type Inner = VariableAssignment<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> VariableAssignment<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            VariableAssignment { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args VariableAssignmentArgs<'args>,
        ) -> flatbuffers::WIPOffset<VariableAssignment<'bldr>> {
            let mut builder = VariableAssignmentBuilder::new(_fbb);
            if let Some(x) = args.init_ {
                builder.add_init_(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_init__type(args.init__type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;
        pub const VT_INIT__TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_INIT_: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                VariableAssignment::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn id(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(
                    VariableAssignment::VT_ID,
                    None,
                )
        }
        #[inline]
        pub fn init__type(&self) -> Expression {
            self._tab
                .get::<Expression>(VariableAssignment::VT_INIT__TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn init_(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    VariableAssignment::VT_INIT_,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.init__type() == Expression::StringExpression {
                self.init_().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.init__type() == Expression::ParenExpression {
                self.init_().map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.init__type() == Expression::ArrayExpression {
                self.init_().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.init__type() == Expression::FunctionExpression {
                self.init_().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.init__type() == Expression::BinaryExpression {
                self.init_().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.init__type() == Expression::BooleanLiteral {
                self.init_().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.init__type() == Expression::CallExpression {
                self.init_().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.init__type() == Expression::ConditionalExpression {
                self.init_()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.init__type() == Expression::DateTimeLiteral {
                self.init_().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.init__type() == Expression::DurationLiteral {
                self.init_().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.init__type() == Expression::FloatLiteral {
                self.init_().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_identifier(&self) -> Option<Identifier<'a>> {
            if self.init__type() == Expression::Identifier {
                self.init_().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.init__type() == Expression::IntegerLiteral {
                self.init_().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.init__type() == Expression::LogicalExpression {
                self.init_().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.init__type() == Expression::MemberExpression {
                self.init_().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.init__type() == Expression::IndexExpression {
                self.init_().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.init__type() == Expression::ObjectExpression {
                self.init_().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.init__type() == Expression::PipeExpression {
                self.init_().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.init__type() == Expression::PipeLiteral {
                self.init_().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.init__type() == Expression::RegexpLiteral {
                self.init_().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.init__type() == Expression::StringLiteral {
                self.init_().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.init__type() == Expression::UnaryExpression {
                self.init_().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.init__type() == Expression::UnsignedIntegerLiteral {
                self.init_()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.init__type() == Expression::BadExpression {
                self.init_().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct VariableAssignmentArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub init__type: Expression,
        pub init_: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for VariableAssignmentArgs<'a> {
        #[inline]
        fn default() -> Self {
            VariableAssignmentArgs {
                base_node: None,
                id: None,
                init__type: Expression::NONE,
                init_: None,
            }
        }
    }
    pub struct VariableAssignmentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> VariableAssignmentBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    VariableAssignment::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    VariableAssignment::VT_ID,
                    id,
                );
        }
        #[inline]
        pub fn add_init__type(&mut self, init__type: Expression) {
            self.fbb_.push_slot::<Expression>(
                VariableAssignment::VT_INIT__TYPE,
                init__type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_init_(&mut self, init_: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(VariableAssignment::VT_INIT_, init_);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> VariableAssignmentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            VariableAssignmentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<VariableAssignment<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum MemberAssignmentOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct MemberAssignment<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MemberAssignment<'a> {
        type Inner = MemberAssignment<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> MemberAssignment<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MemberAssignment { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MemberAssignmentArgs<'args>,
        ) -> flatbuffers::WIPOffset<MemberAssignment<'bldr>> {
            let mut builder = MemberAssignmentBuilder::new(_fbb);
            if let Some(x) = args.init_ {
                builder.add_init_(x);
            }
            if let Some(x) = args.member {
                builder.add_member(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_init__type(args.init__type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_MEMBER: flatbuffers::VOffsetT = 6;
        pub const VT_INIT__TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_INIT_: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                MemberAssignment::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn member(&self) -> Option<MemberExpression<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<MemberExpression<'a>>>(
                    MemberAssignment::VT_MEMBER,
                    None,
                )
        }
        #[inline]
        pub fn init__type(&self) -> Expression {
            self._tab
                .get::<Expression>(MemberAssignment::VT_INIT__TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn init_(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    MemberAssignment::VT_INIT_,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.init__type() == Expression::StringExpression {
                self.init_().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.init__type() == Expression::ParenExpression {
                self.init_().map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.init__type() == Expression::ArrayExpression {
                self.init_().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.init__type() == Expression::FunctionExpression {
                self.init_().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.init__type() == Expression::BinaryExpression {
                self.init_().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.init__type() == Expression::BooleanLiteral {
                self.init_().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.init__type() == Expression::CallExpression {
                self.init_().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.init__type() == Expression::ConditionalExpression {
                self.init_()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.init__type() == Expression::DateTimeLiteral {
                self.init_().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.init__type() == Expression::DurationLiteral {
                self.init_().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.init__type() == Expression::FloatLiteral {
                self.init_().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_identifier(&self) -> Option<Identifier<'a>> {
            if self.init__type() == Expression::Identifier {
                self.init_().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.init__type() == Expression::IntegerLiteral {
                self.init_().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.init__type() == Expression::LogicalExpression {
                self.init_().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.init__type() == Expression::MemberExpression {
                self.init_().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.init__type() == Expression::IndexExpression {
                self.init_().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.init__type() == Expression::ObjectExpression {
                self.init_().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.init__type() == Expression::PipeExpression {
                self.init_().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.init__type() == Expression::PipeLiteral {
                self.init_().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.init__type() == Expression::RegexpLiteral {
                self.init_().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.init__type() == Expression::StringLiteral {
                self.init_().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.init__type() == Expression::UnaryExpression {
                self.init_().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.init__type() == Expression::UnsignedIntegerLiteral {
                self.init_()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn init__as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.init__type() == Expression::BadExpression {
                self.init_().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct MemberAssignmentArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub member: Option<flatbuffers::WIPOffset<MemberExpression<'a>>>,
        pub init__type: Expression,
        pub init_: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for MemberAssignmentArgs<'a> {
        #[inline]
        fn default() -> Self {
            MemberAssignmentArgs {
                base_node: None,
                member: None,
                init__type: Expression::NONE,
                init_: None,
            }
        }
    }
    pub struct MemberAssignmentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MemberAssignmentBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    MemberAssignment::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_member(&mut self, member: flatbuffers::WIPOffset<MemberExpression<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<MemberExpression>>(
                    MemberAssignment::VT_MEMBER,
                    member,
                );
        }
        #[inline]
        pub fn add_init__type(&mut self, init__type: Expression) {
            self.fbb_.push_slot::<Expression>(
                MemberAssignment::VT_INIT__TYPE,
                init__type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_init_(&mut self, init_: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MemberAssignment::VT_INIT_, init_);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MemberAssignmentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MemberAssignmentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MemberAssignment<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ExpressionStatementOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct ExpressionStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ExpressionStatement<'a> {
        type Inner = ExpressionStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> ExpressionStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ExpressionStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ExpressionStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<ExpressionStatement<'bldr>> {
            let mut builder = ExpressionStatementBuilder::new(_fbb);
            if let Some(x) = args.expression {
                builder.add_expression(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_expression_type(args.expression_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_EXPRESSION_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_EXPRESSION: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                ExpressionStatement::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn expression_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    ExpressionStatement::VT_EXPRESSION_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn expression(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ExpressionStatement::VT_EXPRESSION,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.expression_type() == Expression::StringExpression {
                self.expression()
                    .map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.expression_type() == Expression::ParenExpression {
                self.expression()
                    .map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.expression_type() == Expression::ArrayExpression {
                self.expression()
                    .map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.expression_type() == Expression::FunctionExpression {
                self.expression()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.expression_type() == Expression::BinaryExpression {
                self.expression()
                    .map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.expression_type() == Expression::BooleanLiteral {
                self.expression()
                    .map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.expression_type() == Expression::CallExpression {
                self.expression()
                    .map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.expression_type() == Expression::ConditionalExpression {
                self.expression()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.expression_type() == Expression::DateTimeLiteral {
                self.expression()
                    .map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.expression_type() == Expression::DurationLiteral {
                self.expression()
                    .map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.expression_type() == Expression::FloatLiteral {
                self.expression().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.expression_type() == Expression::Identifier {
                self.expression().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.expression_type() == Expression::IntegerLiteral {
                self.expression()
                    .map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.expression_type() == Expression::LogicalExpression {
                self.expression()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.expression_type() == Expression::MemberExpression {
                self.expression()
                    .map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.expression_type() == Expression::IndexExpression {
                self.expression()
                    .map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.expression_type() == Expression::ObjectExpression {
                self.expression()
                    .map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.expression_type() == Expression::PipeExpression {
                self.expression()
                    .map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.expression_type() == Expression::PipeLiteral {
                self.expression().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.expression_type() == Expression::RegexpLiteral {
                self.expression().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.expression_type() == Expression::StringLiteral {
                self.expression().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.expression_type() == Expression::UnaryExpression {
                self.expression()
                    .map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.expression_type() == Expression::UnsignedIntegerLiteral {
                self.expression()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.expression_type() == Expression::BadExpression {
                self.expression().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct ExpressionStatementArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub expression_type: Expression,
        pub expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ExpressionStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            ExpressionStatementArgs {
                base_node: None,
                expression_type: Expression::NONE,
                expression: None,
            }
        }
    }
    pub struct ExpressionStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ExpressionStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ExpressionStatement::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_expression_type(&mut self, expression_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ExpressionStatement::VT_EXPRESSION_TYPE,
                expression_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_expression(
            &mut self,
            expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ExpressionStatement::VT_EXPRESSION,
                expression,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ExpressionStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ExpressionStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ExpressionStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ReturnStatementOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct ReturnStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ReturnStatement<'a> {
        type Inner = ReturnStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> ReturnStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ReturnStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ReturnStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<ReturnStatement<'bldr>> {
            let mut builder = ReturnStatementBuilder::new(_fbb);
            if let Some(x) = args.argument {
                builder.add_argument(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_argument_type(args.argument_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ARGUMENT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ARGUMENT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                ReturnStatement::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn argument_type(&self) -> Expression {
            self._tab
                .get::<Expression>(ReturnStatement::VT_ARGUMENT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn argument(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ReturnStatement::VT_ARGUMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.argument_type() == Expression::StringExpression {
                self.argument()
                    .map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.argument_type() == Expression::ParenExpression {
                self.argument().map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.argument_type() == Expression::ArrayExpression {
                self.argument().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.argument_type() == Expression::FunctionExpression {
                self.argument()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.argument_type() == Expression::BinaryExpression {
                self.argument()
                    .map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.argument_type() == Expression::BooleanLiteral {
                self.argument().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.argument_type() == Expression::CallExpression {
                self.argument().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.argument_type() == Expression::ConditionalExpression {
                self.argument()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.argument_type() == Expression::DateTimeLiteral {
                self.argument().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.argument_type() == Expression::DurationLiteral {
                self.argument().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.argument_type() == Expression::FloatLiteral {
                self.argument().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.argument_type() == Expression::Identifier {
                self.argument().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.argument_type() == Expression::IntegerLiteral {
                self.argument().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.argument_type() == Expression::LogicalExpression {
                self.argument()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.argument_type() == Expression::MemberExpression {
                self.argument()
                    .map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.argument_type() == Expression::IndexExpression {
                self.argument().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.argument_type() == Expression::ObjectExpression {
                self.argument()
                    .map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.argument_type() == Expression::PipeExpression {
                self.argument().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.argument_type() == Expression::PipeLiteral {
                self.argument().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.argument_type() == Expression::RegexpLiteral {
                self.argument().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.argument_type() == Expression::StringLiteral {
                self.argument().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.argument_type() == Expression::UnaryExpression {
                self.argument().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.argument_type() == Expression::UnsignedIntegerLiteral {
                self.argument()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.argument_type() == Expression::BadExpression {
                self.argument().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct ReturnStatementArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub argument_type: Expression,
        pub argument: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ReturnStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            ReturnStatementArgs {
                base_node: None,
                argument_type: Expression::NONE,
                argument: None,
            }
        }
    }
    pub struct ReturnStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ReturnStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ReturnStatement::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_argument_type(&mut self, argument_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ReturnStatement::VT_ARGUMENT_TYPE,
                argument_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_argument(
            &mut self,
            argument: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ReturnStatement::VT_ARGUMENT,
                argument,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ReturnStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ReturnStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ReturnStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum OptionStatementOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct OptionStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for OptionStatement<'a> {
        type Inner = OptionStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> OptionStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            OptionStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args OptionStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<OptionStatement<'bldr>> {
            let mut builder = OptionStatementBuilder::new(_fbb);
            if let Some(x) = args.assignment {
                builder.add_assignment(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_assignment_type(args.assignment_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ASSIGNMENT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ASSIGNMENT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                OptionStatement::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn assignment_type(&self) -> Assignment {
            self._tab
                .get::<Assignment>(OptionStatement::VT_ASSIGNMENT_TYPE, Some(Assignment::NONE))
                .unwrap()
        }
        #[inline]
        pub fn assignment(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    OptionStatement::VT_ASSIGNMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn assignment_as_member_assignment(&self) -> Option<MemberAssignment<'a>> {
            if self.assignment_type() == Assignment::MemberAssignment {
                self.assignment()
                    .map(|u| MemberAssignment::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn assignment_as_variable_assignment(&self) -> Option<VariableAssignment<'a>> {
            if self.assignment_type() == Assignment::VariableAssignment {
                self.assignment()
                    .map(|u| VariableAssignment::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct OptionStatementArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub assignment_type: Assignment,
        pub assignment: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for OptionStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            OptionStatementArgs {
                base_node: None,
                assignment_type: Assignment::NONE,
                assignment: None,
            }
        }
    }
    pub struct OptionStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> OptionStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    OptionStatement::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_assignment_type(&mut self, assignment_type: Assignment) {
            self.fbb_.push_slot::<Assignment>(
                OptionStatement::VT_ASSIGNMENT_TYPE,
                assignment_type,
                Assignment::NONE,
            );
        }
        #[inline]
        pub fn add_assignment(
            &mut self,
            assignment: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                OptionStatement::VT_ASSIGNMENT,
                assignment,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> OptionStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            OptionStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<OptionStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum BuiltinStatementOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct BuiltinStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BuiltinStatement<'a> {
        type Inner = BuiltinStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> BuiltinStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BuiltinStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BuiltinStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<BuiltinStatement<'bldr>> {
            let mut builder = BuiltinStatementBuilder::new(_fbb);
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                BuiltinStatement::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn id(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(BuiltinStatement::VT_ID, None)
        }
    }

    pub struct BuiltinStatementArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    }
    impl<'a> Default for BuiltinStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            BuiltinStatementArgs {
                base_node: None,
                id: None,
            }
        }
    }
    pub struct BuiltinStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BuiltinStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    BuiltinStatement::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    BuiltinStatement::VT_ID,
                    id,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BuiltinStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BuiltinStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BuiltinStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum TestStatementOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct TestStatement<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TestStatement<'a> {
        type Inner = TestStatement<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> TestStatement<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TestStatement { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TestStatementArgs<'args>,
        ) -> flatbuffers::WIPOffset<TestStatement<'bldr>> {
            let mut builder = TestStatementBuilder::new(_fbb);
            if let Some(x) = args.assignment {
                builder.add_assignment(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_assignment_type(args.assignment_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ASSIGNMENT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ASSIGNMENT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                TestStatement::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn assignment_type(&self) -> Assignment {
            self._tab
                .get::<Assignment>(TestStatement::VT_ASSIGNMENT_TYPE, Some(Assignment::NONE))
                .unwrap()
        }
        #[inline]
        pub fn assignment(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    TestStatement::VT_ASSIGNMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn assignment_as_member_assignment(&self) -> Option<MemberAssignment<'a>> {
            if self.assignment_type() == Assignment::MemberAssignment {
                self.assignment()
                    .map(|u| MemberAssignment::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn assignment_as_variable_assignment(&self) -> Option<VariableAssignment<'a>> {
            if self.assignment_type() == Assignment::VariableAssignment {
                self.assignment()
                    .map(|u| VariableAssignment::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct TestStatementArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub assignment_type: Assignment,
        pub assignment: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for TestStatementArgs<'a> {
        #[inline]
        fn default() -> Self {
            TestStatementArgs {
                base_node: None,
                assignment_type: Assignment::NONE,
                assignment: None,
            }
        }
    }
    pub struct TestStatementBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TestStatementBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    TestStatement::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_assignment_type(&mut self, assignment_type: Assignment) {
            self.fbb_.push_slot::<Assignment>(
                TestStatement::VT_ASSIGNMENT_TYPE,
                assignment_type,
                Assignment::NONE,
            );
        }
        #[inline]
        pub fn add_assignment(
            &mut self,
            assignment: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TestStatement::VT_ASSIGNMENT,
                assignment,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TestStatementBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TestStatementBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TestStatement<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum WrappedExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct WrappedExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for WrappedExpression<'a> {
        type Inner = WrappedExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> WrappedExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            WrappedExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args WrappedExpressionArgs,
        ) -> flatbuffers::WIPOffset<WrappedExpression<'bldr>> {
            let mut builder = WrappedExpressionBuilder::new(_fbb);
            if let Some(x) = args.expr {
                builder.add_expr(x);
            }
            builder.add_expr_type(args.expr_type);
            builder.finish()
        }

        pub const VT_EXPR_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_EXPR: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn expr_type(&self) -> Expression {
            self._tab
                .get::<Expression>(WrappedExpression::VT_EXPR_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn expr(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    WrappedExpression::VT_EXPR,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.expr_type() == Expression::StringExpression {
                self.expr().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.expr_type() == Expression::ParenExpression {
                self.expr().map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.expr_type() == Expression::ArrayExpression {
                self.expr().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.expr_type() == Expression::FunctionExpression {
                self.expr().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.expr_type() == Expression::BinaryExpression {
                self.expr().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.expr_type() == Expression::BooleanLiteral {
                self.expr().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.expr_type() == Expression::CallExpression {
                self.expr().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.expr_type() == Expression::ConditionalExpression {
                self.expr()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.expr_type() == Expression::DateTimeLiteral {
                self.expr().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.expr_type() == Expression::DurationLiteral {
                self.expr().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.expr_type() == Expression::FloatLiteral {
                self.expr().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.expr_type() == Expression::Identifier {
                self.expr().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.expr_type() == Expression::IntegerLiteral {
                self.expr().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.expr_type() == Expression::LogicalExpression {
                self.expr().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.expr_type() == Expression::MemberExpression {
                self.expr().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.expr_type() == Expression::IndexExpression {
                self.expr().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.expr_type() == Expression::ObjectExpression {
                self.expr().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.expr_type() == Expression::PipeExpression {
                self.expr().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.expr_type() == Expression::PipeLiteral {
                self.expr().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.expr_type() == Expression::RegexpLiteral {
                self.expr().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.expr_type() == Expression::StringLiteral {
                self.expr().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.expr_type() == Expression::UnaryExpression {
                self.expr().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.expr_type() == Expression::UnsignedIntegerLiteral {
                self.expr()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expr_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.expr_type() == Expression::BadExpression {
                self.expr().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct WrappedExpressionArgs {
        pub expr_type: Expression,
        pub expr: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for WrappedExpressionArgs {
        #[inline]
        fn default() -> Self {
            WrappedExpressionArgs {
                expr_type: Expression::NONE,
                expr: None,
            }
        }
    }
    pub struct WrappedExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> WrappedExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_expr_type(&mut self, expr_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                WrappedExpression::VT_EXPR_TYPE,
                expr_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_expr(&mut self, expr: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(WrappedExpression::VT_EXPR, expr);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> WrappedExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            WrappedExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<WrappedExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum BinaryExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct BinaryExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BinaryExpression<'a> {
        type Inner = BinaryExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> BinaryExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BinaryExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BinaryExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<BinaryExpression<'bldr>> {
            let mut builder = BinaryExpressionBuilder::new(_fbb);
            if let Some(x) = args.right {
                builder.add_right(x);
            }
            if let Some(x) = args.left {
                builder.add_left(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_right_type(args.right_type);
            builder.add_left_type(args.left_type);
            builder.add_operator(args.operator);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_OPERATOR: flatbuffers::VOffsetT = 6;
        pub const VT_LEFT_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_LEFT: flatbuffers::VOffsetT = 10;
        pub const VT_RIGHT_TYPE: flatbuffers::VOffsetT = 12;
        pub const VT_RIGHT: flatbuffers::VOffsetT = 14;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                BinaryExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn operator(&self) -> Operator {
            self._tab
                .get::<Operator>(
                    BinaryExpression::VT_OPERATOR,
                    Some(Operator::InvalidOperator),
                )
                .unwrap()
        }
        #[inline]
        pub fn left_type(&self) -> Expression {
            self._tab
                .get::<Expression>(BinaryExpression::VT_LEFT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn left(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    BinaryExpression::VT_LEFT,
                    None,
                )
        }
        #[inline]
        pub fn right_type(&self) -> Expression {
            self._tab
                .get::<Expression>(BinaryExpression::VT_RIGHT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn right(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    BinaryExpression::VT_RIGHT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.left_type() == Expression::StringExpression {
                self.left().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.left_type() == Expression::ParenExpression {
                self.left().map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.left_type() == Expression::ArrayExpression {
                self.left().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.left_type() == Expression::FunctionExpression {
                self.left().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.left_type() == Expression::BinaryExpression {
                self.left().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.left_type() == Expression::BooleanLiteral {
                self.left().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.left_type() == Expression::CallExpression {
                self.left().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.left_type() == Expression::ConditionalExpression {
                self.left()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.left_type() == Expression::DateTimeLiteral {
                self.left().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.left_type() == Expression::DurationLiteral {
                self.left().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.left_type() == Expression::FloatLiteral {
                self.left().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.left_type() == Expression::Identifier {
                self.left().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.left_type() == Expression::IntegerLiteral {
                self.left().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.left_type() == Expression::LogicalExpression {
                self.left().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.left_type() == Expression::MemberExpression {
                self.left().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.left_type() == Expression::IndexExpression {
                self.left().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.left_type() == Expression::ObjectExpression {
                self.left().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.left_type() == Expression::PipeExpression {
                self.left().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.left_type() == Expression::PipeLiteral {
                self.left().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.left_type() == Expression::RegexpLiteral {
                self.left().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.left_type() == Expression::StringLiteral {
                self.left().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.left_type() == Expression::UnaryExpression {
                self.left().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.left_type() == Expression::UnsignedIntegerLiteral {
                self.left()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.left_type() == Expression::BadExpression {
                self.left().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.right_type() == Expression::StringExpression {
                self.right().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.right_type() == Expression::ParenExpression {
                self.right().map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.right_type() == Expression::ArrayExpression {
                self.right().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.right_type() == Expression::FunctionExpression {
                self.right().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.right_type() == Expression::BinaryExpression {
                self.right().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.right_type() == Expression::BooleanLiteral {
                self.right().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.right_type() == Expression::CallExpression {
                self.right().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.right_type() == Expression::ConditionalExpression {
                self.right()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.right_type() == Expression::DateTimeLiteral {
                self.right().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.right_type() == Expression::DurationLiteral {
                self.right().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.right_type() == Expression::FloatLiteral {
                self.right().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.right_type() == Expression::Identifier {
                self.right().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.right_type() == Expression::IntegerLiteral {
                self.right().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.right_type() == Expression::LogicalExpression {
                self.right().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.right_type() == Expression::MemberExpression {
                self.right().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.right_type() == Expression::IndexExpression {
                self.right().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.right_type() == Expression::ObjectExpression {
                self.right().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.right_type() == Expression::PipeExpression {
                self.right().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.right_type() == Expression::PipeLiteral {
                self.right().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.right_type() == Expression::RegexpLiteral {
                self.right().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.right_type() == Expression::StringLiteral {
                self.right().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.right_type() == Expression::UnaryExpression {
                self.right().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.right_type() == Expression::UnsignedIntegerLiteral {
                self.right()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.right_type() == Expression::BadExpression {
                self.right().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct BinaryExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub operator: Operator,
        pub left_type: Expression,
        pub left: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub right_type: Expression,
        pub right: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for BinaryExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            BinaryExpressionArgs {
                base_node: None,
                operator: Operator::InvalidOperator,
                left_type: Expression::NONE,
                left: None,
                right_type: Expression::NONE,
                right: None,
            }
        }
    }
    pub struct BinaryExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BinaryExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    BinaryExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_operator(&mut self, operator: Operator) {
            self.fbb_.push_slot::<Operator>(
                BinaryExpression::VT_OPERATOR,
                operator,
                Operator::InvalidOperator,
            );
        }
        #[inline]
        pub fn add_left_type(&mut self, left_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                BinaryExpression::VT_LEFT_TYPE,
                left_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_left(&mut self, left: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryExpression::VT_LEFT, left);
        }
        #[inline]
        pub fn add_right_type(&mut self, right_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                BinaryExpression::VT_RIGHT_TYPE,
                right_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_right(&mut self, right: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryExpression::VT_RIGHT, right);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BinaryExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BinaryExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BinaryExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum LogicalExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct LogicalExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LogicalExpression<'a> {
        type Inner = LogicalExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> LogicalExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LogicalExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LogicalExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<LogicalExpression<'bldr>> {
            let mut builder = LogicalExpressionBuilder::new(_fbb);
            if let Some(x) = args.right {
                builder.add_right(x);
            }
            if let Some(x) = args.left {
                builder.add_left(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_right_type(args.right_type);
            builder.add_left_type(args.left_type);
            builder.add_operator(args.operator);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_OPERATOR: flatbuffers::VOffsetT = 6;
        pub const VT_LEFT_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_LEFT: flatbuffers::VOffsetT = 10;
        pub const VT_RIGHT_TYPE: flatbuffers::VOffsetT = 12;
        pub const VT_RIGHT: flatbuffers::VOffsetT = 14;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                LogicalExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn operator(&self) -> LogicalOperator {
            self._tab
                .get::<LogicalOperator>(
                    LogicalExpression::VT_OPERATOR,
                    Some(LogicalOperator::AndOperator),
                )
                .unwrap()
        }
        #[inline]
        pub fn left_type(&self) -> Expression {
            self._tab
                .get::<Expression>(LogicalExpression::VT_LEFT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn left(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    LogicalExpression::VT_LEFT,
                    None,
                )
        }
        #[inline]
        pub fn right_type(&self) -> Expression {
            self._tab
                .get::<Expression>(LogicalExpression::VT_RIGHT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn right(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    LogicalExpression::VT_RIGHT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.left_type() == Expression::StringExpression {
                self.left().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.left_type() == Expression::ParenExpression {
                self.left().map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.left_type() == Expression::ArrayExpression {
                self.left().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.left_type() == Expression::FunctionExpression {
                self.left().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.left_type() == Expression::BinaryExpression {
                self.left().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.left_type() == Expression::BooleanLiteral {
                self.left().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.left_type() == Expression::CallExpression {
                self.left().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.left_type() == Expression::ConditionalExpression {
                self.left()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.left_type() == Expression::DateTimeLiteral {
                self.left().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.left_type() == Expression::DurationLiteral {
                self.left().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.left_type() == Expression::FloatLiteral {
                self.left().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.left_type() == Expression::Identifier {
                self.left().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.left_type() == Expression::IntegerLiteral {
                self.left().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.left_type() == Expression::LogicalExpression {
                self.left().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.left_type() == Expression::MemberExpression {
                self.left().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.left_type() == Expression::IndexExpression {
                self.left().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.left_type() == Expression::ObjectExpression {
                self.left().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.left_type() == Expression::PipeExpression {
                self.left().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.left_type() == Expression::PipeLiteral {
                self.left().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.left_type() == Expression::RegexpLiteral {
                self.left().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.left_type() == Expression::StringLiteral {
                self.left().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.left_type() == Expression::UnaryExpression {
                self.left().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.left_type() == Expression::UnsignedIntegerLiteral {
                self.left()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn left_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.left_type() == Expression::BadExpression {
                self.left().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.right_type() == Expression::StringExpression {
                self.right().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.right_type() == Expression::ParenExpression {
                self.right().map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.right_type() == Expression::ArrayExpression {
                self.right().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.right_type() == Expression::FunctionExpression {
                self.right().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.right_type() == Expression::BinaryExpression {
                self.right().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.right_type() == Expression::BooleanLiteral {
                self.right().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.right_type() == Expression::CallExpression {
                self.right().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.right_type() == Expression::ConditionalExpression {
                self.right()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.right_type() == Expression::DateTimeLiteral {
                self.right().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.right_type() == Expression::DurationLiteral {
                self.right().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.right_type() == Expression::FloatLiteral {
                self.right().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.right_type() == Expression::Identifier {
                self.right().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.right_type() == Expression::IntegerLiteral {
                self.right().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.right_type() == Expression::LogicalExpression {
                self.right().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.right_type() == Expression::MemberExpression {
                self.right().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.right_type() == Expression::IndexExpression {
                self.right().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.right_type() == Expression::ObjectExpression {
                self.right().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.right_type() == Expression::PipeExpression {
                self.right().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.right_type() == Expression::PipeLiteral {
                self.right().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.right_type() == Expression::RegexpLiteral {
                self.right().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.right_type() == Expression::StringLiteral {
                self.right().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.right_type() == Expression::UnaryExpression {
                self.right().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.right_type() == Expression::UnsignedIntegerLiteral {
                self.right()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn right_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.right_type() == Expression::BadExpression {
                self.right().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct LogicalExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub operator: LogicalOperator,
        pub left_type: Expression,
        pub left: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub right_type: Expression,
        pub right: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for LogicalExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            LogicalExpressionArgs {
                base_node: None,
                operator: LogicalOperator::AndOperator,
                left_type: Expression::NONE,
                left: None,
                right_type: Expression::NONE,
                right: None,
            }
        }
    }
    pub struct LogicalExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LogicalExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    LogicalExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_operator(&mut self, operator: LogicalOperator) {
            self.fbb_.push_slot::<LogicalOperator>(
                LogicalExpression::VT_OPERATOR,
                operator,
                LogicalOperator::AndOperator,
            );
        }
        #[inline]
        pub fn add_left_type(&mut self, left_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                LogicalExpression::VT_LEFT_TYPE,
                left_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_left(&mut self, left: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(LogicalExpression::VT_LEFT, left);
        }
        #[inline]
        pub fn add_right_type(&mut self, right_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                LogicalExpression::VT_RIGHT_TYPE,
                right_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_right(&mut self, right: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(LogicalExpression::VT_RIGHT, right);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LogicalExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LogicalExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LogicalExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum UnaryExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct UnaryExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnaryExpression<'a> {
        type Inner = UnaryExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> UnaryExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnaryExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UnaryExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<UnaryExpression<'bldr>> {
            let mut builder = UnaryExpressionBuilder::new(_fbb);
            if let Some(x) = args.argument {
                builder.add_argument(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_argument_type(args.argument_type);
            builder.add_operator(args.operator);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_OPERATOR: flatbuffers::VOffsetT = 6;
        pub const VT_ARGUMENT_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_ARGUMENT: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                UnaryExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn operator(&self) -> Operator {
            self._tab
                .get::<Operator>(
                    UnaryExpression::VT_OPERATOR,
                    Some(Operator::InvalidOperator),
                )
                .unwrap()
        }
        #[inline]
        pub fn argument_type(&self) -> Expression {
            self._tab
                .get::<Expression>(UnaryExpression::VT_ARGUMENT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn argument(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    UnaryExpression::VT_ARGUMENT,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.argument_type() == Expression::StringExpression {
                self.argument()
                    .map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.argument_type() == Expression::ParenExpression {
                self.argument().map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.argument_type() == Expression::ArrayExpression {
                self.argument().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.argument_type() == Expression::FunctionExpression {
                self.argument()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.argument_type() == Expression::BinaryExpression {
                self.argument()
                    .map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.argument_type() == Expression::BooleanLiteral {
                self.argument().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.argument_type() == Expression::CallExpression {
                self.argument().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.argument_type() == Expression::ConditionalExpression {
                self.argument()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.argument_type() == Expression::DateTimeLiteral {
                self.argument().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.argument_type() == Expression::DurationLiteral {
                self.argument().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.argument_type() == Expression::FloatLiteral {
                self.argument().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.argument_type() == Expression::Identifier {
                self.argument().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.argument_type() == Expression::IntegerLiteral {
                self.argument().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.argument_type() == Expression::LogicalExpression {
                self.argument()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.argument_type() == Expression::MemberExpression {
                self.argument()
                    .map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.argument_type() == Expression::IndexExpression {
                self.argument().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.argument_type() == Expression::ObjectExpression {
                self.argument()
                    .map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.argument_type() == Expression::PipeExpression {
                self.argument().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.argument_type() == Expression::PipeLiteral {
                self.argument().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.argument_type() == Expression::RegexpLiteral {
                self.argument().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.argument_type() == Expression::StringLiteral {
                self.argument().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.argument_type() == Expression::UnaryExpression {
                self.argument().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.argument_type() == Expression::UnsignedIntegerLiteral {
                self.argument()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.argument_type() == Expression::BadExpression {
                self.argument().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct UnaryExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub operator: Operator,
        pub argument_type: Expression,
        pub argument: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for UnaryExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            UnaryExpressionArgs {
                base_node: None,
                operator: Operator::InvalidOperator,
                argument_type: Expression::NONE,
                argument: None,
            }
        }
    }
    pub struct UnaryExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UnaryExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    UnaryExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_operator(&mut self, operator: Operator) {
            self.fbb_.push_slot::<Operator>(
                UnaryExpression::VT_OPERATOR,
                operator,
                Operator::InvalidOperator,
            );
        }
        #[inline]
        pub fn add_argument_type(&mut self, argument_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                UnaryExpression::VT_ARGUMENT_TYPE,
                argument_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_argument(
            &mut self,
            argument: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UnaryExpression::VT_ARGUMENT,
                argument,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UnaryExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UnaryExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnaryExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum BooleanLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct BooleanLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BooleanLiteral<'a> {
        type Inner = BooleanLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> BooleanLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BooleanLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BooleanLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<BooleanLiteral<'bldr>> {
            let mut builder = BooleanLiteralBuilder::new(_fbb);
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_value(args.value);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                BooleanLiteral::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn value(&self) -> bool {
            self._tab
                .get::<bool>(BooleanLiteral::VT_VALUE, Some(false))
                .unwrap()
        }
    }

    pub struct BooleanLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub value: bool,
    }
    impl<'a> Default for BooleanLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            BooleanLiteralArgs {
                base_node: None,
                value: false,
            }
        }
    }
    pub struct BooleanLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BooleanLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    BooleanLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: bool) {
            self.fbb_
                .push_slot::<bool>(BooleanLiteral::VT_VALUE, value, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BooleanLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BooleanLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BooleanLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum DateTimeLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct DateTimeLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DateTimeLiteral<'a> {
        type Inner = DateTimeLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> DateTimeLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DateTimeLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DateTimeLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<DateTimeLiteral<'bldr>> {
            let mut builder = DateTimeLiteralBuilder::new(_fbb);
            builder.add_secs(args.secs);
            builder.add_offset(args.offset);
            builder.add_nsecs(args.nsecs);
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_SECS: flatbuffers::VOffsetT = 6;
        pub const VT_NSECS: flatbuffers::VOffsetT = 8;
        pub const VT_OFFSET: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                DateTimeLiteral::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn secs(&self) -> i64 {
            self._tab
                .get::<i64>(DateTimeLiteral::VT_SECS, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn nsecs(&self) -> u32 {
            self._tab
                .get::<u32>(DateTimeLiteral::VT_NSECS, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn offset(&self) -> i32 {
            self._tab
                .get::<i32>(DateTimeLiteral::VT_OFFSET, Some(0))
                .unwrap()
        }
    }

    pub struct DateTimeLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub secs: i64,
        pub nsecs: u32,
        pub offset: i32,
    }
    impl<'a> Default for DateTimeLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            DateTimeLiteralArgs {
                base_node: None,
                secs: 0,
                nsecs: 0,
                offset: 0,
            }
        }
    }
    pub struct DateTimeLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DateTimeLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    DateTimeLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_secs(&mut self, secs: i64) {
            self.fbb_
                .push_slot::<i64>(DateTimeLiteral::VT_SECS, secs, 0);
        }
        #[inline]
        pub fn add_nsecs(&mut self, nsecs: u32) {
            self.fbb_
                .push_slot::<u32>(DateTimeLiteral::VT_NSECS, nsecs, 0);
        }
        #[inline]
        pub fn add_offset(&mut self, offset: i32) {
            self.fbb_
                .push_slot::<i32>(DateTimeLiteral::VT_OFFSET, offset, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DateTimeLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DateTimeLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DateTimeLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum DurationLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct DurationLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DurationLiteral<'a> {
        type Inner = DurationLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> DurationLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DurationLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DurationLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<DurationLiteral<'bldr>> {
            let mut builder = DurationLiteralBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_VALUES: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                DurationLiteral::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Duration<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<Duration<'a>>>,
            >>(DurationLiteral::VT_VALUES, None)
        }
    }

    pub struct DurationLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Duration<'a>>>,
            >,
        >,
    }
    impl<'a> Default for DurationLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            DurationLiteralArgs {
                base_node: None,
                values: None,
            }
        }
    }
    pub struct DurationLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DurationLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    DurationLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Duration<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DurationLiteral::VT_VALUES, values);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DurationLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DurationLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DurationLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum DurationOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Duration<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Duration<'a> {
        type Inner = Duration<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Duration<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Duration { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DurationArgs,
        ) -> flatbuffers::WIPOffset<Duration<'bldr>> {
            let mut builder = DurationBuilder::new(_fbb);
            builder.add_magnitude(args.magnitude);
            builder.add_unit(args.unit);
            builder.finish()
        }

        pub const VT_MAGNITUDE: flatbuffers::VOffsetT = 4;
        pub const VT_UNIT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn magnitude(&self) -> i64 {
            self._tab
                .get::<i64>(Duration::VT_MAGNITUDE, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn unit(&self) -> TimeUnit {
            self._tab
                .get::<TimeUnit>(Duration::VT_UNIT, Some(TimeUnit::y))
                .unwrap()
        }
    }

    pub struct DurationArgs {
        pub magnitude: i64,
        pub unit: TimeUnit,
    }
    impl<'a> Default for DurationArgs {
        #[inline]
        fn default() -> Self {
            DurationArgs {
                magnitude: 0,
                unit: TimeUnit::y,
            }
        }
    }
    pub struct DurationBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DurationBuilder<'a, 'b> {
        #[inline]
        pub fn add_magnitude(&mut self, magnitude: i64) {
            self.fbb_
                .push_slot::<i64>(Duration::VT_MAGNITUDE, magnitude, 0);
        }
        #[inline]
        pub fn add_unit(&mut self, unit: TimeUnit) {
            self.fbb_
                .push_slot::<TimeUnit>(Duration::VT_UNIT, unit, TimeUnit::y);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DurationBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DurationBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Duration<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FloatLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct FloatLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FloatLiteral<'a> {
        type Inner = FloatLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> FloatLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FloatLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FloatLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<FloatLiteral<'bldr>> {
            let mut builder = FloatLiteralBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(FloatLiteral::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn value(&self) -> f64 {
            self._tab
                .get::<f64>(FloatLiteral::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }

    pub struct FloatLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub value: f64,
    }
    impl<'a> Default for FloatLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            FloatLiteralArgs {
                base_node: None,
                value: 0.0,
            }
        }
    }
    pub struct FloatLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FloatLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    FloatLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: f64) {
            self.fbb_
                .push_slot::<f64>(FloatLiteral::VT_VALUE, value, 0.0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FloatLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FloatLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FloatLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum IntegerLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct IntegerLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for IntegerLiteral<'a> {
        type Inner = IntegerLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> IntegerLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            IntegerLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IntegerLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<IntegerLiteral<'bldr>> {
            let mut builder = IntegerLiteralBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                IntegerLiteral::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn value(&self) -> i64 {
            self._tab
                .get::<i64>(IntegerLiteral::VT_VALUE, Some(0))
                .unwrap()
        }
    }

    pub struct IntegerLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub value: i64,
    }
    impl<'a> Default for IntegerLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            IntegerLiteralArgs {
                base_node: None,
                value: 0,
            }
        }
    }
    pub struct IntegerLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IntegerLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    IntegerLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: i64) {
            self.fbb_
                .push_slot::<i64>(IntegerLiteral::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> IntegerLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IntegerLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<IntegerLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum PipeLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct PipeLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PipeLiteral<'a> {
        type Inner = PipeLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> PipeLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PipeLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PipeLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<PipeLiteral<'bldr>> {
            let mut builder = PipeLiteralBuilder::new(_fbb);
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(PipeLiteral::VT_BASE_NODE, None)
        }
    }

    pub struct PipeLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
    }
    impl<'a> Default for PipeLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            PipeLiteralArgs { base_node: None }
        }
    }
    pub struct PipeLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PipeLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    PipeLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PipeLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PipeLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PipeLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum RegexpLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct RegexpLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RegexpLiteral<'a> {
        type Inner = RegexpLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> RegexpLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RegexpLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RegexpLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<RegexpLiteral<'bldr>> {
            let mut builder = RegexpLiteralBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                RegexpLiteral::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn value(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(RegexpLiteral::VT_VALUE, None)
        }
    }

    pub struct RegexpLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for RegexpLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            RegexpLiteralArgs {
                base_node: None,
                value: None,
            }
        }
    }
    pub struct RegexpLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RegexpLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    RegexpLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(RegexpLiteral::VT_VALUE, value);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> RegexpLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RegexpLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RegexpLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum StringLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct StringLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StringLiteral<'a> {
        type Inner = StringLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> StringLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StringLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StringLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<StringLiteral<'bldr>> {
            let mut builder = StringLiteralBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                StringLiteral::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn value(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(StringLiteral::VT_VALUE, None)
        }
    }

    pub struct StringLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for StringLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            StringLiteralArgs {
                base_node: None,
                value: None,
            }
        }
    }
    pub struct StringLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StringLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    StringLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(StringLiteral::VT_VALUE, value);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> StringLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StringLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StringLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum UnsignedIntegerLiteralOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct UnsignedIntegerLiteral<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnsignedIntegerLiteral<'a> {
        type Inner = UnsignedIntegerLiteral<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> UnsignedIntegerLiteral<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnsignedIntegerLiteral { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UnsignedIntegerLiteralArgs<'args>,
        ) -> flatbuffers::WIPOffset<UnsignedIntegerLiteral<'bldr>> {
            let mut builder = UnsignedIntegerLiteralBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                UnsignedIntegerLiteral::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn value(&self) -> u64 {
            self._tab
                .get::<u64>(UnsignedIntegerLiteral::VT_VALUE, Some(0))
                .unwrap()
        }
    }

    pub struct UnsignedIntegerLiteralArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub value: u64,
    }
    impl<'a> Default for UnsignedIntegerLiteralArgs<'a> {
        #[inline]
        fn default() -> Self {
            UnsignedIntegerLiteralArgs {
                base_node: None,
                value: 0,
            }
        }
    }
    pub struct UnsignedIntegerLiteralBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UnsignedIntegerLiteralBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    UnsignedIntegerLiteral::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_
                .push_slot::<u64>(UnsignedIntegerLiteral::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UnsignedIntegerLiteralBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UnsignedIntegerLiteralBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnsignedIntegerLiteral<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum IdentifierOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Identifier<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Identifier<'a> {
        type Inner = Identifier<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Identifier<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Identifier { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IdentifierArgs<'args>,
        ) -> flatbuffers::WIPOffset<Identifier<'bldr>> {
            let mut builder = IdentifierBuilder::new(_fbb);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(Identifier::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Identifier::VT_NAME, None)
        }
    }

    pub struct IdentifierArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for IdentifierArgs<'a> {
        #[inline]
        fn default() -> Self {
            IdentifierArgs {
                base_node: None,
                name: None,
            }
        }
    }
    pub struct IdentifierBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IdentifierBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    Identifier::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Identifier::VT_NAME, name);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IdentifierBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IdentifierBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Identifier<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum StringExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct StringExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StringExpression<'a> {
        type Inner = StringExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> StringExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StringExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StringExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<StringExpression<'bldr>> {
            let mut builder = StringExpressionBuilder::new(_fbb);
            if let Some(x) = args.parts {
                builder.add_parts(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_PARTS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                StringExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn parts(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringExpressionPart<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<StringExpressionPart<'a>>>,
            >>(StringExpression::VT_PARTS, None)
        }
    }

    pub struct StringExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub parts: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringExpressionPart<'a>>>,
            >,
        >,
    }
    impl<'a> Default for StringExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            StringExpressionArgs {
                base_node: None,
                parts: None,
            }
        }
    }
    pub struct StringExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StringExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    StringExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_parts(
            &mut self,
            parts: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<StringExpressionPart<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(StringExpression::VT_PARTS, parts);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> StringExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StringExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StringExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum StringExpressionPartOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct StringExpressionPart<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StringExpressionPart<'a> {
        type Inner = StringExpressionPart<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> StringExpressionPart<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StringExpressionPart { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StringExpressionPartArgs<'args>,
        ) -> flatbuffers::WIPOffset<StringExpressionPart<'bldr>> {
            let mut builder = StringExpressionPartBuilder::new(_fbb);
            if let Some(x) = args.interpolated_expression {
                builder.add_interpolated_expression(x);
            }
            if let Some(x) = args.text_value {
                builder.add_text_value(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_interpolated_expression_type(args.interpolated_expression_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_TEXT_VALUE: flatbuffers::VOffsetT = 6;
        pub const VT_INTERPOLATED_EXPRESSION_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_INTERPOLATED_EXPRESSION: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                StringExpressionPart::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn text_value(&self) -> Option<&'a str> {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                StringExpressionPart::VT_TEXT_VALUE,
                None,
            )
        }
        #[inline]
        pub fn interpolated_expression_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    StringExpressionPart::VT_INTERPOLATED_EXPRESSION_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn interpolated_expression(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    StringExpressionPart::VT_INTERPOLATED_EXPRESSION,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.interpolated_expression_type() == Expression::StringExpression {
                self.interpolated_expression()
                    .map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.interpolated_expression_type() == Expression::ParenExpression {
                self.interpolated_expression()
                    .map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.interpolated_expression_type() == Expression::ArrayExpression {
                self.interpolated_expression()
                    .map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_function_expression(
            &self,
        ) -> Option<FunctionExpression<'a>> {
            if self.interpolated_expression_type() == Expression::FunctionExpression {
                self.interpolated_expression()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.interpolated_expression_type() == Expression::BinaryExpression {
                self.interpolated_expression()
                    .map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::BooleanLiteral {
                self.interpolated_expression()
                    .map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.interpolated_expression_type() == Expression::CallExpression {
                self.interpolated_expression()
                    .map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_conditional_expression(
            &self,
        ) -> Option<ConditionalExpression<'a>> {
            if self.interpolated_expression_type() == Expression::ConditionalExpression {
                self.interpolated_expression()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::DateTimeLiteral {
                self.interpolated_expression()
                    .map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::DurationLiteral {
                self.interpolated_expression()
                    .map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::FloatLiteral {
                self.interpolated_expression()
                    .map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.interpolated_expression_type() == Expression::Identifier {
                self.interpolated_expression()
                    .map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::IntegerLiteral {
                self.interpolated_expression()
                    .map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_logical_expression(
            &self,
        ) -> Option<LogicalExpression<'a>> {
            if self.interpolated_expression_type() == Expression::LogicalExpression {
                self.interpolated_expression()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.interpolated_expression_type() == Expression::MemberExpression {
                self.interpolated_expression()
                    .map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.interpolated_expression_type() == Expression::IndexExpression {
                self.interpolated_expression()
                    .map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.interpolated_expression_type() == Expression::ObjectExpression {
                self.interpolated_expression()
                    .map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.interpolated_expression_type() == Expression::PipeExpression {
                self.interpolated_expression()
                    .map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::PipeLiteral {
                self.interpolated_expression()
                    .map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::RegexpLiteral {
                self.interpolated_expression()
                    .map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::StringLiteral {
                self.interpolated_expression()
                    .map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.interpolated_expression_type() == Expression::UnaryExpression {
                self.interpolated_expression()
                    .map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_unsigned_integer_literal(
            &self,
        ) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.interpolated_expression_type() == Expression::UnsignedIntegerLiteral {
                self.interpolated_expression()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn interpolated_expression_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.interpolated_expression_type() == Expression::BadExpression {
                self.interpolated_expression()
                    .map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct StringExpressionPartArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub text_value: Option<flatbuffers::WIPOffset<&'a str>>,
        pub interpolated_expression_type: Expression,
        pub interpolated_expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for StringExpressionPartArgs<'a> {
        #[inline]
        fn default() -> Self {
            StringExpressionPartArgs {
                base_node: None,
                text_value: None,
                interpolated_expression_type: Expression::NONE,
                interpolated_expression: None,
            }
        }
    }
    pub struct StringExpressionPartBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StringExpressionPartBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    StringExpressionPart::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_text_value(&mut self, text_value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                StringExpressionPart::VT_TEXT_VALUE,
                text_value,
            );
        }
        #[inline]
        pub fn add_interpolated_expression_type(
            &mut self,
            interpolated_expression_type: Expression,
        ) {
            self.fbb_.push_slot::<Expression>(
                StringExpressionPart::VT_INTERPOLATED_EXPRESSION_TYPE,
                interpolated_expression_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_interpolated_expression(
            &mut self,
            interpolated_expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                StringExpressionPart::VT_INTERPOLATED_EXPRESSION,
                interpolated_expression,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> StringExpressionPartBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StringExpressionPartBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StringExpressionPart<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ParenExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct ParenExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ParenExpression<'a> {
        type Inner = ParenExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> ParenExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ParenExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ParenExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<ParenExpression<'bldr>> {
            let mut builder = ParenExpressionBuilder::new(_fbb);
            if let Some(x) = args.expression {
                builder.add_expression(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_expression_type(args.expression_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_EXPRESSION_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_EXPRESSION: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                ParenExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn expression_type(&self) -> Expression {
            self._tab
                .get::<Expression>(ParenExpression::VT_EXPRESSION_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn expression(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ParenExpression::VT_EXPRESSION,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.expression_type() == Expression::StringExpression {
                self.expression()
                    .map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.expression_type() == Expression::ParenExpression {
                self.expression()
                    .map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.expression_type() == Expression::ArrayExpression {
                self.expression()
                    .map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.expression_type() == Expression::FunctionExpression {
                self.expression()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.expression_type() == Expression::BinaryExpression {
                self.expression()
                    .map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.expression_type() == Expression::BooleanLiteral {
                self.expression()
                    .map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.expression_type() == Expression::CallExpression {
                self.expression()
                    .map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.expression_type() == Expression::ConditionalExpression {
                self.expression()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.expression_type() == Expression::DateTimeLiteral {
                self.expression()
                    .map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.expression_type() == Expression::DurationLiteral {
                self.expression()
                    .map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.expression_type() == Expression::FloatLiteral {
                self.expression().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.expression_type() == Expression::Identifier {
                self.expression().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.expression_type() == Expression::IntegerLiteral {
                self.expression()
                    .map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.expression_type() == Expression::LogicalExpression {
                self.expression()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.expression_type() == Expression::MemberExpression {
                self.expression()
                    .map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.expression_type() == Expression::IndexExpression {
                self.expression()
                    .map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.expression_type() == Expression::ObjectExpression {
                self.expression()
                    .map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.expression_type() == Expression::PipeExpression {
                self.expression()
                    .map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.expression_type() == Expression::PipeLiteral {
                self.expression().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.expression_type() == Expression::RegexpLiteral {
                self.expression().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.expression_type() == Expression::StringLiteral {
                self.expression().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.expression_type() == Expression::UnaryExpression {
                self.expression()
                    .map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.expression_type() == Expression::UnsignedIntegerLiteral {
                self.expression()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.expression_type() == Expression::BadExpression {
                self.expression().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct ParenExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub expression_type: Expression,
        pub expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ParenExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            ParenExpressionArgs {
                base_node: None,
                expression_type: Expression::NONE,
                expression: None,
            }
        }
    }
    pub struct ParenExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ParenExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ParenExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_expression_type(&mut self, expression_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ParenExpression::VT_EXPRESSION_TYPE,
                expression_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_expression(
            &mut self,
            expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ParenExpression::VT_EXPRESSION,
                expression,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ParenExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ParenExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ParenExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ArrayExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct ArrayExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ArrayExpression<'a> {
        type Inner = ArrayExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> ArrayExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ArrayExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ArrayExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<ArrayExpression<'bldr>> {
            let mut builder = ArrayExpressionBuilder::new(_fbb);
            if let Some(x) = args.elements {
                builder.add_elements(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ELEMENTS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                ArrayExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn elements(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedExpression<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<WrappedExpression<'a>>>,
            >>(ArrayExpression::VT_ELEMENTS, None)
        }
    }

    pub struct ArrayExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub elements: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedExpression<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ArrayExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            ArrayExpressionArgs {
                base_node: None,
                elements: None,
            }
        }
    }
    pub struct ArrayExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ArrayExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ArrayExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_elements(
            &mut self,
            elements: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<WrappedExpression<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ArrayExpression::VT_ELEMENTS,
                elements,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ArrayExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ArrayExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ArrayExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FunctionExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct FunctionExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FunctionExpression<'a> {
        type Inner = FunctionExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> FunctionExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FunctionExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FunctionExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<FunctionExpression<'bldr>> {
            let mut builder = FunctionExpressionBuilder::new(_fbb);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.params {
                builder.add_params(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_body_type(args.body_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_PARAMS: flatbuffers::VOffsetT = 6;
        pub const VT_BODY_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_BODY: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                FunctionExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn params(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<Property<'a>>>,
            >>(FunctionExpression::VT_PARAMS, None)
        }
        #[inline]
        pub fn body_type(&self) -> ExpressionOrBlock {
            self._tab
                .get::<ExpressionOrBlock>(
                    FunctionExpression::VT_BODY_TYPE,
                    Some(ExpressionOrBlock::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn body(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    FunctionExpression::VT_BODY,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_block(&self) -> Option<Block<'a>> {
            if self.body_type() == ExpressionOrBlock::Block {
                self.body().map(|u| Block::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_wrapped_expression(&self) -> Option<WrappedExpression<'a>> {
            if self.body_type() == ExpressionOrBlock::WrappedExpression {
                self.body().map(|u| WrappedExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct FunctionExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub params: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>,
            >,
        >,
        pub body_type: ExpressionOrBlock,
        pub body: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for FunctionExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            FunctionExpressionArgs {
                base_node: None,
                params: None,
                body_type: ExpressionOrBlock::NONE,
                body: None,
            }
        }
    }
    pub struct FunctionExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FunctionExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    FunctionExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_params(
            &mut self,
            params: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Property<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                FunctionExpression::VT_PARAMS,
                params,
            );
        }
        #[inline]
        pub fn add_body_type(&mut self, body_type: ExpressionOrBlock) {
            self.fbb_.push_slot::<ExpressionOrBlock>(
                FunctionExpression::VT_BODY_TYPE,
                body_type,
                ExpressionOrBlock::NONE,
            );
        }
        #[inline]
        pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionExpression::VT_BODY, body);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FunctionExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FunctionExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FunctionExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum BlockOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Block<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Block<'a> {
        type Inner = Block<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Block<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Block { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BlockArgs<'args>,
        ) -> flatbuffers::WIPOffset<Block<'bldr>> {
            let mut builder = BlockBuilder::new(_fbb);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_BODY: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(Block::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn body(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>,
            >>(Block::VT_BODY, None)
        }
    }

    pub struct BlockArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub body: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>,
            >,
        >,
    }
    impl<'a> Default for BlockArgs<'a> {
        #[inline]
        fn default() -> Self {
            BlockArgs {
                base_node: None,
                body: None,
            }
        }
    }
    pub struct BlockBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BlockBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    Block::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_body(
            &mut self,
            body: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<WrappedStatement<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_BODY, body);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BlockBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Block<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum CallExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct CallExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CallExpression<'a> {
        type Inner = CallExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> CallExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CallExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CallExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<CallExpression<'bldr>> {
            let mut builder = CallExpressionBuilder::new(_fbb);
            if let Some(x) = args.arguments {
                builder.add_arguments(x);
            }
            if let Some(x) = args.callee {
                builder.add_callee(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_callee_type(args.callee_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_CALLEE_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_CALLEE: flatbuffers::VOffsetT = 8;
        pub const VT_ARGUMENTS: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                CallExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn callee_type(&self) -> Expression {
            self._tab
                .get::<Expression>(CallExpression::VT_CALLEE_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn callee(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    CallExpression::VT_CALLEE,
                    None,
                )
        }
        #[inline]
        pub fn arguments(&self) -> Option<ObjectExpression<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<ObjectExpression<'a>>>(
                    CallExpression::VT_ARGUMENTS,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.callee_type() == Expression::StringExpression {
                self.callee().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.callee_type() == Expression::ParenExpression {
                self.callee().map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.callee_type() == Expression::ArrayExpression {
                self.callee().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.callee_type() == Expression::FunctionExpression {
                self.callee()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.callee_type() == Expression::BinaryExpression {
                self.callee().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.callee_type() == Expression::BooleanLiteral {
                self.callee().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.callee_type() == Expression::CallExpression {
                self.callee().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.callee_type() == Expression::ConditionalExpression {
                self.callee()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.callee_type() == Expression::DateTimeLiteral {
                self.callee().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.callee_type() == Expression::DurationLiteral {
                self.callee().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.callee_type() == Expression::FloatLiteral {
                self.callee().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.callee_type() == Expression::Identifier {
                self.callee().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.callee_type() == Expression::IntegerLiteral {
                self.callee().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.callee_type() == Expression::LogicalExpression {
                self.callee().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.callee_type() == Expression::MemberExpression {
                self.callee().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.callee_type() == Expression::IndexExpression {
                self.callee().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.callee_type() == Expression::ObjectExpression {
                self.callee().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.callee_type() == Expression::PipeExpression {
                self.callee().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.callee_type() == Expression::PipeLiteral {
                self.callee().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.callee_type() == Expression::RegexpLiteral {
                self.callee().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.callee_type() == Expression::StringLiteral {
                self.callee().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.callee_type() == Expression::UnaryExpression {
                self.callee().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.callee_type() == Expression::UnsignedIntegerLiteral {
                self.callee()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn callee_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.callee_type() == Expression::BadExpression {
                self.callee().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct CallExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub callee_type: Expression,
        pub callee: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub arguments: Option<flatbuffers::WIPOffset<ObjectExpression<'a>>>,
    }
    impl<'a> Default for CallExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            CallExpressionArgs {
                base_node: None,
                callee_type: Expression::NONE,
                callee: None,
                arguments: None,
            }
        }
    }
    pub struct CallExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CallExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    CallExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_callee_type(&mut self, callee_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                CallExpression::VT_CALLEE_TYPE,
                callee_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_callee(&mut self, callee: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CallExpression::VT_CALLEE, callee);
        }
        #[inline]
        pub fn add_arguments(&mut self, arguments: flatbuffers::WIPOffset<ObjectExpression<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<ObjectExpression>>(
                    CallExpression::VT_ARGUMENTS,
                    arguments,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CallExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CallExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CallExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ConditionalExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct ConditionalExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ConditionalExpression<'a> {
        type Inner = ConditionalExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> ConditionalExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ConditionalExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ConditionalExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<ConditionalExpression<'bldr>> {
            let mut builder = ConditionalExpressionBuilder::new(_fbb);
            if let Some(x) = args.alternate {
                builder.add_alternate(x);
            }
            if let Some(x) = args.consequent {
                builder.add_consequent(x);
            }
            if let Some(x) = args.test {
                builder.add_test(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_alternate_type(args.alternate_type);
            builder.add_consequent_type(args.consequent_type);
            builder.add_test_type(args.test_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_TEST_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_TEST: flatbuffers::VOffsetT = 8;
        pub const VT_CONSEQUENT_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_CONSEQUENT: flatbuffers::VOffsetT = 12;
        pub const VT_ALTERNATE_TYPE: flatbuffers::VOffsetT = 14;
        pub const VT_ALTERNATE: flatbuffers::VOffsetT = 16;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                ConditionalExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn test_type(&self) -> Expression {
            self._tab
                .get::<Expression>(ConditionalExpression::VT_TEST_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn test(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConditionalExpression::VT_TEST,
                    None,
                )
        }
        #[inline]
        pub fn consequent_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    ConditionalExpression::VT_CONSEQUENT_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn consequent(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConditionalExpression::VT_CONSEQUENT,
                    None,
                )
        }
        #[inline]
        pub fn alternate_type(&self) -> Expression {
            self._tab
                .get::<Expression>(
                    ConditionalExpression::VT_ALTERNATE_TYPE,
                    Some(Expression::NONE),
                )
                .unwrap()
        }
        #[inline]
        pub fn alternate(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConditionalExpression::VT_ALTERNATE,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.test_type() == Expression::StringExpression {
                self.test().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.test_type() == Expression::ParenExpression {
                self.test().map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.test_type() == Expression::ArrayExpression {
                self.test().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.test_type() == Expression::FunctionExpression {
                self.test().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.test_type() == Expression::BinaryExpression {
                self.test().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.test_type() == Expression::BooleanLiteral {
                self.test().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.test_type() == Expression::CallExpression {
                self.test().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.test_type() == Expression::ConditionalExpression {
                self.test()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.test_type() == Expression::DateTimeLiteral {
                self.test().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.test_type() == Expression::DurationLiteral {
                self.test().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.test_type() == Expression::FloatLiteral {
                self.test().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.test_type() == Expression::Identifier {
                self.test().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.test_type() == Expression::IntegerLiteral {
                self.test().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.test_type() == Expression::LogicalExpression {
                self.test().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.test_type() == Expression::MemberExpression {
                self.test().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.test_type() == Expression::IndexExpression {
                self.test().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.test_type() == Expression::ObjectExpression {
                self.test().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.test_type() == Expression::PipeExpression {
                self.test().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.test_type() == Expression::PipeLiteral {
                self.test().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.test_type() == Expression::RegexpLiteral {
                self.test().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.test_type() == Expression::StringLiteral {
                self.test().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.test_type() == Expression::UnaryExpression {
                self.test().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.test_type() == Expression::UnsignedIntegerLiteral {
                self.test()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn test_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.test_type() == Expression::BadExpression {
                self.test().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.consequent_type() == Expression::StringExpression {
                self.consequent()
                    .map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.consequent_type() == Expression::ParenExpression {
                self.consequent()
                    .map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.consequent_type() == Expression::ArrayExpression {
                self.consequent()
                    .map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.consequent_type() == Expression::FunctionExpression {
                self.consequent()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.consequent_type() == Expression::BinaryExpression {
                self.consequent()
                    .map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.consequent_type() == Expression::BooleanLiteral {
                self.consequent()
                    .map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.consequent_type() == Expression::CallExpression {
                self.consequent()
                    .map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.consequent_type() == Expression::ConditionalExpression {
                self.consequent()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.consequent_type() == Expression::DateTimeLiteral {
                self.consequent()
                    .map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.consequent_type() == Expression::DurationLiteral {
                self.consequent()
                    .map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.consequent_type() == Expression::FloatLiteral {
                self.consequent().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.consequent_type() == Expression::Identifier {
                self.consequent().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.consequent_type() == Expression::IntegerLiteral {
                self.consequent()
                    .map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.consequent_type() == Expression::LogicalExpression {
                self.consequent()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.consequent_type() == Expression::MemberExpression {
                self.consequent()
                    .map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.consequent_type() == Expression::IndexExpression {
                self.consequent()
                    .map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.consequent_type() == Expression::ObjectExpression {
                self.consequent()
                    .map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.consequent_type() == Expression::PipeExpression {
                self.consequent()
                    .map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.consequent_type() == Expression::PipeLiteral {
                self.consequent().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.consequent_type() == Expression::RegexpLiteral {
                self.consequent().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.consequent_type() == Expression::StringLiteral {
                self.consequent().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.consequent_type() == Expression::UnaryExpression {
                self.consequent()
                    .map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.consequent_type() == Expression::UnsignedIntegerLiteral {
                self.consequent()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn consequent_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.consequent_type() == Expression::BadExpression {
                self.consequent().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.alternate_type() == Expression::StringExpression {
                self.alternate()
                    .map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.alternate_type() == Expression::ParenExpression {
                self.alternate()
                    .map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.alternate_type() == Expression::ArrayExpression {
                self.alternate()
                    .map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.alternate_type() == Expression::FunctionExpression {
                self.alternate()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.alternate_type() == Expression::BinaryExpression {
                self.alternate()
                    .map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.alternate_type() == Expression::BooleanLiteral {
                self.alternate().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.alternate_type() == Expression::CallExpression {
                self.alternate().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.alternate_type() == Expression::ConditionalExpression {
                self.alternate()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.alternate_type() == Expression::DateTimeLiteral {
                self.alternate()
                    .map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.alternate_type() == Expression::DurationLiteral {
                self.alternate()
                    .map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.alternate_type() == Expression::FloatLiteral {
                self.alternate().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.alternate_type() == Expression::Identifier {
                self.alternate().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.alternate_type() == Expression::IntegerLiteral {
                self.alternate().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.alternate_type() == Expression::LogicalExpression {
                self.alternate()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.alternate_type() == Expression::MemberExpression {
                self.alternate()
                    .map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.alternate_type() == Expression::IndexExpression {
                self.alternate()
                    .map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.alternate_type() == Expression::ObjectExpression {
                self.alternate()
                    .map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.alternate_type() == Expression::PipeExpression {
                self.alternate().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.alternate_type() == Expression::PipeLiteral {
                self.alternate().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.alternate_type() == Expression::RegexpLiteral {
                self.alternate().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.alternate_type() == Expression::StringLiteral {
                self.alternate().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.alternate_type() == Expression::UnaryExpression {
                self.alternate()
                    .map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.alternate_type() == Expression::UnsignedIntegerLiteral {
                self.alternate()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn alternate_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.alternate_type() == Expression::BadExpression {
                self.alternate().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct ConditionalExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub test_type: Expression,
        pub test: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub consequent_type: Expression,
        pub consequent: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub alternate_type: Expression,
        pub alternate: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ConditionalExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            ConditionalExpressionArgs {
                base_node: None,
                test_type: Expression::NONE,
                test: None,
                consequent_type: Expression::NONE,
                consequent: None,
                alternate_type: Expression::NONE,
                alternate: None,
            }
        }
    }
    pub struct ConditionalExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ConditionalExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ConditionalExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_test_type(&mut self, test_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ConditionalExpression::VT_TEST_TYPE,
                test_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_test(&mut self, test: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ConditionalExpression::VT_TEST,
                test,
            );
        }
        #[inline]
        pub fn add_consequent_type(&mut self, consequent_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ConditionalExpression::VT_CONSEQUENT_TYPE,
                consequent_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_consequent(
            &mut self,
            consequent: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ConditionalExpression::VT_CONSEQUENT,
                consequent,
            );
        }
        #[inline]
        pub fn add_alternate_type(&mut self, alternate_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                ConditionalExpression::VT_ALTERNATE_TYPE,
                alternate_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_alternate(
            &mut self,
            alternate: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ConditionalExpression::VT_ALTERNATE,
                alternate,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ConditionalExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ConditionalExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ConditionalExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum PropertyOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Property<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Property<'a> {
        type Inner = Property<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Property<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Property { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PropertyArgs<'args>,
        ) -> flatbuffers::WIPOffset<Property<'bldr>> {
            let mut builder = PropertyBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_value_type(args.value_type);
            builder.add_key_type(args.key_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_KEY_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_KEY: flatbuffers::VOffsetT = 8;
        pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_VALUE: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(Property::VT_BASE_NODE, None)
        }
        #[inline]
        pub fn key_type(&self) -> PropertyKey {
            self._tab
                .get::<PropertyKey>(Property::VT_KEY_TYPE, Some(PropertyKey::NONE))
                .unwrap()
        }
        #[inline]
        pub fn key(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Property::VT_KEY, None)
        }
        #[inline]
        pub fn value_type(&self) -> Expression {
            self._tab
                .get::<Expression>(Property::VT_VALUE_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    Property::VT_VALUE,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.key_type() == PropertyKey::Identifier {
                self.key().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn key_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.key_type() == PropertyKey::StringLiteral {
                self.key().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.value_type() == Expression::StringExpression {
                self.value().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.value_type() == Expression::ParenExpression {
                self.value().map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.value_type() == Expression::ArrayExpression {
                self.value().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.value_type() == Expression::FunctionExpression {
                self.value().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.value_type() == Expression::BinaryExpression {
                self.value().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.value_type() == Expression::BooleanLiteral {
                self.value().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.value_type() == Expression::CallExpression {
                self.value().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.value_type() == Expression::ConditionalExpression {
                self.value()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.value_type() == Expression::DateTimeLiteral {
                self.value().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.value_type() == Expression::DurationLiteral {
                self.value().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.value_type() == Expression::FloatLiteral {
                self.value().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.value_type() == Expression::Identifier {
                self.value().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.value_type() == Expression::IntegerLiteral {
                self.value().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.value_type() == Expression::LogicalExpression {
                self.value().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.value_type() == Expression::MemberExpression {
                self.value().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.value_type() == Expression::IndexExpression {
                self.value().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.value_type() == Expression::ObjectExpression {
                self.value().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.value_type() == Expression::PipeExpression {
                self.value().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.value_type() == Expression::PipeLiteral {
                self.value().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.value_type() == Expression::RegexpLiteral {
                self.value().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.value_type() == Expression::StringLiteral {
                self.value().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.value_type() == Expression::UnaryExpression {
                self.value().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.value_type() == Expression::UnsignedIntegerLiteral {
                self.value()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.value_type() == Expression::BadExpression {
                self.value().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct PropertyArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub key_type: PropertyKey,
        pub key: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub value_type: Expression,
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for PropertyArgs<'a> {
        #[inline]
        fn default() -> Self {
            PropertyArgs {
                base_node: None,
                key_type: PropertyKey::NONE,
                key: None,
                value_type: Expression::NONE,
                value: None,
            }
        }
    }
    pub struct PropertyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PropertyBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    Property::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_key_type(&mut self, key_type: PropertyKey) {
            self.fbb_
                .push_slot::<PropertyKey>(Property::VT_KEY_TYPE, key_type, PropertyKey::NONE);
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Property::VT_KEY, key);
        }
        #[inline]
        pub fn add_value_type(&mut self, value_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                Property::VT_VALUE_TYPE,
                value_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Property::VT_VALUE, value);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PropertyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PropertyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Property<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum MemberExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct MemberExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MemberExpression<'a> {
        type Inner = MemberExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> MemberExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MemberExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MemberExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<MemberExpression<'bldr>> {
            let mut builder = MemberExpressionBuilder::new(_fbb);
            if let Some(x) = args.property {
                builder.add_property(x);
            }
            if let Some(x) = args.object {
                builder.add_object(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_property_type(args.property_type);
            builder.add_object_type(args.object_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_OBJECT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_OBJECT: flatbuffers::VOffsetT = 8;
        pub const VT_PROPERTY_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_PROPERTY: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                MemberExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn object_type(&self) -> Expression {
            self._tab
                .get::<Expression>(MemberExpression::VT_OBJECT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn object(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    MemberExpression::VT_OBJECT,
                    None,
                )
        }
        #[inline]
        pub fn property_type(&self) -> PropertyKey {
            self._tab
                .get::<PropertyKey>(MemberExpression::VT_PROPERTY_TYPE, Some(PropertyKey::NONE))
                .unwrap()
        }
        #[inline]
        pub fn property(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    MemberExpression::VT_PROPERTY,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.object_type() == Expression::StringExpression {
                self.object().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.object_type() == Expression::ParenExpression {
                self.object().map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.object_type() == Expression::ArrayExpression {
                self.object().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.object_type() == Expression::FunctionExpression {
                self.object()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.object_type() == Expression::BinaryExpression {
                self.object().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.object_type() == Expression::BooleanLiteral {
                self.object().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.object_type() == Expression::CallExpression {
                self.object().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.object_type() == Expression::ConditionalExpression {
                self.object()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.object_type() == Expression::DateTimeLiteral {
                self.object().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.object_type() == Expression::DurationLiteral {
                self.object().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.object_type() == Expression::FloatLiteral {
                self.object().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.object_type() == Expression::Identifier {
                self.object().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.object_type() == Expression::IntegerLiteral {
                self.object().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.object_type() == Expression::LogicalExpression {
                self.object().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.object_type() == Expression::MemberExpression {
                self.object().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.object_type() == Expression::IndexExpression {
                self.object().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.object_type() == Expression::ObjectExpression {
                self.object().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.object_type() == Expression::PipeExpression {
                self.object().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.object_type() == Expression::PipeLiteral {
                self.object().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.object_type() == Expression::RegexpLiteral {
                self.object().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.object_type() == Expression::StringLiteral {
                self.object().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.object_type() == Expression::UnaryExpression {
                self.object().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.object_type() == Expression::UnsignedIntegerLiteral {
                self.object()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn object_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.object_type() == Expression::BadExpression {
                self.object().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn property_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.property_type() == PropertyKey::Identifier {
                self.property().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn property_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.property_type() == PropertyKey::StringLiteral {
                self.property().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct MemberExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub object_type: Expression,
        pub object: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub property_type: PropertyKey,
        pub property: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for MemberExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            MemberExpressionArgs {
                base_node: None,
                object_type: Expression::NONE,
                object: None,
                property_type: PropertyKey::NONE,
                property: None,
            }
        }
    }
    pub struct MemberExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MemberExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    MemberExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_object_type(&mut self, object_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                MemberExpression::VT_OBJECT_TYPE,
                object_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_object(&mut self, object: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MemberExpression::VT_OBJECT, object);
        }
        #[inline]
        pub fn add_property_type(&mut self, property_type: PropertyKey) {
            self.fbb_.push_slot::<PropertyKey>(
                MemberExpression::VT_PROPERTY_TYPE,
                property_type,
                PropertyKey::NONE,
            );
        }
        #[inline]
        pub fn add_property(
            &mut self,
            property: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MemberExpression::VT_PROPERTY,
                property,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MemberExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MemberExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MemberExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum IndexExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct IndexExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for IndexExpression<'a> {
        type Inner = IndexExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> IndexExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            IndexExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IndexExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<IndexExpression<'bldr>> {
            let mut builder = IndexExpressionBuilder::new(_fbb);
            if let Some(x) = args.index {
                builder.add_index(x);
            }
            if let Some(x) = args.array {
                builder.add_array(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_index_type(args.index_type);
            builder.add_array_type(args.array_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ARRAY_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ARRAY: flatbuffers::VOffsetT = 8;
        pub const VT_INDEX_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_INDEX: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                IndexExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn array_type(&self) -> Expression {
            self._tab
                .get::<Expression>(IndexExpression::VT_ARRAY_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn array(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    IndexExpression::VT_ARRAY,
                    None,
                )
        }
        #[inline]
        pub fn index_type(&self) -> Expression {
            self._tab
                .get::<Expression>(IndexExpression::VT_INDEX_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn index(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    IndexExpression::VT_INDEX,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.array_type() == Expression::StringExpression {
                self.array().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.array_type() == Expression::ParenExpression {
                self.array().map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.array_type() == Expression::ArrayExpression {
                self.array().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.array_type() == Expression::FunctionExpression {
                self.array().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.array_type() == Expression::BinaryExpression {
                self.array().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.array_type() == Expression::BooleanLiteral {
                self.array().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.array_type() == Expression::CallExpression {
                self.array().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.array_type() == Expression::ConditionalExpression {
                self.array()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.array_type() == Expression::DateTimeLiteral {
                self.array().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.array_type() == Expression::DurationLiteral {
                self.array().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.array_type() == Expression::FloatLiteral {
                self.array().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.array_type() == Expression::Identifier {
                self.array().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.array_type() == Expression::IntegerLiteral {
                self.array().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.array_type() == Expression::LogicalExpression {
                self.array().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.array_type() == Expression::MemberExpression {
                self.array().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.array_type() == Expression::IndexExpression {
                self.array().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.array_type() == Expression::ObjectExpression {
                self.array().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.array_type() == Expression::PipeExpression {
                self.array().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.array_type() == Expression::PipeLiteral {
                self.array().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.array_type() == Expression::RegexpLiteral {
                self.array().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.array_type() == Expression::StringLiteral {
                self.array().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.array_type() == Expression::UnaryExpression {
                self.array().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.array_type() == Expression::UnsignedIntegerLiteral {
                self.array()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.array_type() == Expression::BadExpression {
                self.array().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.index_type() == Expression::StringExpression {
                self.index().map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.index_type() == Expression::ParenExpression {
                self.index().map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.index_type() == Expression::ArrayExpression {
                self.index().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.index_type() == Expression::FunctionExpression {
                self.index().map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.index_type() == Expression::BinaryExpression {
                self.index().map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.index_type() == Expression::BooleanLiteral {
                self.index().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.index_type() == Expression::CallExpression {
                self.index().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.index_type() == Expression::ConditionalExpression {
                self.index()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.index_type() == Expression::DateTimeLiteral {
                self.index().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.index_type() == Expression::DurationLiteral {
                self.index().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.index_type() == Expression::FloatLiteral {
                self.index().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.index_type() == Expression::Identifier {
                self.index().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.index_type() == Expression::IntegerLiteral {
                self.index().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.index_type() == Expression::LogicalExpression {
                self.index().map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.index_type() == Expression::MemberExpression {
                self.index().map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.index_type() == Expression::IndexExpression {
                self.index().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.index_type() == Expression::ObjectExpression {
                self.index().map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.index_type() == Expression::PipeExpression {
                self.index().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.index_type() == Expression::PipeLiteral {
                self.index().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.index_type() == Expression::RegexpLiteral {
                self.index().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.index_type() == Expression::StringLiteral {
                self.index().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.index_type() == Expression::UnaryExpression {
                self.index().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.index_type() == Expression::UnsignedIntegerLiteral {
                self.index()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn index_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.index_type() == Expression::BadExpression {
                self.index().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct IndexExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub array_type: Expression,
        pub array: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub index_type: Expression,
        pub index: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for IndexExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            IndexExpressionArgs {
                base_node: None,
                array_type: Expression::NONE,
                array: None,
                index_type: Expression::NONE,
                index: None,
            }
        }
    }
    pub struct IndexExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IndexExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    IndexExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_array_type(&mut self, array_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                IndexExpression::VT_ARRAY_TYPE,
                array_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_array(&mut self, array: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IndexExpression::VT_ARRAY, array);
        }
        #[inline]
        pub fn add_index_type(&mut self, index_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                IndexExpression::VT_INDEX_TYPE,
                index_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_index(&mut self, index: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IndexExpression::VT_INDEX, index);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> IndexExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IndexExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<IndexExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ObjectExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct ObjectExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ObjectExpression<'a> {
        type Inner = ObjectExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> ObjectExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ObjectExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ObjectExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<ObjectExpression<'bldr>> {
            let mut builder = ObjectExpressionBuilder::new(_fbb);
            if let Some(x) = args.properties {
                builder.add_properties(x);
            }
            if let Some(x) = args.with {
                builder.add_with(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_WITH: flatbuffers::VOffsetT = 6;
        pub const VT_PROPERTIES: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                ObjectExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn with(&self) -> Option<Identifier<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(
                    ObjectExpression::VT_WITH,
                    None,
                )
        }
        #[inline]
        pub fn properties(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<Property<'a>>>,
            >>(ObjectExpression::VT_PROPERTIES, None)
        }
    }

    pub struct ObjectExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub with: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
        pub properties: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ObjectExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            ObjectExpressionArgs {
                base_node: None,
                with: None,
                properties: None,
            }
        }
    }
    pub struct ObjectExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ObjectExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    ObjectExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_with(&mut self, with: flatbuffers::WIPOffset<Identifier<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Identifier>>(
                    ObjectExpression::VT_WITH,
                    with,
                );
        }
        #[inline]
        pub fn add_properties(
            &mut self,
            properties: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Property<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ObjectExpression::VT_PROPERTIES,
                properties,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ObjectExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ObjectExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ObjectExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum PipeExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct PipeExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PipeExpression<'a> {
        type Inner = PipeExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> PipeExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PipeExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PipeExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<PipeExpression<'bldr>> {
            let mut builder = PipeExpressionBuilder::new(_fbb);
            if let Some(x) = args.call {
                builder.add_call(x);
            }
            if let Some(x) = args.argument {
                builder.add_argument(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_argument_type(args.argument_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_ARGUMENT_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_ARGUMENT: flatbuffers::VOffsetT = 8;
        pub const VT_CALL: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                PipeExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn argument_type(&self) -> Expression {
            self._tab
                .get::<Expression>(PipeExpression::VT_ARGUMENT_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn argument(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    PipeExpression::VT_ARGUMENT,
                    None,
                )
        }
        #[inline]
        pub fn call(&self) -> Option<CallExpression<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<CallExpression<'a>>>(
                    PipeExpression::VT_CALL,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.argument_type() == Expression::StringExpression {
                self.argument()
                    .map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.argument_type() == Expression::ParenExpression {
                self.argument().map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.argument_type() == Expression::ArrayExpression {
                self.argument().map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.argument_type() == Expression::FunctionExpression {
                self.argument()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.argument_type() == Expression::BinaryExpression {
                self.argument()
                    .map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.argument_type() == Expression::BooleanLiteral {
                self.argument().map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.argument_type() == Expression::CallExpression {
                self.argument().map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.argument_type() == Expression::ConditionalExpression {
                self.argument()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.argument_type() == Expression::DateTimeLiteral {
                self.argument().map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.argument_type() == Expression::DurationLiteral {
                self.argument().map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.argument_type() == Expression::FloatLiteral {
                self.argument().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.argument_type() == Expression::Identifier {
                self.argument().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.argument_type() == Expression::IntegerLiteral {
                self.argument().map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.argument_type() == Expression::LogicalExpression {
                self.argument()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.argument_type() == Expression::MemberExpression {
                self.argument()
                    .map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.argument_type() == Expression::IndexExpression {
                self.argument().map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.argument_type() == Expression::ObjectExpression {
                self.argument()
                    .map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.argument_type() == Expression::PipeExpression {
                self.argument().map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.argument_type() == Expression::PipeLiteral {
                self.argument().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.argument_type() == Expression::RegexpLiteral {
                self.argument().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.argument_type() == Expression::StringLiteral {
                self.argument().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.argument_type() == Expression::UnaryExpression {
                self.argument().map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.argument_type() == Expression::UnsignedIntegerLiteral {
                self.argument()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn argument_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.argument_type() == Expression::BadExpression {
                self.argument().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct PipeExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub argument_type: Expression,
        pub argument: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub call: Option<flatbuffers::WIPOffset<CallExpression<'a>>>,
    }
    impl<'a> Default for PipeExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            PipeExpressionArgs {
                base_node: None,
                argument_type: Expression::NONE,
                argument: None,
                call: None,
            }
        }
    }
    pub struct PipeExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PipeExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    PipeExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_argument_type(&mut self, argument_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                PipeExpression::VT_ARGUMENT_TYPE,
                argument_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_argument(
            &mut self,
            argument: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                PipeExpression::VT_ARGUMENT,
                argument,
            );
        }
        #[inline]
        pub fn add_call(&mut self, call: flatbuffers::WIPOffset<CallExpression<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<CallExpression>>(
                    PipeExpression::VT_CALL,
                    call,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> PipeExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PipeExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PipeExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum BadExpressionOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct BadExpression<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BadExpression<'a> {
        type Inner = BadExpression<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> BadExpression<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BadExpression { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BadExpressionArgs<'args>,
        ) -> flatbuffers::WIPOffset<BadExpression<'bldr>> {
            let mut builder = BadExpressionBuilder::new(_fbb);
            if let Some(x) = args.expression {
                builder.add_expression(x);
            }
            if let Some(x) = args.text {
                builder.add_text(x);
            }
            if let Some(x) = args.base_node {
                builder.add_base_node(x);
            }
            builder.add_expression_type(args.expression_type);
            builder.finish()
        }

        pub const VT_BASE_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_TEXT: flatbuffers::VOffsetT = 6;
        pub const VT_EXPRESSION_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_EXPRESSION: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn base_node(&self) -> Option<BaseNode<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<BaseNode<'a>>>(
                BadExpression::VT_BASE_NODE,
                None,
            )
        }
        #[inline]
        pub fn text(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(BadExpression::VT_TEXT, None)
        }
        #[inline]
        pub fn expression_type(&self) -> Expression {
            self._tab
                .get::<Expression>(BadExpression::VT_EXPRESSION_TYPE, Some(Expression::NONE))
                .unwrap()
        }
        #[inline]
        pub fn expression(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    BadExpression::VT_EXPRESSION,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
            if self.expression_type() == Expression::StringExpression {
                self.expression()
                    .map(|u| StringExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_paren_expression(&self) -> Option<ParenExpression<'a>> {
            if self.expression_type() == Expression::ParenExpression {
                self.expression()
                    .map(|u| ParenExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
            if self.expression_type() == Expression::ArrayExpression {
                self.expression()
                    .map(|u| ArrayExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
            if self.expression_type() == Expression::FunctionExpression {
                self.expression()
                    .map(|u| FunctionExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
            if self.expression_type() == Expression::BinaryExpression {
                self.expression()
                    .map(|u| BinaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
            if self.expression_type() == Expression::BooleanLiteral {
                self.expression()
                    .map(|u| BooleanLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
            if self.expression_type() == Expression::CallExpression {
                self.expression()
                    .map(|u| CallExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
            if self.expression_type() == Expression::ConditionalExpression {
                self.expression()
                    .map(|u| ConditionalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
            if self.expression_type() == Expression::DateTimeLiteral {
                self.expression()
                    .map(|u| DateTimeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
            if self.expression_type() == Expression::DurationLiteral {
                self.expression()
                    .map(|u| DurationLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
            if self.expression_type() == Expression::FloatLiteral {
                self.expression().map(|u| FloatLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_identifier(&self) -> Option<Identifier<'a>> {
            if self.expression_type() == Expression::Identifier {
                self.expression().map(|u| Identifier::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
            if self.expression_type() == Expression::IntegerLiteral {
                self.expression()
                    .map(|u| IntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
            if self.expression_type() == Expression::LogicalExpression {
                self.expression()
                    .map(|u| LogicalExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
            if self.expression_type() == Expression::MemberExpression {
                self.expression()
                    .map(|u| MemberExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
            if self.expression_type() == Expression::IndexExpression {
                self.expression()
                    .map(|u| IndexExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
            if self.expression_type() == Expression::ObjectExpression {
                self.expression()
                    .map(|u| ObjectExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_pipe_expression(&self) -> Option<PipeExpression<'a>> {
            if self.expression_type() == Expression::PipeExpression {
                self.expression()
                    .map(|u| PipeExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_pipe_literal(&self) -> Option<PipeLiteral<'a>> {
            if self.expression_type() == Expression::PipeLiteral {
                self.expression().map(|u| PipeLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
            if self.expression_type() == Expression::RegexpLiteral {
                self.expression().map(|u| RegexpLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
            if self.expression_type() == Expression::StringLiteral {
                self.expression().map(|u| StringLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
            if self.expression_type() == Expression::UnaryExpression {
                self.expression()
                    .map(|u| UnaryExpression::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
            if self.expression_type() == Expression::UnsignedIntegerLiteral {
                self.expression()
                    .map(|u| UnsignedIntegerLiteral::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn expression_as_bad_expression(&self) -> Option<BadExpression<'a>> {
            if self.expression_type() == Expression::BadExpression {
                self.expression().map(|u| BadExpression::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct BadExpressionArgs<'a> {
        pub base_node: Option<flatbuffers::WIPOffset<BaseNode<'a>>>,
        pub text: Option<flatbuffers::WIPOffset<&'a str>>,
        pub expression_type: Expression,
        pub expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for BadExpressionArgs<'a> {
        #[inline]
        fn default() -> Self {
            BadExpressionArgs {
                base_node: None,
                text: None,
                expression_type: Expression::NONE,
                expression: None,
            }
        }
    }
    pub struct BadExpressionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BadExpressionBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_node(&mut self, base_node: flatbuffers::WIPOffset<BaseNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BaseNode>>(
                    BadExpression::VT_BASE_NODE,
                    base_node,
                );
        }
        #[inline]
        pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BadExpression::VT_TEXT, text);
        }
        #[inline]
        pub fn add_expression_type(&mut self, expression_type: Expression) {
            self.fbb_.push_slot::<Expression>(
                BadExpression::VT_EXPRESSION_TYPE,
                expression_type,
                Expression::NONE,
            );
        }
        #[inline]
        pub fn add_expression(
            &mut self,
            expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BadExpression::VT_EXPRESSION,
                expression,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BadExpressionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BadExpressionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BadExpression<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    #[inline]
    pub fn get_root_as_package<'a>(buf: &'a [u8]) -> Package<'a> {
        flatbuffers::get_root::<Package<'a>>(buf)
    }

    #[inline]
    pub fn get_size_prefixed_root_as_package<'a>(buf: &'a [u8]) -> Package<'a> {
        flatbuffers::get_size_prefixed_root::<Package<'a>>(buf)
    }

    #[inline]
    pub fn finish_package_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Package<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_package_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Package<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod fbast

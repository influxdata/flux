// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod fbsemantic {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Statement {
  NONE = 0,
  OptionStatement = 1,
  BuiltinStatement = 2,
  TestStatement = 3,
  ExpressionStatement = 4,
  ReturnStatement = 5,

}

const ENUM_MIN_STATEMENT: u8 = 0;
const ENUM_MAX_STATEMENT: u8 = 5;

impl<'a> flatbuffers::Follow<'a> for Statement {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Statement {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Statement;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Statement;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Statement {
    type Output = Statement;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Statement>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_STATEMENT:[Statement; 6] = [
  Statement::NONE,
  Statement::OptionStatement,
  Statement::BuiltinStatement,
  Statement::TestStatement,
  Statement::ExpressionStatement,
  Statement::ReturnStatement
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_STATEMENT:[&'static str; 6] = [
    "NONE",
    "OptionStatement",
    "BuiltinStatement",
    "TestStatement",
    "ExpressionStatement",
    "ReturnStatement"
];

pub fn enum_name_statement(e: Statement) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_STATEMENT[index as usize]
}

pub struct StatementUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Assignment {
  NONE = 0,
  MemberAssignment = 1,
  NativeVariableAssignment = 2,

}

const ENUM_MIN_ASSIGNMENT: u8 = 0;
const ENUM_MAX_ASSIGNMENT: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for Assignment {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Assignment {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Assignment;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Assignment;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Assignment {
    type Output = Assignment;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Assignment>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_ASSIGNMENT:[Assignment; 3] = [
  Assignment::NONE,
  Assignment::MemberAssignment,
  Assignment::NativeVariableAssignment
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_ASSIGNMENT:[&'static str; 3] = [
    "NONE",
    "MemberAssignment",
    "NativeVariableAssignment"
];

pub fn enum_name_assignment(e: Assignment) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_ASSIGNMENT[index as usize]
}

pub struct AssignmentUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Expression {
  NONE = 0,
  StringExpression = 1,
  ArrayExpression = 2,
  FunctionExpression = 3,
  BinaryExpression = 4,
  CallExpression = 5,
  ConditionalExpression = 6,
  IdentifierExpression = 7,
  LogicalExpression = 8,
  MemberExpression = 9,
  IndexExpression = 10,
  ObjectExpression = 11,
  UnaryExpression = 12,
  BooleanLiteral = 13,
  DateTimeLiteral = 14,
  DurationLiteral = 15,
  FloatLiteral = 16,
  IntegerLiteral = 17,
  StringLiteral = 18,
  RegexpLiteral = 19,
  UnsignedIntegerLiteral = 20,

}

const ENUM_MIN_EXPRESSION: u8 = 0;
const ENUM_MAX_EXPRESSION: u8 = 20;

impl<'a> flatbuffers::Follow<'a> for Expression {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Expression {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Expression;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Expression;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Expression {
    type Output = Expression;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Expression>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_EXPRESSION:[Expression; 21] = [
  Expression::NONE,
  Expression::StringExpression,
  Expression::ArrayExpression,
  Expression::FunctionExpression,
  Expression::BinaryExpression,
  Expression::CallExpression,
  Expression::ConditionalExpression,
  Expression::IdentifierExpression,
  Expression::LogicalExpression,
  Expression::MemberExpression,
  Expression::IndexExpression,
  Expression::ObjectExpression,
  Expression::UnaryExpression,
  Expression::BooleanLiteral,
  Expression::DateTimeLiteral,
  Expression::DurationLiteral,
  Expression::FloatLiteral,
  Expression::IntegerLiteral,
  Expression::StringLiteral,
  Expression::RegexpLiteral,
  Expression::UnsignedIntegerLiteral
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_EXPRESSION:[&'static str; 21] = [
    "NONE",
    "StringExpression",
    "ArrayExpression",
    "FunctionExpression",
    "BinaryExpression",
    "CallExpression",
    "ConditionalExpression",
    "IdentifierExpression",
    "LogicalExpression",
    "MemberExpression",
    "IndexExpression",
    "ObjectExpression",
    "UnaryExpression",
    "BooleanLiteral",
    "DateTimeLiteral",
    "DurationLiteral",
    "FloatLiteral",
    "IntegerLiteral",
    "StringLiteral",
    "RegexpLiteral",
    "UnsignedIntegerLiteral"
];

pub fn enum_name_expression(e: Expression) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_EXPRESSION[index as usize]
}

pub struct ExpressionUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum PropertyKey {
  NONE = 0,
  Identifier = 1,
  StringLiteral = 2,

}

const ENUM_MIN_PROPERTY_KEY: u8 = 0;
const ENUM_MAX_PROPERTY_KEY: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for PropertyKey {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for PropertyKey {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const PropertyKey;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const PropertyKey;
    unsafe { *p }
  }
}

impl flatbuffers::Push for PropertyKey {
    type Output = PropertyKey;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<PropertyKey>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_PROPERTY_KEY:[PropertyKey; 3] = [
  PropertyKey::NONE,
  PropertyKey::Identifier,
  PropertyKey::StringLiteral
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_PROPERTY_KEY:[&'static str; 3] = [
    "NONE",
    "Identifier",
    "StringLiteral"
];

pub fn enum_name_property_key(e: PropertyKey) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_PROPERTY_KEY[index as usize]
}

pub struct PropertyKeyUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Operator {
  MultiplicationOperator = 0,
  DivisionOperator = 1,
  ModuloOperator = 2,
  PowerOperator = 3,
  AdditionOperator = 4,
  SubtractionOperator = 5,
  LessThanEqualOperator = 6,
  LessThanOperator = 7,
  GreaterThanEqualOperator = 8,
  GreaterThanOperator = 9,
  StartsWithOperator = 10,
  InOperator = 11,
  NotOperator = 12,
  ExistsOperator = 13,
  NotEmptyOperator = 14,
  EmptyOperator = 15,
  EqualOperator = 16,
  NotEqualOperator = 17,
  RegexpMatchOperator = 18,
  NotRegexpMatchOperator = 19,
  InvalidOperator = 20,

}

const ENUM_MIN_OPERATOR: i8 = 0;
const ENUM_MAX_OPERATOR: i8 = 20;

impl<'a> flatbuffers::Follow<'a> for Operator {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Operator {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const Operator;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const Operator;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Operator {
    type Output = Operator;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Operator>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_OPERATOR:[Operator; 21] = [
  Operator::MultiplicationOperator,
  Operator::DivisionOperator,
  Operator::ModuloOperator,
  Operator::PowerOperator,
  Operator::AdditionOperator,
  Operator::SubtractionOperator,
  Operator::LessThanEqualOperator,
  Operator::LessThanOperator,
  Operator::GreaterThanEqualOperator,
  Operator::GreaterThanOperator,
  Operator::StartsWithOperator,
  Operator::InOperator,
  Operator::NotOperator,
  Operator::ExistsOperator,
  Operator::NotEmptyOperator,
  Operator::EmptyOperator,
  Operator::EqualOperator,
  Operator::NotEqualOperator,
  Operator::RegexpMatchOperator,
  Operator::NotRegexpMatchOperator,
  Operator::InvalidOperator
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_OPERATOR:[&'static str; 21] = [
    "MultiplicationOperator",
    "DivisionOperator",
    "ModuloOperator",
    "PowerOperator",
    "AdditionOperator",
    "SubtractionOperator",
    "LessThanEqualOperator",
    "LessThanOperator",
    "GreaterThanEqualOperator",
    "GreaterThanOperator",
    "StartsWithOperator",
    "InOperator",
    "NotOperator",
    "ExistsOperator",
    "NotEmptyOperator",
    "EmptyOperator",
    "EqualOperator",
    "NotEqualOperator",
    "RegexpMatchOperator",
    "NotRegexpMatchOperator",
    "InvalidOperator"
];

pub fn enum_name_operator(e: Operator) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_OPERATOR[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum LogicalOperator {
  AndOperator = 0,
  OrOperator = 1,

}

const ENUM_MIN_LOGICAL_OPERATOR: i8 = 0;
const ENUM_MAX_LOGICAL_OPERATOR: i8 = 1;

impl<'a> flatbuffers::Follow<'a> for LogicalOperator {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for LogicalOperator {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const LogicalOperator;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const LogicalOperator;
    unsafe { *p }
  }
}

impl flatbuffers::Push for LogicalOperator {
    type Output = LogicalOperator;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<LogicalOperator>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_LOGICAL_OPERATOR:[LogicalOperator; 2] = [
  LogicalOperator::AndOperator,
  LogicalOperator::OrOperator
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_LOGICAL_OPERATOR:[&'static str; 2] = [
    "AndOperator",
    "OrOperator"
];

pub fn enum_name_logical_operator(e: LogicalOperator) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_LOGICAL_OPERATOR[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum TimeUnit {
  y = 0,
  mo = 1,
  w = 2,
  d = 3,
  h = 4,
  m = 5,
  s = 6,
  ms = 7,
  us = 8,
  ns = 9,

}

const ENUM_MIN_TIME_UNIT: i8 = 0;
const ENUM_MAX_TIME_UNIT: i8 = 9;

impl<'a> flatbuffers::Follow<'a> for TimeUnit {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for TimeUnit {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const TimeUnit;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const TimeUnit;
    unsafe { *p }
  }
}

impl flatbuffers::Push for TimeUnit {
    type Output = TimeUnit;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<TimeUnit>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_TIME_UNIT:[TimeUnit; 10] = [
  TimeUnit::y,
  TimeUnit::mo,
  TimeUnit::w,
  TimeUnit::d,
  TimeUnit::h,
  TimeUnit::m,
  TimeUnit::s,
  TimeUnit::ms,
  TimeUnit::us,
  TimeUnit::ns
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_TIME_UNIT:[&'static str; 10] = [
    "y",
    "mo",
    "w",
    "d",
    "h",
    "m",
    "s",
    "ms",
    "us",
    "ns"
];

pub fn enum_name_time_unit(e: TimeUnit) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_TIME_UNIT[index as usize]
}

// struct Position, aligned to 4
#[repr(C, align(4))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Position {
  line_: i32,
  column_: i32,
} // pub struct Position
impl flatbuffers::SafeSliceAccess for Position {}
impl<'a> flatbuffers::Follow<'a> for Position {
  type Inner = &'a Position;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Position>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Position {
  type Inner = &'a Position;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Position>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Position {
    type Output = Position;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Position as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Position {
    type Output = Position;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Position as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Position {
  pub fn new<'a>(_line: i32, _column: i32) -> Self {
    Position {
      line_: _line.to_little_endian(),
      column_: _column.to_little_endian(),

    }
  }
  pub fn line<'a>(&'a self) -> i32 {
    self.line_.from_little_endian()
  }
  pub fn column<'a>(&'a self) -> i32 {
    self.column_.from_little_endian()
  }
}

pub enum PackageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Package<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Package<'a> {
    type Inner = Package<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Package<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Package {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PackageArgs<'args>) -> flatbuffers::WIPOffset<Package<'bldr>> {
      let mut builder = PackageBuilder::new(_fbb);
      if let Some(x) = args.files { builder.add_files(x); }
      if let Some(x) = args.package { builder.add_package(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_PACKAGE: flatbuffers::VOffsetT = 6;
    pub const VT_FILES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(Package::VT_LOC, None)
  }
  #[inline]
  pub fn package(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Package::VT_PACKAGE, None)
  }
  #[inline]
  pub fn files(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<File<'a>>>>>(Package::VT_FILES, None)
  }
}

pub struct PackageArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub package: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub files: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<File<'a >>>>>,
}
impl<'a> Default for PackageArgs<'a> {
    #[inline]
    fn default() -> Self {
        PackageArgs {
            loc: None,
            package: None,
            files: None,
        }
    }
}
pub struct PackageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PackageBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(Package::VT_LOC, loc);
  }
  #[inline]
  pub fn add_package(&mut self, package: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_PACKAGE, package);
  }
  #[inline]
  pub fn add_files(&mut self, files: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<File<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_FILES, files);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PackageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PackageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Package<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FileOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct File<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for File<'a> {
    type Inner = File<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> File<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        File {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FileArgs<'args>) -> flatbuffers::WIPOffset<File<'bldr>> {
      let mut builder = FileBuilder::new(_fbb);
      if let Some(x) = args.body { builder.add_body(x); }
      if let Some(x) = args.imports { builder.add_imports(x); }
      if let Some(x) = args.package { builder.add_package(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_PACKAGE: flatbuffers::VOffsetT = 6;
    pub const VT_IMPORTS: flatbuffers::VOffsetT = 8;
    pub const VT_BODY: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(File::VT_LOC, None)
  }
  #[inline]
  pub fn package(&self) -> Option<PackageClause<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<PackageClause<'a>>>(File::VT_PACKAGE, None)
  }
  #[inline]
  pub fn imports(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ImportDeclaration<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<ImportDeclaration<'a>>>>>(File::VT_IMPORTS, None)
  }
  #[inline]
  pub fn body(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>>>(File::VT_BODY, None)
  }
}

pub struct FileArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub package: Option<flatbuffers::WIPOffset<PackageClause<'a >>>,
    pub imports: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<ImportDeclaration<'a >>>>>,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<WrappedStatement<'a >>>>>,
}
impl<'a> Default for FileArgs<'a> {
    #[inline]
    fn default() -> Self {
        FileArgs {
            loc: None,
            package: None,
            imports: None,
            body: None,
        }
    }
}
pub struct FileBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FileBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(File::VT_LOC, loc);
  }
  #[inline]
  pub fn add_package(&mut self, package: flatbuffers::WIPOffset<PackageClause<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PackageClause>>(File::VT_PACKAGE, package);
  }
  #[inline]
  pub fn add_imports(&mut self, imports: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ImportDeclaration<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_IMPORTS, imports);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WrappedStatement<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_BODY, body);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FileBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<File<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PackageClauseOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct PackageClause<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PackageClause<'a> {
    type Inner = PackageClause<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> PackageClause<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PackageClause {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PackageClauseArgs<'args>) -> flatbuffers::WIPOffset<PackageClause<'bldr>> {
      let mut builder = PackageClauseBuilder::new(_fbb);
      if let Some(x) = args.name { builder.add_name(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(PackageClause::VT_LOC, None)
  }
  #[inline]
  pub fn name(&self) -> Option<Identifier<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(PackageClause::VT_NAME, None)
  }
}

pub struct PackageClauseArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub name: Option<flatbuffers::WIPOffset<Identifier<'a >>>,
}
impl<'a> Default for PackageClauseArgs<'a> {
    #[inline]
    fn default() -> Self {
        PackageClauseArgs {
            loc: None,
            name: None,
        }
    }
}
pub struct PackageClauseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PackageClauseBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(PackageClause::VT_LOC, loc);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(PackageClause::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PackageClauseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PackageClauseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PackageClause<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ImportDeclarationOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ImportDeclaration<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ImportDeclaration<'a> {
    type Inner = ImportDeclaration<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ImportDeclaration<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ImportDeclaration {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ImportDeclarationArgs<'args>) -> flatbuffers::WIPOffset<ImportDeclaration<'bldr>> {
      let mut builder = ImportDeclarationBuilder::new(_fbb);
      if let Some(x) = args.path { builder.add_path(x); }
      if let Some(x) = args.as_ { builder.add_as_(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_AS_: flatbuffers::VOffsetT = 6;
    pub const VT_PATH: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(ImportDeclaration::VT_LOC, None)
  }
  #[inline]
  pub fn as_(&self) -> Option<Identifier<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(ImportDeclaration::VT_AS_, None)
  }
  #[inline]
  pub fn path(&self) -> Option<StringLiteral<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<StringLiteral<'a>>>(ImportDeclaration::VT_PATH, None)
  }
}

pub struct ImportDeclarationArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub as_: Option<flatbuffers::WIPOffset<Identifier<'a >>>,
    pub path: Option<flatbuffers::WIPOffset<StringLiteral<'a >>>,
}
impl<'a> Default for ImportDeclarationArgs<'a> {
    #[inline]
    fn default() -> Self {
        ImportDeclarationArgs {
            loc: None,
            as_: None,
            path: None,
        }
    }
}
pub struct ImportDeclarationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ImportDeclarationBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(ImportDeclaration::VT_LOC, loc);
  }
  #[inline]
  pub fn add_as_(&mut self, as_: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(ImportDeclaration::VT_AS_, as_);
  }
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<StringLiteral<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StringLiteral>>(ImportDeclaration::VT_PATH, path);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ImportDeclarationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ImportDeclarationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ImportDeclaration<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Block<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Block<'a> {
    type Inner = Block<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Block<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Block {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockArgs<'args>) -> flatbuffers::WIPOffset<Block<'bldr>> {
      let mut builder = BlockBuilder::new(_fbb);
      if let Some(x) = args.body { builder.add_body(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_BODY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(Block::VT_LOC, None)
  }
  #[inline]
  pub fn body(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<WrappedStatement<'a>>>>>(Block::VT_BODY, None)
  }
}

pub struct BlockArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<WrappedStatement<'a >>>>>,
}
impl<'a> Default for BlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockArgs {
            loc: None,
            body: None,
        }
    }
}
pub struct BlockBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(Block::VT_LOC, loc);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WrappedStatement<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_BODY, body);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Block<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SourceLocationOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SourceLocation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SourceLocation<'a> {
    type Inner = SourceLocation<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SourceLocation<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SourceLocation {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SourceLocationArgs<'args>) -> flatbuffers::WIPOffset<SourceLocation<'bldr>> {
      let mut builder = SourceLocationBuilder::new(_fbb);
      if let Some(x) = args.source { builder.add_source(x); }
      if let Some(x) = args.end { builder.add_end(x); }
      if let Some(x) = args.start { builder.add_start(x); }
      if let Some(x) = args.file { builder.add_file(x); }
      builder.finish()
    }

    pub const VT_FILE: flatbuffers::VOffsetT = 4;
    pub const VT_START: flatbuffers::VOffsetT = 6;
    pub const VT_END: flatbuffers::VOffsetT = 8;
    pub const VT_SOURCE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn file(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SourceLocation::VT_FILE, None)
  }
  #[inline]
  pub fn start(&self) -> Option<&'a Position> {
    self._tab.get::<Position>(SourceLocation::VT_START, None)
  }
  #[inline]
  pub fn end(&self) -> Option<&'a Position> {
    self._tab.get::<Position>(SourceLocation::VT_END, None)
  }
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SourceLocation::VT_SOURCE, None)
  }
}

pub struct SourceLocationArgs<'a> {
    pub file: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub start: Option<&'a  Position>,
    pub end: Option<&'a  Position>,
    pub source: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for SourceLocationArgs<'a> {
    #[inline]
    fn default() -> Self {
        SourceLocationArgs {
            file: None,
            start: None,
            end: None,
            source: None,
        }
    }
}
pub struct SourceLocationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SourceLocationBuilder<'a, 'b> {
  #[inline]
  pub fn add_file(&mut self, file: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SourceLocation::VT_FILE, file);
  }
  #[inline]
  pub fn add_start(&mut self, start: &'b  Position) {
    self.fbb_.push_slot_always::<&Position>(SourceLocation::VT_START, start);
  }
  #[inline]
  pub fn add_end(&mut self, end: &'b  Position) {
    self.fbb_.push_slot_always::<&Position>(SourceLocation::VT_END, end);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SourceLocation::VT_SOURCE, source);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SourceLocationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SourceLocationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SourceLocation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum WrappedStatementOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct WrappedStatement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WrappedStatement<'a> {
    type Inner = WrappedStatement<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> WrappedStatement<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WrappedStatement {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WrappedStatementArgs) -> flatbuffers::WIPOffset<WrappedStatement<'bldr>> {
      let mut builder = WrappedStatementBuilder::new(_fbb);
      if let Some(x) = args.statement { builder.add_statement(x); }
      builder.add_statement_type(args.statement_type);
      builder.finish()
    }

    pub const VT_STATEMENT_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_STATEMENT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn statement_type(&self) -> Statement {
    self._tab.get::<Statement>(WrappedStatement::VT_STATEMENT_TYPE, Some(Statement::NONE)).unwrap()
  }
  #[inline]
  pub fn statement(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(WrappedStatement::VT_STATEMENT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn statement_as_option_statement(&self) -> Option<OptionStatement<'a>> {
    if self.statement_type() == Statement::OptionStatement {
      self.statement().map(|u| OptionStatement::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn statement_as_builtin_statement(&self) -> Option<BuiltinStatement<'a>> {
    if self.statement_type() == Statement::BuiltinStatement {
      self.statement().map(|u| BuiltinStatement::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn statement_as_test_statement(&self) -> Option<TestStatement<'a>> {
    if self.statement_type() == Statement::TestStatement {
      self.statement().map(|u| TestStatement::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn statement_as_expression_statement(&self) -> Option<ExpressionStatement<'a>> {
    if self.statement_type() == Statement::ExpressionStatement {
      self.statement().map(|u| ExpressionStatement::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn statement_as_return_statement(&self) -> Option<ReturnStatement<'a>> {
    if self.statement_type() == Statement::ReturnStatement {
      self.statement().map(|u| ReturnStatement::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct WrappedStatementArgs {
    pub statement_type: Statement,
    pub statement: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for WrappedStatementArgs {
    #[inline]
    fn default() -> Self {
        WrappedStatementArgs {
            statement_type: Statement::NONE,
            statement: None,
        }
    }
}
pub struct WrappedStatementBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WrappedStatementBuilder<'a, 'b> {
  #[inline]
  pub fn add_statement_type(&mut self, statement_type: Statement) {
    self.fbb_.push_slot::<Statement>(WrappedStatement::VT_STATEMENT_TYPE, statement_type, Statement::NONE);
  }
  #[inline]
  pub fn add_statement(&mut self, statement: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WrappedStatement::VT_STATEMENT, statement);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WrappedStatementBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WrappedStatementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WrappedStatement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum OptionStatementOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct OptionStatement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OptionStatement<'a> {
    type Inner = OptionStatement<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> OptionStatement<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OptionStatement {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OptionStatementArgs<'args>) -> flatbuffers::WIPOffset<OptionStatement<'bldr>> {
      let mut builder = OptionStatementBuilder::new(_fbb);
      if let Some(x) = args.assignment { builder.add_assignment(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.add_assignment_type(args.assignment_type);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_ASSIGNMENT_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_ASSIGNMENT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(OptionStatement::VT_LOC, None)
  }
  #[inline]
  pub fn assignment_type(&self) -> Assignment {
    self._tab.get::<Assignment>(OptionStatement::VT_ASSIGNMENT_TYPE, Some(Assignment::NONE)).unwrap()
  }
  #[inline]
  pub fn assignment(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(OptionStatement::VT_ASSIGNMENT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn assignment_as_member_assignment(&self) -> Option<MemberAssignment<'a>> {
    if self.assignment_type() == Assignment::MemberAssignment {
      self.assignment().map(|u| MemberAssignment::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn assignment_as_native_variable_assignment(&self) -> Option<NativeVariableAssignment<'a>> {
    if self.assignment_type() == Assignment::NativeVariableAssignment {
      self.assignment().map(|u| NativeVariableAssignment::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct OptionStatementArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub assignment_type: Assignment,
    pub assignment: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for OptionStatementArgs<'a> {
    #[inline]
    fn default() -> Self {
        OptionStatementArgs {
            loc: None,
            assignment_type: Assignment::NONE,
            assignment: None,
        }
    }
}
pub struct OptionStatementBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OptionStatementBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(OptionStatement::VT_LOC, loc);
  }
  #[inline]
  pub fn add_assignment_type(&mut self, assignment_type: Assignment) {
    self.fbb_.push_slot::<Assignment>(OptionStatement::VT_ASSIGNMENT_TYPE, assignment_type, Assignment::NONE);
  }
  #[inline]
  pub fn add_assignment(&mut self, assignment: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OptionStatement::VT_ASSIGNMENT, assignment);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OptionStatementBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OptionStatementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OptionStatement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BuiltinStatementOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BuiltinStatement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BuiltinStatement<'a> {
    type Inner = BuiltinStatement<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BuiltinStatement<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BuiltinStatement {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BuiltinStatementArgs<'args>) -> flatbuffers::WIPOffset<BuiltinStatement<'bldr>> {
      let mut builder = BuiltinStatementBuilder::new(_fbb);
      if let Some(x) = args.id { builder.add_id(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(BuiltinStatement::VT_LOC, None)
  }
  #[inline]
  pub fn id(&self) -> Option<Identifier<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(BuiltinStatement::VT_ID, None)
  }
}

pub struct BuiltinStatementArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub id: Option<flatbuffers::WIPOffset<Identifier<'a >>>,
}
impl<'a> Default for BuiltinStatementArgs<'a> {
    #[inline]
    fn default() -> Self {
        BuiltinStatementArgs {
            loc: None,
            id: None,
        }
    }
}
pub struct BuiltinStatementBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BuiltinStatementBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(BuiltinStatement::VT_LOC, loc);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(BuiltinStatement::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BuiltinStatementBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BuiltinStatementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BuiltinStatement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TestStatementOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct TestStatement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TestStatement<'a> {
    type Inner = TestStatement<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TestStatement<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TestStatement {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TestStatementArgs<'args>) -> flatbuffers::WIPOffset<TestStatement<'bldr>> {
      let mut builder = TestStatementBuilder::new(_fbb);
      if let Some(x) = args.assignment { builder.add_assignment(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_ASSIGNMENT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(TestStatement::VT_LOC, None)
  }
  #[inline]
  pub fn assignment(&self) -> Option<NativeVariableAssignment<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<NativeVariableAssignment<'a>>>(TestStatement::VT_ASSIGNMENT, None)
  }
}

pub struct TestStatementArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub assignment: Option<flatbuffers::WIPOffset<NativeVariableAssignment<'a >>>,
}
impl<'a> Default for TestStatementArgs<'a> {
    #[inline]
    fn default() -> Self {
        TestStatementArgs {
            loc: None,
            assignment: None,
        }
    }
}
pub struct TestStatementBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TestStatementBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(TestStatement::VT_LOC, loc);
  }
  #[inline]
  pub fn add_assignment(&mut self, assignment: flatbuffers::WIPOffset<NativeVariableAssignment<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<NativeVariableAssignment>>(TestStatement::VT_ASSIGNMENT, assignment);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TestStatementBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TestStatementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TestStatement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ExpressionStatementOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ExpressionStatement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExpressionStatement<'a> {
    type Inner = ExpressionStatement<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ExpressionStatement<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExpressionStatement {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExpressionStatementArgs<'args>) -> flatbuffers::WIPOffset<ExpressionStatement<'bldr>> {
      let mut builder = ExpressionStatementBuilder::new(_fbb);
      if let Some(x) = args.expression { builder.add_expression(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.add_expression_type(args.expression_type);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_EXPRESSION_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_EXPRESSION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(ExpressionStatement::VT_LOC, None)
  }
  #[inline]
  pub fn expression_type(&self) -> Expression {
    self._tab.get::<Expression>(ExpressionStatement::VT_EXPRESSION_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn expression(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ExpressionStatement::VT_EXPRESSION, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.expression_type() == Expression::StringExpression {
      self.expression().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.expression_type() == Expression::ArrayExpression {
      self.expression().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.expression_type() == Expression::FunctionExpression {
      self.expression().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.expression_type() == Expression::BinaryExpression {
      self.expression().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.expression_type() == Expression::CallExpression {
      self.expression().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.expression_type() == Expression::ConditionalExpression {
      self.expression().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.expression_type() == Expression::IdentifierExpression {
      self.expression().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.expression_type() == Expression::LogicalExpression {
      self.expression().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.expression_type() == Expression::MemberExpression {
      self.expression().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.expression_type() == Expression::IndexExpression {
      self.expression().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.expression_type() == Expression::ObjectExpression {
      self.expression().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.expression_type() == Expression::UnaryExpression {
      self.expression().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.expression_type() == Expression::BooleanLiteral {
      self.expression().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.expression_type() == Expression::DateTimeLiteral {
      self.expression().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.expression_type() == Expression::DurationLiteral {
      self.expression().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.expression_type() == Expression::FloatLiteral {
      self.expression().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.expression_type() == Expression::IntegerLiteral {
      self.expression().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.expression_type() == Expression::StringLiteral {
      self.expression().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.expression_type() == Expression::RegexpLiteral {
      self.expression().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.expression_type() == Expression::UnsignedIntegerLiteral {
      self.expression().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct ExpressionStatementArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub expression_type: Expression,
    pub expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ExpressionStatementArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExpressionStatementArgs {
            loc: None,
            expression_type: Expression::NONE,
            expression: None,
        }
    }
}
pub struct ExpressionStatementBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExpressionStatementBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(ExpressionStatement::VT_LOC, loc);
  }
  #[inline]
  pub fn add_expression_type(&mut self, expression_type: Expression) {
    self.fbb_.push_slot::<Expression>(ExpressionStatement::VT_EXPRESSION_TYPE, expression_type, Expression::NONE);
  }
  #[inline]
  pub fn add_expression(&mut self, expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExpressionStatement::VT_EXPRESSION, expression);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExpressionStatementBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExpressionStatementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExpressionStatement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ReturnStatementOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ReturnStatement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReturnStatement<'a> {
    type Inner = ReturnStatement<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ReturnStatement<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReturnStatement {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReturnStatementArgs<'args>) -> flatbuffers::WIPOffset<ReturnStatement<'bldr>> {
      let mut builder = ReturnStatementBuilder::new(_fbb);
      if let Some(x) = args.argument { builder.add_argument(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.add_argument_type(args.argument_type);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_ARGUMENT_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_ARGUMENT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(ReturnStatement::VT_LOC, None)
  }
  #[inline]
  pub fn argument_type(&self) -> Expression {
    self._tab.get::<Expression>(ReturnStatement::VT_ARGUMENT_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn argument(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ReturnStatement::VT_ARGUMENT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.argument_type() == Expression::StringExpression {
      self.argument().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.argument_type() == Expression::ArrayExpression {
      self.argument().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.argument_type() == Expression::FunctionExpression {
      self.argument().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.argument_type() == Expression::BinaryExpression {
      self.argument().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.argument_type() == Expression::CallExpression {
      self.argument().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.argument_type() == Expression::ConditionalExpression {
      self.argument().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.argument_type() == Expression::IdentifierExpression {
      self.argument().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.argument_type() == Expression::LogicalExpression {
      self.argument().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.argument_type() == Expression::MemberExpression {
      self.argument().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.argument_type() == Expression::IndexExpression {
      self.argument().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.argument_type() == Expression::ObjectExpression {
      self.argument().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.argument_type() == Expression::UnaryExpression {
      self.argument().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.argument_type() == Expression::BooleanLiteral {
      self.argument().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.argument_type() == Expression::DateTimeLiteral {
      self.argument().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.argument_type() == Expression::DurationLiteral {
      self.argument().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.argument_type() == Expression::FloatLiteral {
      self.argument().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.argument_type() == Expression::IntegerLiteral {
      self.argument().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.argument_type() == Expression::StringLiteral {
      self.argument().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.argument_type() == Expression::RegexpLiteral {
      self.argument().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.argument_type() == Expression::UnsignedIntegerLiteral {
      self.argument().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct ReturnStatementArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub argument_type: Expression,
    pub argument: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ReturnStatementArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReturnStatementArgs {
            loc: None,
            argument_type: Expression::NONE,
            argument: None,
        }
    }
}
pub struct ReturnStatementBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReturnStatementBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(ReturnStatement::VT_LOC, loc);
  }
  #[inline]
  pub fn add_argument_type(&mut self, argument_type: Expression) {
    self.fbb_.push_slot::<Expression>(ReturnStatement::VT_ARGUMENT_TYPE, argument_type, Expression::NONE);
  }
  #[inline]
  pub fn add_argument(&mut self, argument: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReturnStatement::VT_ARGUMENT, argument);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReturnStatementBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReturnStatementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReturnStatement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum NativeVariableAssignmentOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct NativeVariableAssignment<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NativeVariableAssignment<'a> {
    type Inner = NativeVariableAssignment<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> NativeVariableAssignment<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        NativeVariableAssignment {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args NativeVariableAssignmentArgs<'args>) -> flatbuffers::WIPOffset<NativeVariableAssignment<'bldr>> {
      let mut builder = NativeVariableAssignmentBuilder::new(_fbb);
      if let Some(x) = args.init_ { builder.add_init_(x); }
      if let Some(x) = args.identifier { builder.add_identifier(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.add_init__type(args.init__type);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_IDENTIFIER: flatbuffers::VOffsetT = 6;
    pub const VT_INIT__TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_INIT_: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(NativeVariableAssignment::VT_LOC, None)
  }
  #[inline]
  pub fn identifier(&self) -> Option<Identifier<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(NativeVariableAssignment::VT_IDENTIFIER, None)
  }
  #[inline]
  pub fn init__type(&self) -> Expression {
    self._tab.get::<Expression>(NativeVariableAssignment::VT_INIT__TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn init_(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(NativeVariableAssignment::VT_INIT_, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.init__type() == Expression::StringExpression {
      self.init_().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.init__type() == Expression::ArrayExpression {
      self.init_().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.init__type() == Expression::FunctionExpression {
      self.init_().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.init__type() == Expression::BinaryExpression {
      self.init_().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.init__type() == Expression::CallExpression {
      self.init_().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.init__type() == Expression::ConditionalExpression {
      self.init_().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.init__type() == Expression::IdentifierExpression {
      self.init_().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.init__type() == Expression::LogicalExpression {
      self.init_().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.init__type() == Expression::MemberExpression {
      self.init_().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.init__type() == Expression::IndexExpression {
      self.init_().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.init__type() == Expression::ObjectExpression {
      self.init_().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.init__type() == Expression::UnaryExpression {
      self.init_().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.init__type() == Expression::BooleanLiteral {
      self.init_().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.init__type() == Expression::DateTimeLiteral {
      self.init_().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.init__type() == Expression::DurationLiteral {
      self.init_().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.init__type() == Expression::FloatLiteral {
      self.init_().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.init__type() == Expression::IntegerLiteral {
      self.init_().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.init__type() == Expression::StringLiteral {
      self.init_().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.init__type() == Expression::RegexpLiteral {
      self.init_().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.init__type() == Expression::UnsignedIntegerLiteral {
      self.init_().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct NativeVariableAssignmentArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub identifier: Option<flatbuffers::WIPOffset<Identifier<'a >>>,
    pub init__type: Expression,
    pub init_: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for NativeVariableAssignmentArgs<'a> {
    #[inline]
    fn default() -> Self {
        NativeVariableAssignmentArgs {
            loc: None,
            identifier: None,
            init__type: Expression::NONE,
            init_: None,
        }
    }
}
pub struct NativeVariableAssignmentBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NativeVariableAssignmentBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(NativeVariableAssignment::VT_LOC, loc);
  }
  #[inline]
  pub fn add_identifier(&mut self, identifier: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(NativeVariableAssignment::VT_IDENTIFIER, identifier);
  }
  #[inline]
  pub fn add_init__type(&mut self, init__type: Expression) {
    self.fbb_.push_slot::<Expression>(NativeVariableAssignment::VT_INIT__TYPE, init__type, Expression::NONE);
  }
  #[inline]
  pub fn add_init_(&mut self, init_: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NativeVariableAssignment::VT_INIT_, init_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NativeVariableAssignmentBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NativeVariableAssignmentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NativeVariableAssignment<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum MemberAssignmentOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct MemberAssignment<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MemberAssignment<'a> {
    type Inner = MemberAssignment<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> MemberAssignment<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MemberAssignment {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MemberAssignmentArgs<'args>) -> flatbuffers::WIPOffset<MemberAssignment<'bldr>> {
      let mut builder = MemberAssignmentBuilder::new(_fbb);
      if let Some(x) = args.init_ { builder.add_init_(x); }
      if let Some(x) = args.member { builder.add_member(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.add_init__type(args.init__type);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_MEMBER: flatbuffers::VOffsetT = 6;
    pub const VT_INIT__TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_INIT_: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(MemberAssignment::VT_LOC, None)
  }
  #[inline]
  pub fn member(&self) -> Option<MemberExpression<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<MemberExpression<'a>>>(MemberAssignment::VT_MEMBER, None)
  }
  #[inline]
  pub fn init__type(&self) -> Expression {
    self._tab.get::<Expression>(MemberAssignment::VT_INIT__TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn init_(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(MemberAssignment::VT_INIT_, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.init__type() == Expression::StringExpression {
      self.init_().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.init__type() == Expression::ArrayExpression {
      self.init_().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.init__type() == Expression::FunctionExpression {
      self.init_().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.init__type() == Expression::BinaryExpression {
      self.init_().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.init__type() == Expression::CallExpression {
      self.init_().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.init__type() == Expression::ConditionalExpression {
      self.init_().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.init__type() == Expression::IdentifierExpression {
      self.init_().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.init__type() == Expression::LogicalExpression {
      self.init_().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.init__type() == Expression::MemberExpression {
      self.init_().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.init__type() == Expression::IndexExpression {
      self.init_().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.init__type() == Expression::ObjectExpression {
      self.init_().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.init__type() == Expression::UnaryExpression {
      self.init_().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.init__type() == Expression::BooleanLiteral {
      self.init_().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.init__type() == Expression::DateTimeLiteral {
      self.init_().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.init__type() == Expression::DurationLiteral {
      self.init_().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.init__type() == Expression::FloatLiteral {
      self.init_().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.init__type() == Expression::IntegerLiteral {
      self.init_().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.init__type() == Expression::StringLiteral {
      self.init_().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.init__type() == Expression::RegexpLiteral {
      self.init_().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn init__as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.init__type() == Expression::UnsignedIntegerLiteral {
      self.init_().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct MemberAssignmentArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub member: Option<flatbuffers::WIPOffset<MemberExpression<'a >>>,
    pub init__type: Expression,
    pub init_: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for MemberAssignmentArgs<'a> {
    #[inline]
    fn default() -> Self {
        MemberAssignmentArgs {
            loc: None,
            member: None,
            init__type: Expression::NONE,
            init_: None,
        }
    }
}
pub struct MemberAssignmentBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MemberAssignmentBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(MemberAssignment::VT_LOC, loc);
  }
  #[inline]
  pub fn add_member(&mut self, member: flatbuffers::WIPOffset<MemberExpression<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MemberExpression>>(MemberAssignment::VT_MEMBER, member);
  }
  #[inline]
  pub fn add_init__type(&mut self, init__type: Expression) {
    self.fbb_.push_slot::<Expression>(MemberAssignment::VT_INIT__TYPE, init__type, Expression::NONE);
  }
  #[inline]
  pub fn add_init_(&mut self, init_: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MemberAssignment::VT_INIT_, init_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MemberAssignmentBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MemberAssignmentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MemberAssignment<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum WrappedExpressionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct WrappedExpression<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WrappedExpression<'a> {
    type Inner = WrappedExpression<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> WrappedExpression<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WrappedExpression {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WrappedExpressionArgs) -> flatbuffers::WIPOffset<WrappedExpression<'bldr>> {
      let mut builder = WrappedExpressionBuilder::new(_fbb);
      if let Some(x) = args.expression { builder.add_expression(x); }
      builder.add_expression_type(args.expression_type);
      builder.finish()
    }

    pub const VT_EXPRESSION_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_EXPRESSION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn expression_type(&self) -> Expression {
    self._tab.get::<Expression>(WrappedExpression::VT_EXPRESSION_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn expression(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(WrappedExpression::VT_EXPRESSION, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.expression_type() == Expression::StringExpression {
      self.expression().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.expression_type() == Expression::ArrayExpression {
      self.expression().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.expression_type() == Expression::FunctionExpression {
      self.expression().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.expression_type() == Expression::BinaryExpression {
      self.expression().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.expression_type() == Expression::CallExpression {
      self.expression().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.expression_type() == Expression::ConditionalExpression {
      self.expression().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.expression_type() == Expression::IdentifierExpression {
      self.expression().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.expression_type() == Expression::LogicalExpression {
      self.expression().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.expression_type() == Expression::MemberExpression {
      self.expression().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.expression_type() == Expression::IndexExpression {
      self.expression().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.expression_type() == Expression::ObjectExpression {
      self.expression().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.expression_type() == Expression::UnaryExpression {
      self.expression().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.expression_type() == Expression::BooleanLiteral {
      self.expression().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.expression_type() == Expression::DateTimeLiteral {
      self.expression().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.expression_type() == Expression::DurationLiteral {
      self.expression().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.expression_type() == Expression::FloatLiteral {
      self.expression().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.expression_type() == Expression::IntegerLiteral {
      self.expression().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.expression_type() == Expression::StringLiteral {
      self.expression().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.expression_type() == Expression::RegexpLiteral {
      self.expression().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expression_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.expression_type() == Expression::UnsignedIntegerLiteral {
      self.expression().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct WrappedExpressionArgs {
    pub expression_type: Expression,
    pub expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for WrappedExpressionArgs {
    #[inline]
    fn default() -> Self {
        WrappedExpressionArgs {
            expression_type: Expression::NONE,
            expression: None,
        }
    }
}
pub struct WrappedExpressionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WrappedExpressionBuilder<'a, 'b> {
  #[inline]
  pub fn add_expression_type(&mut self, expression_type: Expression) {
    self.fbb_.push_slot::<Expression>(WrappedExpression::VT_EXPRESSION_TYPE, expression_type, Expression::NONE);
  }
  #[inline]
  pub fn add_expression(&mut self, expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WrappedExpression::VT_EXPRESSION, expression);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WrappedExpressionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WrappedExpressionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WrappedExpression<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum StringExpressionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StringExpression<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StringExpression<'a> {
    type Inner = StringExpression<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StringExpression<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StringExpression {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StringExpressionArgs<'args>) -> flatbuffers::WIPOffset<StringExpression<'bldr>> {
      let mut builder = StringExpressionBuilder::new(_fbb);
      if let Some(x) = args.parts { builder.add_parts(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_PARTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(StringExpression::VT_LOC, None)
  }
  #[inline]
  pub fn parts(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringExpressionPart<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<StringExpressionPart<'a>>>>>(StringExpression::VT_PARTS, None)
  }
}

pub struct StringExpressionArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub parts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<StringExpressionPart<'a >>>>>,
}
impl<'a> Default for StringExpressionArgs<'a> {
    #[inline]
    fn default() -> Self {
        StringExpressionArgs {
            loc: None,
            parts: None,
        }
    }
}
pub struct StringExpressionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StringExpressionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(StringExpression::VT_LOC, loc);
  }
  #[inline]
  pub fn add_parts(&mut self, parts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringExpressionPart<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringExpression::VT_PARTS, parts);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StringExpressionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StringExpressionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StringExpression<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum StringExpressionPartOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StringExpressionPart<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StringExpressionPart<'a> {
    type Inner = StringExpressionPart<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StringExpressionPart<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StringExpressionPart {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StringExpressionPartArgs<'args>) -> flatbuffers::WIPOffset<StringExpressionPart<'bldr>> {
      let mut builder = StringExpressionPartBuilder::new(_fbb);
      if let Some(x) = args.interpolated_expression { builder.add_interpolated_expression(x); }
      if let Some(x) = args.text_value { builder.add_text_value(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.add_interpolated_expression_type(args.interpolated_expression_type);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_TEXT_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_INTERPOLATED_EXPRESSION_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_INTERPOLATED_EXPRESSION: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(StringExpressionPart::VT_LOC, None)
  }
  #[inline]
  pub fn text_value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringExpressionPart::VT_TEXT_VALUE, None)
  }
  #[inline]
  pub fn interpolated_expression_type(&self) -> Expression {
    self._tab.get::<Expression>(StringExpressionPart::VT_INTERPOLATED_EXPRESSION_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn interpolated_expression(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(StringExpressionPart::VT_INTERPOLATED_EXPRESSION, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.interpolated_expression_type() == Expression::StringExpression {
      self.interpolated_expression().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.interpolated_expression_type() == Expression::ArrayExpression {
      self.interpolated_expression().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.interpolated_expression_type() == Expression::FunctionExpression {
      self.interpolated_expression().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.interpolated_expression_type() == Expression::BinaryExpression {
      self.interpolated_expression().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.interpolated_expression_type() == Expression::CallExpression {
      self.interpolated_expression().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.interpolated_expression_type() == Expression::ConditionalExpression {
      self.interpolated_expression().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.interpolated_expression_type() == Expression::IdentifierExpression {
      self.interpolated_expression().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.interpolated_expression_type() == Expression::LogicalExpression {
      self.interpolated_expression().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.interpolated_expression_type() == Expression::MemberExpression {
      self.interpolated_expression().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.interpolated_expression_type() == Expression::IndexExpression {
      self.interpolated_expression().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.interpolated_expression_type() == Expression::ObjectExpression {
      self.interpolated_expression().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.interpolated_expression_type() == Expression::UnaryExpression {
      self.interpolated_expression().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.interpolated_expression_type() == Expression::BooleanLiteral {
      self.interpolated_expression().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.interpolated_expression_type() == Expression::DateTimeLiteral {
      self.interpolated_expression().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.interpolated_expression_type() == Expression::DurationLiteral {
      self.interpolated_expression().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.interpolated_expression_type() == Expression::FloatLiteral {
      self.interpolated_expression().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.interpolated_expression_type() == Expression::IntegerLiteral {
      self.interpolated_expression().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.interpolated_expression_type() == Expression::StringLiteral {
      self.interpolated_expression().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.interpolated_expression_type() == Expression::RegexpLiteral {
      self.interpolated_expression().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolated_expression_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.interpolated_expression_type() == Expression::UnsignedIntegerLiteral {
      self.interpolated_expression().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct StringExpressionPartArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub text_value: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub interpolated_expression_type: Expression,
    pub interpolated_expression: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for StringExpressionPartArgs<'a> {
    #[inline]
    fn default() -> Self {
        StringExpressionPartArgs {
            loc: None,
            text_value: None,
            interpolated_expression_type: Expression::NONE,
            interpolated_expression: None,
        }
    }
}
pub struct StringExpressionPartBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StringExpressionPartBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(StringExpressionPart::VT_LOC, loc);
  }
  #[inline]
  pub fn add_text_value(&mut self, text_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringExpressionPart::VT_TEXT_VALUE, text_value);
  }
  #[inline]
  pub fn add_interpolated_expression_type(&mut self, interpolated_expression_type: Expression) {
    self.fbb_.push_slot::<Expression>(StringExpressionPart::VT_INTERPOLATED_EXPRESSION_TYPE, interpolated_expression_type, Expression::NONE);
  }
  #[inline]
  pub fn add_interpolated_expression(&mut self, interpolated_expression: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringExpressionPart::VT_INTERPOLATED_EXPRESSION, interpolated_expression);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StringExpressionPartBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StringExpressionPartBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StringExpressionPart<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ArrayExpressionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ArrayExpression<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArrayExpression<'a> {
    type Inner = ArrayExpression<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ArrayExpression<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ArrayExpression {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ArrayExpressionArgs<'args>) -> flatbuffers::WIPOffset<ArrayExpression<'bldr>> {
      let mut builder = ArrayExpressionBuilder::new(_fbb);
      if let Some(x) = args.elements { builder.add_elements(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_ELEMENTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(ArrayExpression::VT_LOC, None)
  }
  #[inline]
  pub fn elements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WrappedExpression<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<WrappedExpression<'a>>>>>(ArrayExpression::VT_ELEMENTS, None)
  }
}

pub struct ArrayExpressionArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<WrappedExpression<'a >>>>>,
}
impl<'a> Default for ArrayExpressionArgs<'a> {
    #[inline]
    fn default() -> Self {
        ArrayExpressionArgs {
            loc: None,
            elements: None,
        }
    }
}
pub struct ArrayExpressionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArrayExpressionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(ArrayExpression::VT_LOC, loc);
  }
  #[inline]
  pub fn add_elements(&mut self, elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WrappedExpression<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayExpression::VT_ELEMENTS, elements);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrayExpressionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArrayExpressionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArrayExpression<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FunctionExpressionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FunctionExpression<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FunctionExpression<'a> {
    type Inner = FunctionExpression<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FunctionExpression<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FunctionExpression {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FunctionExpressionArgs<'args>) -> flatbuffers::WIPOffset<FunctionExpression<'bldr>> {
      let mut builder = FunctionExpressionBuilder::new(_fbb);
      if let Some(x) = args.Block { builder.add_Block(x); }
      if let Some(x) = args.defaults { builder.add_defaults(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_DEFAULTS: flatbuffers::VOffsetT = 6;
    pub const VT_BLOCK: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(FunctionExpression::VT_LOC, None)
  }
  #[inline]
  pub fn defaults(&self) -> Option<ObjectExpression<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<ObjectExpression<'a>>>(FunctionExpression::VT_DEFAULTS, None)
  }
  #[inline]
  pub fn Block(&self) -> Option<FunctionBlock<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FunctionBlock<'a>>>(FunctionExpression::VT_BLOCK, None)
  }
}

pub struct FunctionExpressionArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub defaults: Option<flatbuffers::WIPOffset<ObjectExpression<'a >>>,
    pub Block: Option<flatbuffers::WIPOffset<FunctionBlock<'a >>>,
}
impl<'a> Default for FunctionExpressionArgs<'a> {
    #[inline]
    fn default() -> Self {
        FunctionExpressionArgs {
            loc: None,
            defaults: None,
            Block: None,
        }
    }
}
pub struct FunctionExpressionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FunctionExpressionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(FunctionExpression::VT_LOC, loc);
  }
  #[inline]
  pub fn add_defaults(&mut self, defaults: flatbuffers::WIPOffset<ObjectExpression<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ObjectExpression>>(FunctionExpression::VT_DEFAULTS, defaults);
  }
  #[inline]
  pub fn add_Block(&mut self, Block: flatbuffers::WIPOffset<FunctionBlock<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FunctionBlock>>(FunctionExpression::VT_BLOCK, Block);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FunctionExpressionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FunctionExpressionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FunctionExpression<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FunctionBlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FunctionBlock<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FunctionBlock<'a> {
    type Inner = FunctionBlock<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FunctionBlock<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FunctionBlock {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FunctionBlockArgs<'args>) -> flatbuffers::WIPOffset<FunctionBlock<'bldr>> {
      let mut builder = FunctionBlockBuilder::new(_fbb);
      if let Some(x) = args.body { builder.add_body(x); }
      if let Some(x) = args.parameters { builder.add_parameters(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_PARAMETERS: flatbuffers::VOffsetT = 6;
    pub const VT_BODY: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(FunctionBlock::VT_LOC, None)
  }
  #[inline]
  pub fn parameters(&self) -> Option<FunctionParameters<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FunctionParameters<'a>>>(FunctionBlock::VT_PARAMETERS, None)
  }
  #[inline]
  pub fn body(&self) -> Option<Block<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Block<'a>>>(FunctionBlock::VT_BODY, None)
  }
}

pub struct FunctionBlockArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub parameters: Option<flatbuffers::WIPOffset<FunctionParameters<'a >>>,
    pub body: Option<flatbuffers::WIPOffset<Block<'a >>>,
}
impl<'a> Default for FunctionBlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        FunctionBlockArgs {
            loc: None,
            parameters: None,
            body: None,
        }
    }
}
pub struct FunctionBlockBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FunctionBlockBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(FunctionBlock::VT_LOC, loc);
  }
  #[inline]
  pub fn add_parameters(&mut self, parameters: flatbuffers::WIPOffset<FunctionParameters<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FunctionParameters>>(FunctionBlock::VT_PARAMETERS, parameters);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<Block<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Block>>(FunctionBlock::VT_BODY, body);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FunctionBlockBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FunctionBlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FunctionBlock<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FunctionParametersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FunctionParameters<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FunctionParameters<'a> {
    type Inner = FunctionParameters<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FunctionParameters<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FunctionParameters {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FunctionParametersArgs<'args>) -> flatbuffers::WIPOffset<FunctionParameters<'bldr>> {
      let mut builder = FunctionParametersBuilder::new(_fbb);
      if let Some(x) = args.pipe { builder.add_pipe(x); }
      if let Some(x) = args.list { builder.add_list(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_LIST: flatbuffers::VOffsetT = 6;
    pub const VT_PIPE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(FunctionParameters::VT_LOC, None)
  }
  #[inline]
  pub fn list(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctionParameter<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FunctionParameter<'a>>>>>(FunctionParameters::VT_LIST, None)
  }
  #[inline]
  pub fn pipe(&self) -> Option<Identifier<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(FunctionParameters::VT_PIPE, None)
  }
}

pub struct FunctionParametersArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub list: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FunctionParameter<'a >>>>>,
    pub pipe: Option<flatbuffers::WIPOffset<Identifier<'a >>>,
}
impl<'a> Default for FunctionParametersArgs<'a> {
    #[inline]
    fn default() -> Self {
        FunctionParametersArgs {
            loc: None,
            list: None,
            pipe: None,
        }
    }
}
pub struct FunctionParametersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FunctionParametersBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(FunctionParameters::VT_LOC, loc);
  }
  #[inline]
  pub fn add_list(&mut self, list: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FunctionParameter<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionParameters::VT_LIST, list);
  }
  #[inline]
  pub fn add_pipe(&mut self, pipe: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(FunctionParameters::VT_PIPE, pipe);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FunctionParametersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FunctionParametersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FunctionParameters<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FunctionParameterOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FunctionParameter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FunctionParameter<'a> {
    type Inner = FunctionParameter<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FunctionParameter<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FunctionParameter {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FunctionParameterArgs<'args>) -> flatbuffers::WIPOffset<FunctionParameter<'bldr>> {
      let mut builder = FunctionParameterBuilder::new(_fbb);
      if let Some(x) = args.key { builder.add_key(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_KEY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(FunctionParameter::VT_LOC, None)
  }
  #[inline]
  pub fn key(&self) -> Option<Identifier<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Identifier<'a>>>(FunctionParameter::VT_KEY, None)
  }
}

pub struct FunctionParameterArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub key: Option<flatbuffers::WIPOffset<Identifier<'a >>>,
}
impl<'a> Default for FunctionParameterArgs<'a> {
    #[inline]
    fn default() -> Self {
        FunctionParameterArgs {
            loc: None,
            key: None,
        }
    }
}
pub struct FunctionParameterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FunctionParameterBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(FunctionParameter::VT_LOC, loc);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(FunctionParameter::VT_KEY, key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FunctionParameterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FunctionParameterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FunctionParameter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BinaryExpressionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BinaryExpression<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryExpression<'a> {
    type Inner = BinaryExpression<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BinaryExpression<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BinaryExpression {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BinaryExpressionArgs<'args>) -> flatbuffers::WIPOffset<BinaryExpression<'bldr>> {
      let mut builder = BinaryExpressionBuilder::new(_fbb);
      if let Some(x) = args.right { builder.add_right(x); }
      if let Some(x) = args.left { builder.add_left(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.add_right_type(args.right_type);
      builder.add_left_type(args.left_type);
      builder.add_operator(args.operator);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_OPERATOR: flatbuffers::VOffsetT = 6;
    pub const VT_LEFT_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_LEFT: flatbuffers::VOffsetT = 10;
    pub const VT_RIGHT_TYPE: flatbuffers::VOffsetT = 12;
    pub const VT_RIGHT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(BinaryExpression::VT_LOC, None)
  }
  #[inline]
  pub fn operator(&self) -> Operator {
    self._tab.get::<Operator>(BinaryExpression::VT_OPERATOR, Some(Operator::MultiplicationOperator)).unwrap()
  }
  #[inline]
  pub fn left_type(&self) -> Expression {
    self._tab.get::<Expression>(BinaryExpression::VT_LEFT_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn left(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(BinaryExpression::VT_LEFT, None)
  }
  #[inline]
  pub fn right_type(&self) -> Expression {
    self._tab.get::<Expression>(BinaryExpression::VT_RIGHT_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn right(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(BinaryExpression::VT_RIGHT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.left_type() == Expression::StringExpression {
      self.left().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.left_type() == Expression::ArrayExpression {
      self.left().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.left_type() == Expression::FunctionExpression {
      self.left().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.left_type() == Expression::BinaryExpression {
      self.left().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.left_type() == Expression::CallExpression {
      self.left().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.left_type() == Expression::ConditionalExpression {
      self.left().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.left_type() == Expression::IdentifierExpression {
      self.left().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.left_type() == Expression::LogicalExpression {
      self.left().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.left_type() == Expression::MemberExpression {
      self.left().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.left_type() == Expression::IndexExpression {
      self.left().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.left_type() == Expression::ObjectExpression {
      self.left().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.left_type() == Expression::UnaryExpression {
      self.left().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.left_type() == Expression::BooleanLiteral {
      self.left().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.left_type() == Expression::DateTimeLiteral {
      self.left().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.left_type() == Expression::DurationLiteral {
      self.left().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.left_type() == Expression::FloatLiteral {
      self.left().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.left_type() == Expression::IntegerLiteral {
      self.left().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.left_type() == Expression::StringLiteral {
      self.left().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.left_type() == Expression::RegexpLiteral {
      self.left().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.left_type() == Expression::UnsignedIntegerLiteral {
      self.left().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.right_type() == Expression::StringExpression {
      self.right().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.right_type() == Expression::ArrayExpression {
      self.right().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.right_type() == Expression::FunctionExpression {
      self.right().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.right_type() == Expression::BinaryExpression {
      self.right().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.right_type() == Expression::CallExpression {
      self.right().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.right_type() == Expression::ConditionalExpression {
      self.right().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.right_type() == Expression::IdentifierExpression {
      self.right().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.right_type() == Expression::LogicalExpression {
      self.right().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.right_type() == Expression::MemberExpression {
      self.right().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.right_type() == Expression::IndexExpression {
      self.right().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.right_type() == Expression::ObjectExpression {
      self.right().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.right_type() == Expression::UnaryExpression {
      self.right().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.right_type() == Expression::BooleanLiteral {
      self.right().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.right_type() == Expression::DateTimeLiteral {
      self.right().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.right_type() == Expression::DurationLiteral {
      self.right().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.right_type() == Expression::FloatLiteral {
      self.right().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.right_type() == Expression::IntegerLiteral {
      self.right().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.right_type() == Expression::StringLiteral {
      self.right().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.right_type() == Expression::RegexpLiteral {
      self.right().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.right_type() == Expression::UnsignedIntegerLiteral {
      self.right().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct BinaryExpressionArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub operator: Operator,
    pub left_type: Expression,
    pub left: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub right_type: Expression,
    pub right: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for BinaryExpressionArgs<'a> {
    #[inline]
    fn default() -> Self {
        BinaryExpressionArgs {
            loc: None,
            operator: Operator::MultiplicationOperator,
            left_type: Expression::NONE,
            left: None,
            right_type: Expression::NONE,
            right: None,
        }
    }
}
pub struct BinaryExpressionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BinaryExpressionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(BinaryExpression::VT_LOC, loc);
  }
  #[inline]
  pub fn add_operator(&mut self, operator: Operator) {
    self.fbb_.push_slot::<Operator>(BinaryExpression::VT_OPERATOR, operator, Operator::MultiplicationOperator);
  }
  #[inline]
  pub fn add_left_type(&mut self, left_type: Expression) {
    self.fbb_.push_slot::<Expression>(BinaryExpression::VT_LEFT_TYPE, left_type, Expression::NONE);
  }
  #[inline]
  pub fn add_left(&mut self, left: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryExpression::VT_LEFT, left);
  }
  #[inline]
  pub fn add_right_type(&mut self, right_type: Expression) {
    self.fbb_.push_slot::<Expression>(BinaryExpression::VT_RIGHT_TYPE, right_type, Expression::NONE);
  }
  #[inline]
  pub fn add_right(&mut self, right: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryExpression::VT_RIGHT, right);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BinaryExpressionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BinaryExpressionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryExpression<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CallExpressionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CallExpression<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CallExpression<'a> {
    type Inner = CallExpression<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CallExpression<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CallExpression {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CallExpressionArgs<'args>) -> flatbuffers::WIPOffset<CallExpression<'bldr>> {
      let mut builder = CallExpressionBuilder::new(_fbb);
      if let Some(x) = args.pipe { builder.add_pipe(x); }
      if let Some(x) = args.arguments { builder.add_arguments(x); }
      if let Some(x) = args.callee { builder.add_callee(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.add_pipe_type(args.pipe_type);
      builder.add_callee_type(args.callee_type);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_CALLEE_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_CALLEE: flatbuffers::VOffsetT = 8;
    pub const VT_ARGUMENTS: flatbuffers::VOffsetT = 10;
    pub const VT_PIPE_TYPE: flatbuffers::VOffsetT = 12;
    pub const VT_PIPE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(CallExpression::VT_LOC, None)
  }
  #[inline]
  pub fn callee_type(&self) -> Expression {
    self._tab.get::<Expression>(CallExpression::VT_CALLEE_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn callee(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(CallExpression::VT_CALLEE, None)
  }
  #[inline]
  pub fn arguments(&self) -> Option<ObjectExpression<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<ObjectExpression<'a>>>(CallExpression::VT_ARGUMENTS, None)
  }
  #[inline]
  pub fn pipe_type(&self) -> Expression {
    self._tab.get::<Expression>(CallExpression::VT_PIPE_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn pipe(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(CallExpression::VT_PIPE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.callee_type() == Expression::StringExpression {
      self.callee().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.callee_type() == Expression::ArrayExpression {
      self.callee().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.callee_type() == Expression::FunctionExpression {
      self.callee().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.callee_type() == Expression::BinaryExpression {
      self.callee().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.callee_type() == Expression::CallExpression {
      self.callee().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.callee_type() == Expression::ConditionalExpression {
      self.callee().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.callee_type() == Expression::IdentifierExpression {
      self.callee().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.callee_type() == Expression::LogicalExpression {
      self.callee().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.callee_type() == Expression::MemberExpression {
      self.callee().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.callee_type() == Expression::IndexExpression {
      self.callee().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.callee_type() == Expression::ObjectExpression {
      self.callee().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.callee_type() == Expression::UnaryExpression {
      self.callee().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.callee_type() == Expression::BooleanLiteral {
      self.callee().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.callee_type() == Expression::DateTimeLiteral {
      self.callee().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.callee_type() == Expression::DurationLiteral {
      self.callee().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.callee_type() == Expression::FloatLiteral {
      self.callee().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.callee_type() == Expression::IntegerLiteral {
      self.callee().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.callee_type() == Expression::StringLiteral {
      self.callee().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.callee_type() == Expression::RegexpLiteral {
      self.callee().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn callee_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.callee_type() == Expression::UnsignedIntegerLiteral {
      self.callee().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.pipe_type() == Expression::StringExpression {
      self.pipe().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.pipe_type() == Expression::ArrayExpression {
      self.pipe().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.pipe_type() == Expression::FunctionExpression {
      self.pipe().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.pipe_type() == Expression::BinaryExpression {
      self.pipe().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.pipe_type() == Expression::CallExpression {
      self.pipe().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.pipe_type() == Expression::ConditionalExpression {
      self.pipe().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.pipe_type() == Expression::IdentifierExpression {
      self.pipe().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.pipe_type() == Expression::LogicalExpression {
      self.pipe().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.pipe_type() == Expression::MemberExpression {
      self.pipe().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.pipe_type() == Expression::IndexExpression {
      self.pipe().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.pipe_type() == Expression::ObjectExpression {
      self.pipe().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.pipe_type() == Expression::UnaryExpression {
      self.pipe().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.pipe_type() == Expression::BooleanLiteral {
      self.pipe().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.pipe_type() == Expression::DateTimeLiteral {
      self.pipe().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.pipe_type() == Expression::DurationLiteral {
      self.pipe().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.pipe_type() == Expression::FloatLiteral {
      self.pipe().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.pipe_type() == Expression::IntegerLiteral {
      self.pipe().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.pipe_type() == Expression::StringLiteral {
      self.pipe().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.pipe_type() == Expression::RegexpLiteral {
      self.pipe().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn pipe_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.pipe_type() == Expression::UnsignedIntegerLiteral {
      self.pipe().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct CallExpressionArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub callee_type: Expression,
    pub callee: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub arguments: Option<flatbuffers::WIPOffset<ObjectExpression<'a >>>,
    pub pipe_type: Expression,
    pub pipe: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for CallExpressionArgs<'a> {
    #[inline]
    fn default() -> Self {
        CallExpressionArgs {
            loc: None,
            callee_type: Expression::NONE,
            callee: None,
            arguments: None,
            pipe_type: Expression::NONE,
            pipe: None,
        }
    }
}
pub struct CallExpressionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CallExpressionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(CallExpression::VT_LOC, loc);
  }
  #[inline]
  pub fn add_callee_type(&mut self, callee_type: Expression) {
    self.fbb_.push_slot::<Expression>(CallExpression::VT_CALLEE_TYPE, callee_type, Expression::NONE);
  }
  #[inline]
  pub fn add_callee(&mut self, callee: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CallExpression::VT_CALLEE, callee);
  }
  #[inline]
  pub fn add_arguments(&mut self, arguments: flatbuffers::WIPOffset<ObjectExpression<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ObjectExpression>>(CallExpression::VT_ARGUMENTS, arguments);
  }
  #[inline]
  pub fn add_pipe_type(&mut self, pipe_type: Expression) {
    self.fbb_.push_slot::<Expression>(CallExpression::VT_PIPE_TYPE, pipe_type, Expression::NONE);
  }
  #[inline]
  pub fn add_pipe(&mut self, pipe: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CallExpression::VT_PIPE, pipe);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CallExpressionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CallExpressionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CallExpression<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ConditionalExpressionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ConditionalExpression<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConditionalExpression<'a> {
    type Inner = ConditionalExpression<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ConditionalExpression<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConditionalExpression {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConditionalExpressionArgs<'args>) -> flatbuffers::WIPOffset<ConditionalExpression<'bldr>> {
      let mut builder = ConditionalExpressionBuilder::new(_fbb);
      if let Some(x) = args.consequent { builder.add_consequent(x); }
      if let Some(x) = args.alternate { builder.add_alternate(x); }
      if let Some(x) = args.test { builder.add_test(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.add_consequent_type(args.consequent_type);
      builder.add_alternate_type(args.alternate_type);
      builder.add_test_type(args.test_type);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_TEST_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_TEST: flatbuffers::VOffsetT = 8;
    pub const VT_ALTERNATE_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_ALTERNATE: flatbuffers::VOffsetT = 12;
    pub const VT_CONSEQUENT_TYPE: flatbuffers::VOffsetT = 14;
    pub const VT_CONSEQUENT: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(ConditionalExpression::VT_LOC, None)
  }
  #[inline]
  pub fn test_type(&self) -> Expression {
    self._tab.get::<Expression>(ConditionalExpression::VT_TEST_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn test(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ConditionalExpression::VT_TEST, None)
  }
  #[inline]
  pub fn alternate_type(&self) -> Expression {
    self._tab.get::<Expression>(ConditionalExpression::VT_ALTERNATE_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn alternate(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ConditionalExpression::VT_ALTERNATE, None)
  }
  #[inline]
  pub fn consequent_type(&self) -> Expression {
    self._tab.get::<Expression>(ConditionalExpression::VT_CONSEQUENT_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn consequent(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ConditionalExpression::VT_CONSEQUENT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.test_type() == Expression::StringExpression {
      self.test().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.test_type() == Expression::ArrayExpression {
      self.test().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.test_type() == Expression::FunctionExpression {
      self.test().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.test_type() == Expression::BinaryExpression {
      self.test().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.test_type() == Expression::CallExpression {
      self.test().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.test_type() == Expression::ConditionalExpression {
      self.test().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.test_type() == Expression::IdentifierExpression {
      self.test().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.test_type() == Expression::LogicalExpression {
      self.test().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.test_type() == Expression::MemberExpression {
      self.test().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.test_type() == Expression::IndexExpression {
      self.test().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.test_type() == Expression::ObjectExpression {
      self.test().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.test_type() == Expression::UnaryExpression {
      self.test().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.test_type() == Expression::BooleanLiteral {
      self.test().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.test_type() == Expression::DateTimeLiteral {
      self.test().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.test_type() == Expression::DurationLiteral {
      self.test().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.test_type() == Expression::FloatLiteral {
      self.test().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.test_type() == Expression::IntegerLiteral {
      self.test().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.test_type() == Expression::StringLiteral {
      self.test().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.test_type() == Expression::RegexpLiteral {
      self.test().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.test_type() == Expression::UnsignedIntegerLiteral {
      self.test().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.alternate_type() == Expression::StringExpression {
      self.alternate().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.alternate_type() == Expression::ArrayExpression {
      self.alternate().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.alternate_type() == Expression::FunctionExpression {
      self.alternate().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.alternate_type() == Expression::BinaryExpression {
      self.alternate().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.alternate_type() == Expression::CallExpression {
      self.alternate().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.alternate_type() == Expression::ConditionalExpression {
      self.alternate().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.alternate_type() == Expression::IdentifierExpression {
      self.alternate().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.alternate_type() == Expression::LogicalExpression {
      self.alternate().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.alternate_type() == Expression::MemberExpression {
      self.alternate().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.alternate_type() == Expression::IndexExpression {
      self.alternate().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.alternate_type() == Expression::ObjectExpression {
      self.alternate().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.alternate_type() == Expression::UnaryExpression {
      self.alternate().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.alternate_type() == Expression::BooleanLiteral {
      self.alternate().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.alternate_type() == Expression::DateTimeLiteral {
      self.alternate().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.alternate_type() == Expression::DurationLiteral {
      self.alternate().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.alternate_type() == Expression::FloatLiteral {
      self.alternate().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.alternate_type() == Expression::IntegerLiteral {
      self.alternate().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.alternate_type() == Expression::StringLiteral {
      self.alternate().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.alternate_type() == Expression::RegexpLiteral {
      self.alternate().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn alternate_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.alternate_type() == Expression::UnsignedIntegerLiteral {
      self.alternate().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.consequent_type() == Expression::StringExpression {
      self.consequent().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.consequent_type() == Expression::ArrayExpression {
      self.consequent().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.consequent_type() == Expression::FunctionExpression {
      self.consequent().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.consequent_type() == Expression::BinaryExpression {
      self.consequent().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.consequent_type() == Expression::CallExpression {
      self.consequent().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.consequent_type() == Expression::ConditionalExpression {
      self.consequent().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.consequent_type() == Expression::IdentifierExpression {
      self.consequent().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.consequent_type() == Expression::LogicalExpression {
      self.consequent().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.consequent_type() == Expression::MemberExpression {
      self.consequent().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.consequent_type() == Expression::IndexExpression {
      self.consequent().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.consequent_type() == Expression::ObjectExpression {
      self.consequent().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.consequent_type() == Expression::UnaryExpression {
      self.consequent().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.consequent_type() == Expression::BooleanLiteral {
      self.consequent().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.consequent_type() == Expression::DateTimeLiteral {
      self.consequent().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.consequent_type() == Expression::DurationLiteral {
      self.consequent().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.consequent_type() == Expression::FloatLiteral {
      self.consequent().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.consequent_type() == Expression::IntegerLiteral {
      self.consequent().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.consequent_type() == Expression::StringLiteral {
      self.consequent().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.consequent_type() == Expression::RegexpLiteral {
      self.consequent().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn consequent_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.consequent_type() == Expression::UnsignedIntegerLiteral {
      self.consequent().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct ConditionalExpressionArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub test_type: Expression,
    pub test: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub alternate_type: Expression,
    pub alternate: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub consequent_type: Expression,
    pub consequent: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ConditionalExpressionArgs<'a> {
    #[inline]
    fn default() -> Self {
        ConditionalExpressionArgs {
            loc: None,
            test_type: Expression::NONE,
            test: None,
            alternate_type: Expression::NONE,
            alternate: None,
            consequent_type: Expression::NONE,
            consequent: None,
        }
    }
}
pub struct ConditionalExpressionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConditionalExpressionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(ConditionalExpression::VT_LOC, loc);
  }
  #[inline]
  pub fn add_test_type(&mut self, test_type: Expression) {
    self.fbb_.push_slot::<Expression>(ConditionalExpression::VT_TEST_TYPE, test_type, Expression::NONE);
  }
  #[inline]
  pub fn add_test(&mut self, test: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConditionalExpression::VT_TEST, test);
  }
  #[inline]
  pub fn add_alternate_type(&mut self, alternate_type: Expression) {
    self.fbb_.push_slot::<Expression>(ConditionalExpression::VT_ALTERNATE_TYPE, alternate_type, Expression::NONE);
  }
  #[inline]
  pub fn add_alternate(&mut self, alternate: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConditionalExpression::VT_ALTERNATE, alternate);
  }
  #[inline]
  pub fn add_consequent_type(&mut self, consequent_type: Expression) {
    self.fbb_.push_slot::<Expression>(ConditionalExpression::VT_CONSEQUENT_TYPE, consequent_type, Expression::NONE);
  }
  #[inline]
  pub fn add_consequent(&mut self, consequent: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConditionalExpression::VT_CONSEQUENT, consequent);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConditionalExpressionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConditionalExpressionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConditionalExpression<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum LogicalExpressionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct LogicalExpression<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogicalExpression<'a> {
    type Inner = LogicalExpression<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> LogicalExpression<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LogicalExpression {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args LogicalExpressionArgs<'args>) -> flatbuffers::WIPOffset<LogicalExpression<'bldr>> {
      let mut builder = LogicalExpressionBuilder::new(_fbb);
      if let Some(x) = args.right { builder.add_right(x); }
      if let Some(x) = args.left { builder.add_left(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.add_right_type(args.right_type);
      builder.add_left_type(args.left_type);
      builder.add_operator(args.operator);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_OPERATOR: flatbuffers::VOffsetT = 6;
    pub const VT_LEFT_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_LEFT: flatbuffers::VOffsetT = 10;
    pub const VT_RIGHT_TYPE: flatbuffers::VOffsetT = 12;
    pub const VT_RIGHT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(LogicalExpression::VT_LOC, None)
  }
  #[inline]
  pub fn operator(&self) -> LogicalOperator {
    self._tab.get::<LogicalOperator>(LogicalExpression::VT_OPERATOR, Some(LogicalOperator::AndOperator)).unwrap()
  }
  #[inline]
  pub fn left_type(&self) -> Expression {
    self._tab.get::<Expression>(LogicalExpression::VT_LEFT_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn left(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(LogicalExpression::VT_LEFT, None)
  }
  #[inline]
  pub fn right_type(&self) -> Expression {
    self._tab.get::<Expression>(LogicalExpression::VT_RIGHT_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn right(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(LogicalExpression::VT_RIGHT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.left_type() == Expression::StringExpression {
      self.left().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.left_type() == Expression::ArrayExpression {
      self.left().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.left_type() == Expression::FunctionExpression {
      self.left().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.left_type() == Expression::BinaryExpression {
      self.left().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.left_type() == Expression::CallExpression {
      self.left().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.left_type() == Expression::ConditionalExpression {
      self.left().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.left_type() == Expression::IdentifierExpression {
      self.left().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.left_type() == Expression::LogicalExpression {
      self.left().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.left_type() == Expression::MemberExpression {
      self.left().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.left_type() == Expression::IndexExpression {
      self.left().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.left_type() == Expression::ObjectExpression {
      self.left().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.left_type() == Expression::UnaryExpression {
      self.left().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.left_type() == Expression::BooleanLiteral {
      self.left().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.left_type() == Expression::DateTimeLiteral {
      self.left().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.left_type() == Expression::DurationLiteral {
      self.left().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.left_type() == Expression::FloatLiteral {
      self.left().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.left_type() == Expression::IntegerLiteral {
      self.left().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.left_type() == Expression::StringLiteral {
      self.left().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.left_type() == Expression::RegexpLiteral {
      self.left().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.left_type() == Expression::UnsignedIntegerLiteral {
      self.left().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.right_type() == Expression::StringExpression {
      self.right().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.right_type() == Expression::ArrayExpression {
      self.right().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.right_type() == Expression::FunctionExpression {
      self.right().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.right_type() == Expression::BinaryExpression {
      self.right().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.right_type() == Expression::CallExpression {
      self.right().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.right_type() == Expression::ConditionalExpression {
      self.right().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.right_type() == Expression::IdentifierExpression {
      self.right().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.right_type() == Expression::LogicalExpression {
      self.right().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.right_type() == Expression::MemberExpression {
      self.right().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.right_type() == Expression::IndexExpression {
      self.right().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.right_type() == Expression::ObjectExpression {
      self.right().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.right_type() == Expression::UnaryExpression {
      self.right().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.right_type() == Expression::BooleanLiteral {
      self.right().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.right_type() == Expression::DateTimeLiteral {
      self.right().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.right_type() == Expression::DurationLiteral {
      self.right().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.right_type() == Expression::FloatLiteral {
      self.right().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.right_type() == Expression::IntegerLiteral {
      self.right().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.right_type() == Expression::StringLiteral {
      self.right().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.right_type() == Expression::RegexpLiteral {
      self.right().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.right_type() == Expression::UnsignedIntegerLiteral {
      self.right().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct LogicalExpressionArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub operator: LogicalOperator,
    pub left_type: Expression,
    pub left: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub right_type: Expression,
    pub right: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for LogicalExpressionArgs<'a> {
    #[inline]
    fn default() -> Self {
        LogicalExpressionArgs {
            loc: None,
            operator: LogicalOperator::AndOperator,
            left_type: Expression::NONE,
            left: None,
            right_type: Expression::NONE,
            right: None,
        }
    }
}
pub struct LogicalExpressionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LogicalExpressionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(LogicalExpression::VT_LOC, loc);
  }
  #[inline]
  pub fn add_operator(&mut self, operator: LogicalOperator) {
    self.fbb_.push_slot::<LogicalOperator>(LogicalExpression::VT_OPERATOR, operator, LogicalOperator::AndOperator);
  }
  #[inline]
  pub fn add_left_type(&mut self, left_type: Expression) {
    self.fbb_.push_slot::<Expression>(LogicalExpression::VT_LEFT_TYPE, left_type, Expression::NONE);
  }
  #[inline]
  pub fn add_left(&mut self, left: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogicalExpression::VT_LEFT, left);
  }
  #[inline]
  pub fn add_right_type(&mut self, right_type: Expression) {
    self.fbb_.push_slot::<Expression>(LogicalExpression::VT_RIGHT_TYPE, right_type, Expression::NONE);
  }
  #[inline]
  pub fn add_right(&mut self, right: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogicalExpression::VT_RIGHT, right);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LogicalExpressionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LogicalExpressionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogicalExpression<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum MemberExpressionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct MemberExpression<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MemberExpression<'a> {
    type Inner = MemberExpression<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> MemberExpression<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MemberExpression {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MemberExpressionArgs<'args>) -> flatbuffers::WIPOffset<MemberExpression<'bldr>> {
      let mut builder = MemberExpressionBuilder::new(_fbb);
      if let Some(x) = args.property { builder.add_property(x); }
      if let Some(x) = args.object { builder.add_object(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.add_object_type(args.object_type);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_OBJECT_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_OBJECT: flatbuffers::VOffsetT = 8;
    pub const VT_PROPERTY: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(MemberExpression::VT_LOC, None)
  }
  #[inline]
  pub fn object_type(&self) -> Expression {
    self._tab.get::<Expression>(MemberExpression::VT_OBJECT_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn object(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(MemberExpression::VT_OBJECT, None)
  }
  #[inline]
  pub fn property(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MemberExpression::VT_PROPERTY, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.object_type() == Expression::StringExpression {
      self.object().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.object_type() == Expression::ArrayExpression {
      self.object().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.object_type() == Expression::FunctionExpression {
      self.object().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.object_type() == Expression::BinaryExpression {
      self.object().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.object_type() == Expression::CallExpression {
      self.object().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.object_type() == Expression::ConditionalExpression {
      self.object().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.object_type() == Expression::IdentifierExpression {
      self.object().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.object_type() == Expression::LogicalExpression {
      self.object().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.object_type() == Expression::MemberExpression {
      self.object().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.object_type() == Expression::IndexExpression {
      self.object().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.object_type() == Expression::ObjectExpression {
      self.object().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.object_type() == Expression::UnaryExpression {
      self.object().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.object_type() == Expression::BooleanLiteral {
      self.object().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.object_type() == Expression::DateTimeLiteral {
      self.object().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.object_type() == Expression::DurationLiteral {
      self.object().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.object_type() == Expression::FloatLiteral {
      self.object().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.object_type() == Expression::IntegerLiteral {
      self.object().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.object_type() == Expression::StringLiteral {
      self.object().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.object_type() == Expression::RegexpLiteral {
      self.object().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn object_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.object_type() == Expression::UnsignedIntegerLiteral {
      self.object().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct MemberExpressionArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub object_type: Expression,
    pub object: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub property: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for MemberExpressionArgs<'a> {
    #[inline]
    fn default() -> Self {
        MemberExpressionArgs {
            loc: None,
            object_type: Expression::NONE,
            object: None,
            property: None,
        }
    }
}
pub struct MemberExpressionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MemberExpressionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(MemberExpression::VT_LOC, loc);
  }
  #[inline]
  pub fn add_object_type(&mut self, object_type: Expression) {
    self.fbb_.push_slot::<Expression>(MemberExpression::VT_OBJECT_TYPE, object_type, Expression::NONE);
  }
  #[inline]
  pub fn add_object(&mut self, object: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MemberExpression::VT_OBJECT, object);
  }
  #[inline]
  pub fn add_property(&mut self, property: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MemberExpression::VT_PROPERTY, property);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MemberExpressionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MemberExpressionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MemberExpression<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IndexExpressionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IndexExpression<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IndexExpression<'a> {
    type Inner = IndexExpression<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IndexExpression<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IndexExpression {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IndexExpressionArgs<'args>) -> flatbuffers::WIPOffset<IndexExpression<'bldr>> {
      let mut builder = IndexExpressionBuilder::new(_fbb);
      if let Some(x) = args.index { builder.add_index(x); }
      if let Some(x) = args.array { builder.add_array(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.add_index_type(args.index_type);
      builder.add_array_type(args.array_type);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_ARRAY_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_ARRAY: flatbuffers::VOffsetT = 8;
    pub const VT_INDEX_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_INDEX: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(IndexExpression::VT_LOC, None)
  }
  #[inline]
  pub fn array_type(&self) -> Expression {
    self._tab.get::<Expression>(IndexExpression::VT_ARRAY_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn array(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(IndexExpression::VT_ARRAY, None)
  }
  #[inline]
  pub fn index_type(&self) -> Expression {
    self._tab.get::<Expression>(IndexExpression::VT_INDEX_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn index(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(IndexExpression::VT_INDEX, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.array_type() == Expression::StringExpression {
      self.array().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.array_type() == Expression::ArrayExpression {
      self.array().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.array_type() == Expression::FunctionExpression {
      self.array().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.array_type() == Expression::BinaryExpression {
      self.array().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.array_type() == Expression::CallExpression {
      self.array().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.array_type() == Expression::ConditionalExpression {
      self.array().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.array_type() == Expression::IdentifierExpression {
      self.array().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.array_type() == Expression::LogicalExpression {
      self.array().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.array_type() == Expression::MemberExpression {
      self.array().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.array_type() == Expression::IndexExpression {
      self.array().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.array_type() == Expression::ObjectExpression {
      self.array().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.array_type() == Expression::UnaryExpression {
      self.array().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.array_type() == Expression::BooleanLiteral {
      self.array().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.array_type() == Expression::DateTimeLiteral {
      self.array().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.array_type() == Expression::DurationLiteral {
      self.array().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.array_type() == Expression::FloatLiteral {
      self.array().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.array_type() == Expression::IntegerLiteral {
      self.array().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.array_type() == Expression::StringLiteral {
      self.array().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.array_type() == Expression::RegexpLiteral {
      self.array().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.array_type() == Expression::UnsignedIntegerLiteral {
      self.array().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.index_type() == Expression::StringExpression {
      self.index().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.index_type() == Expression::ArrayExpression {
      self.index().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.index_type() == Expression::FunctionExpression {
      self.index().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.index_type() == Expression::BinaryExpression {
      self.index().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.index_type() == Expression::CallExpression {
      self.index().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.index_type() == Expression::ConditionalExpression {
      self.index().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.index_type() == Expression::IdentifierExpression {
      self.index().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.index_type() == Expression::LogicalExpression {
      self.index().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.index_type() == Expression::MemberExpression {
      self.index().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.index_type() == Expression::IndexExpression {
      self.index().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.index_type() == Expression::ObjectExpression {
      self.index().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.index_type() == Expression::UnaryExpression {
      self.index().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.index_type() == Expression::BooleanLiteral {
      self.index().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.index_type() == Expression::DateTimeLiteral {
      self.index().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.index_type() == Expression::DurationLiteral {
      self.index().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.index_type() == Expression::FloatLiteral {
      self.index().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.index_type() == Expression::IntegerLiteral {
      self.index().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.index_type() == Expression::StringLiteral {
      self.index().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.index_type() == Expression::RegexpLiteral {
      self.index().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn index_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.index_type() == Expression::UnsignedIntegerLiteral {
      self.index().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct IndexExpressionArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub array_type: Expression,
    pub array: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub index_type: Expression,
    pub index: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for IndexExpressionArgs<'a> {
    #[inline]
    fn default() -> Self {
        IndexExpressionArgs {
            loc: None,
            array_type: Expression::NONE,
            array: None,
            index_type: Expression::NONE,
            index: None,
        }
    }
}
pub struct IndexExpressionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IndexExpressionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(IndexExpression::VT_LOC, loc);
  }
  #[inline]
  pub fn add_array_type(&mut self, array_type: Expression) {
    self.fbb_.push_slot::<Expression>(IndexExpression::VT_ARRAY_TYPE, array_type, Expression::NONE);
  }
  #[inline]
  pub fn add_array(&mut self, array: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IndexExpression::VT_ARRAY, array);
  }
  #[inline]
  pub fn add_index_type(&mut self, index_type: Expression) {
    self.fbb_.push_slot::<Expression>(IndexExpression::VT_INDEX_TYPE, index_type, Expression::NONE);
  }
  #[inline]
  pub fn add_index(&mut self, index: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IndexExpression::VT_INDEX, index);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IndexExpressionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IndexExpressionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IndexExpression<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ObjectExpressionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ObjectExpression<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ObjectExpression<'a> {
    type Inner = ObjectExpression<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ObjectExpression<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ObjectExpression {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ObjectExpressionArgs<'args>) -> flatbuffers::WIPOffset<ObjectExpression<'bldr>> {
      let mut builder = ObjectExpressionBuilder::new(_fbb);
      if let Some(x) = args.properties { builder.add_properties(x); }
      if let Some(x) = args.with { builder.add_with(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_WITH: flatbuffers::VOffsetT = 6;
    pub const VT_PROPERTIES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(ObjectExpression::VT_LOC, None)
  }
  #[inline]
  pub fn with(&self) -> Option<IdentifierExpression<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<IdentifierExpression<'a>>>(ObjectExpression::VT_WITH, None)
  }
  #[inline]
  pub fn properties(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Property<'a>>>>>(ObjectExpression::VT_PROPERTIES, None)
  }
}

pub struct ObjectExpressionArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub with: Option<flatbuffers::WIPOffset<IdentifierExpression<'a >>>,
    pub properties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Property<'a >>>>>,
}
impl<'a> Default for ObjectExpressionArgs<'a> {
    #[inline]
    fn default() -> Self {
        ObjectExpressionArgs {
            loc: None,
            with: None,
            properties: None,
        }
    }
}
pub struct ObjectExpressionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ObjectExpressionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(ObjectExpression::VT_LOC, loc);
  }
  #[inline]
  pub fn add_with(&mut self, with: flatbuffers::WIPOffset<IdentifierExpression<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IdentifierExpression>>(ObjectExpression::VT_WITH, with);
  }
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Property<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ObjectExpression::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ObjectExpressionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ObjectExpressionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ObjectExpression<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum UnaryExpressionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct UnaryExpression<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnaryExpression<'a> {
    type Inner = UnaryExpression<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> UnaryExpression<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UnaryExpression {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UnaryExpressionArgs<'args>) -> flatbuffers::WIPOffset<UnaryExpression<'bldr>> {
      let mut builder = UnaryExpressionBuilder::new(_fbb);
      if let Some(x) = args.argument { builder.add_argument(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.add_argument_type(args.argument_type);
      builder.add_operator(args.operator);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_OPERATOR: flatbuffers::VOffsetT = 6;
    pub const VT_ARGUMENT_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_ARGUMENT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(UnaryExpression::VT_LOC, None)
  }
  #[inline]
  pub fn operator(&self) -> Operator {
    self._tab.get::<Operator>(UnaryExpression::VT_OPERATOR, Some(Operator::MultiplicationOperator)).unwrap()
  }
  #[inline]
  pub fn argument_type(&self) -> Expression {
    self._tab.get::<Expression>(UnaryExpression::VT_ARGUMENT_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn argument(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(UnaryExpression::VT_ARGUMENT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.argument_type() == Expression::StringExpression {
      self.argument().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.argument_type() == Expression::ArrayExpression {
      self.argument().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.argument_type() == Expression::FunctionExpression {
      self.argument().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.argument_type() == Expression::BinaryExpression {
      self.argument().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.argument_type() == Expression::CallExpression {
      self.argument().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.argument_type() == Expression::ConditionalExpression {
      self.argument().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.argument_type() == Expression::IdentifierExpression {
      self.argument().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.argument_type() == Expression::LogicalExpression {
      self.argument().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.argument_type() == Expression::MemberExpression {
      self.argument().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.argument_type() == Expression::IndexExpression {
      self.argument().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.argument_type() == Expression::ObjectExpression {
      self.argument().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.argument_type() == Expression::UnaryExpression {
      self.argument().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.argument_type() == Expression::BooleanLiteral {
      self.argument().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.argument_type() == Expression::DateTimeLiteral {
      self.argument().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.argument_type() == Expression::DurationLiteral {
      self.argument().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.argument_type() == Expression::FloatLiteral {
      self.argument().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.argument_type() == Expression::IntegerLiteral {
      self.argument().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.argument_type() == Expression::StringLiteral {
      self.argument().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.argument_type() == Expression::RegexpLiteral {
      self.argument().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn argument_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.argument_type() == Expression::UnsignedIntegerLiteral {
      self.argument().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct UnaryExpressionArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub operator: Operator,
    pub argument_type: Expression,
    pub argument: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for UnaryExpressionArgs<'a> {
    #[inline]
    fn default() -> Self {
        UnaryExpressionArgs {
            loc: None,
            operator: Operator::MultiplicationOperator,
            argument_type: Expression::NONE,
            argument: None,
        }
    }
}
pub struct UnaryExpressionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnaryExpressionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(UnaryExpression::VT_LOC, loc);
  }
  #[inline]
  pub fn add_operator(&mut self, operator: Operator) {
    self.fbb_.push_slot::<Operator>(UnaryExpression::VT_OPERATOR, operator, Operator::MultiplicationOperator);
  }
  #[inline]
  pub fn add_argument_type(&mut self, argument_type: Expression) {
    self.fbb_.push_slot::<Expression>(UnaryExpression::VT_ARGUMENT_TYPE, argument_type, Expression::NONE);
  }
  #[inline]
  pub fn add_argument(&mut self, argument: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnaryExpression::VT_ARGUMENT, argument);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnaryExpressionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnaryExpressionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnaryExpression<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PropertyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Property<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Property<'a> {
    type Inner = Property<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Property<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Property {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PropertyArgs<'args>) -> flatbuffers::WIPOffset<Property<'bldr>> {
      let mut builder = PropertyBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.key { builder.add_key(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.add_value_type(args.value_type);
      builder.add_key_type(args.key_type);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_KEY_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_KEY: flatbuffers::VOffsetT = 8;
    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_VALUE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(Property::VT_LOC, None)
  }
  #[inline]
  pub fn key_type(&self) -> PropertyKey {
    self._tab.get::<PropertyKey>(Property::VT_KEY_TYPE, Some(PropertyKey::NONE)).unwrap()
  }
  #[inline]
  pub fn key(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Property::VT_KEY, None)
  }
  #[inline]
  pub fn value_type(&self) -> Expression {
    self._tab.get::<Expression>(Property::VT_VALUE_TYPE, Some(Expression::NONE)).unwrap()
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Property::VT_VALUE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn key_as_identifier(&self) -> Option<Identifier<'a>> {
    if self.key_type() == PropertyKey::Identifier {
      self.key().map(|u| Identifier::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn key_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.key_type() == PropertyKey::StringLiteral {
      self.key().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_string_expression(&self) -> Option<StringExpression<'a>> {
    if self.value_type() == Expression::StringExpression {
      self.value().map(|u| StringExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_array_expression(&self) -> Option<ArrayExpression<'a>> {
    if self.value_type() == Expression::ArrayExpression {
      self.value().map(|u| ArrayExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_function_expression(&self) -> Option<FunctionExpression<'a>> {
    if self.value_type() == Expression::FunctionExpression {
      self.value().map(|u| FunctionExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_binary_expression(&self) -> Option<BinaryExpression<'a>> {
    if self.value_type() == Expression::BinaryExpression {
      self.value().map(|u| BinaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_call_expression(&self) -> Option<CallExpression<'a>> {
    if self.value_type() == Expression::CallExpression {
      self.value().map(|u| CallExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_conditional_expression(&self) -> Option<ConditionalExpression<'a>> {
    if self.value_type() == Expression::ConditionalExpression {
      self.value().map(|u| ConditionalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_identifier_expression(&self) -> Option<IdentifierExpression<'a>> {
    if self.value_type() == Expression::IdentifierExpression {
      self.value().map(|u| IdentifierExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_logical_expression(&self) -> Option<LogicalExpression<'a>> {
    if self.value_type() == Expression::LogicalExpression {
      self.value().map(|u| LogicalExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_member_expression(&self) -> Option<MemberExpression<'a>> {
    if self.value_type() == Expression::MemberExpression {
      self.value().map(|u| MemberExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_index_expression(&self) -> Option<IndexExpression<'a>> {
    if self.value_type() == Expression::IndexExpression {
      self.value().map(|u| IndexExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_object_expression(&self) -> Option<ObjectExpression<'a>> {
    if self.value_type() == Expression::ObjectExpression {
      self.value().map(|u| ObjectExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_unary_expression(&self) -> Option<UnaryExpression<'a>> {
    if self.value_type() == Expression::UnaryExpression {
      self.value().map(|u| UnaryExpression::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_boolean_literal(&self) -> Option<BooleanLiteral<'a>> {
    if self.value_type() == Expression::BooleanLiteral {
      self.value().map(|u| BooleanLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_date_time_literal(&self) -> Option<DateTimeLiteral<'a>> {
    if self.value_type() == Expression::DateTimeLiteral {
      self.value().map(|u| DateTimeLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_duration_literal(&self) -> Option<DurationLiteral<'a>> {
    if self.value_type() == Expression::DurationLiteral {
      self.value().map(|u| DurationLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_float_literal(&self) -> Option<FloatLiteral<'a>> {
    if self.value_type() == Expression::FloatLiteral {
      self.value().map(|u| FloatLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_integer_literal(&self) -> Option<IntegerLiteral<'a>> {
    if self.value_type() == Expression::IntegerLiteral {
      self.value().map(|u| IntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_string_literal(&self) -> Option<StringLiteral<'a>> {
    if self.value_type() == Expression::StringLiteral {
      self.value().map(|u| StringLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_regexp_literal(&self) -> Option<RegexpLiteral<'a>> {
    if self.value_type() == Expression::RegexpLiteral {
      self.value().map(|u| RegexpLiteral::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_unsigned_integer_literal(&self) -> Option<UnsignedIntegerLiteral<'a>> {
    if self.value_type() == Expression::UnsignedIntegerLiteral {
      self.value().map(|u| UnsignedIntegerLiteral::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct PropertyArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub key_type: PropertyKey,
    pub key: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub value_type: Expression,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for PropertyArgs<'a> {
    #[inline]
    fn default() -> Self {
        PropertyArgs {
            loc: None,
            key_type: PropertyKey::NONE,
            key: None,
            value_type: Expression::NONE,
            value: None,
        }
    }
}
pub struct PropertyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PropertyBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(Property::VT_LOC, loc);
  }
  #[inline]
  pub fn add_key_type(&mut self, key_type: PropertyKey) {
    self.fbb_.push_slot::<PropertyKey>(Property::VT_KEY_TYPE, key_type, PropertyKey::NONE);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Property::VT_KEY, key);
  }
  #[inline]
  pub fn add_value_type(&mut self, value_type: Expression) {
    self.fbb_.push_slot::<Expression>(Property::VT_VALUE_TYPE, value_type, Expression::NONE);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Property::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PropertyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PropertyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Property<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IdentifierExpressionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IdentifierExpression<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentifierExpression<'a> {
    type Inner = IdentifierExpression<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IdentifierExpression<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IdentifierExpression {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IdentifierExpressionArgs<'args>) -> flatbuffers::WIPOffset<IdentifierExpression<'bldr>> {
      let mut builder = IdentifierExpressionBuilder::new(_fbb);
      if let Some(x) = args.name { builder.add_name(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(IdentifierExpression::VT_LOC, None)
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IdentifierExpression::VT_NAME, None)
  }
}

pub struct IdentifierExpressionArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for IdentifierExpressionArgs<'a> {
    #[inline]
    fn default() -> Self {
        IdentifierExpressionArgs {
            loc: None,
            name: None,
        }
    }
}
pub struct IdentifierExpressionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IdentifierExpressionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(IdentifierExpression::VT_LOC, loc);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IdentifierExpression::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IdentifierExpressionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IdentifierExpressionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentifierExpression<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IdentifierOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Identifier<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Identifier<'a> {
    type Inner = Identifier<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Identifier<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Identifier {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IdentifierArgs<'args>) -> flatbuffers::WIPOffset<Identifier<'bldr>> {
      let mut builder = IdentifierBuilder::new(_fbb);
      if let Some(x) = args.name { builder.add_name(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(Identifier::VT_LOC, None)
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Identifier::VT_NAME, None)
  }
}

pub struct IdentifierArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for IdentifierArgs<'a> {
    #[inline]
    fn default() -> Self {
        IdentifierArgs {
            loc: None,
            name: None,
        }
    }
}
pub struct IdentifierBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IdentifierBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(Identifier::VT_LOC, loc);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Identifier::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IdentifierBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IdentifierBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Identifier<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BooleanLiteralOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BooleanLiteral<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BooleanLiteral<'a> {
    type Inner = BooleanLiteral<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BooleanLiteral<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BooleanLiteral {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BooleanLiteralArgs<'args>) -> flatbuffers::WIPOffset<BooleanLiteral<'bldr>> {
      let mut builder = BooleanLiteralBuilder::new(_fbb);
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.add_value(args.value);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(BooleanLiteral::VT_LOC, None)
  }
  #[inline]
  pub fn value(&self) -> bool {
    self._tab.get::<bool>(BooleanLiteral::VT_VALUE, Some(false)).unwrap()
  }
}

pub struct BooleanLiteralArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub value: bool,
}
impl<'a> Default for BooleanLiteralArgs<'a> {
    #[inline]
    fn default() -> Self {
        BooleanLiteralArgs {
            loc: None,
            value: false,
        }
    }
}
pub struct BooleanLiteralBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BooleanLiteralBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(BooleanLiteral::VT_LOC, loc);
  }
  #[inline]
  pub fn add_value(&mut self, value: bool) {
    self.fbb_.push_slot::<bool>(BooleanLiteral::VT_VALUE, value, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BooleanLiteralBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BooleanLiteralBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BooleanLiteral<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DateTimeLiteralOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DateTimeLiteral<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DateTimeLiteral<'a> {
    type Inner = DateTimeLiteral<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DateTimeLiteral<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DateTimeLiteral {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DateTimeLiteralArgs<'args>) -> flatbuffers::WIPOffset<DateTimeLiteral<'bldr>> {
      let mut builder = DateTimeLiteralBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(DateTimeLiteral::VT_LOC, None)
  }
  #[inline]
  pub fn value(&self) -> Option<Time<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Time<'a>>>(DateTimeLiteral::VT_VALUE, None)
  }
}

pub struct DateTimeLiteralArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub value: Option<flatbuffers::WIPOffset<Time<'a >>>,
}
impl<'a> Default for DateTimeLiteralArgs<'a> {
    #[inline]
    fn default() -> Self {
        DateTimeLiteralArgs {
            loc: None,
            value: None,
        }
    }
}
pub struct DateTimeLiteralBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DateTimeLiteralBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(DateTimeLiteral::VT_LOC, loc);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<Time<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Time>>(DateTimeLiteral::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DateTimeLiteralBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DateTimeLiteralBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DateTimeLiteral<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TimeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Time<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Time<'a> {
    type Inner = Time<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Time<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Time {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TimeArgs) -> flatbuffers::WIPOffset<Time<'bldr>> {
      let mut builder = TimeBuilder::new(_fbb);
      builder.add_timestamp(args.timestamp);
      builder.add_offset(args.offset);
      builder.finish()
    }

    pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 4;
    pub const VT_OFFSET: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn timestamp(&self) -> i64 {
    self._tab.get::<i64>(Time::VT_TIMESTAMP, Some(0)).unwrap()
  }
  #[inline]
  pub fn offset(&self) -> i32 {
    self._tab.get::<i32>(Time::VT_OFFSET, Some(0)).unwrap()
  }
}

pub struct TimeArgs {
    pub timestamp: i64,
    pub offset: i32,
}
impl<'a> Default for TimeArgs {
    #[inline]
    fn default() -> Self {
        TimeArgs {
            timestamp: 0,
            offset: 0,
        }
    }
}
pub struct TimeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TimeBuilder<'a, 'b> {
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: i64) {
    self.fbb_.push_slot::<i64>(Time::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_offset(&mut self, offset: i32) {
    self.fbb_.push_slot::<i32>(Time::VT_OFFSET, offset, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TimeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TimeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Time<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DurationLiteralOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DurationLiteral<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DurationLiteral<'a> {
    type Inner = DurationLiteral<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DurationLiteral<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DurationLiteral {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DurationLiteralArgs<'args>) -> flatbuffers::WIPOffset<DurationLiteral<'bldr>> {
      let mut builder = DurationLiteralBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(DurationLiteral::VT_LOC, None)
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Duration<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Duration<'a>>>>>(DurationLiteral::VT_VALUE, None)
  }
}

pub struct DurationLiteralArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Duration<'a >>>>>,
}
impl<'a> Default for DurationLiteralArgs<'a> {
    #[inline]
    fn default() -> Self {
        DurationLiteralArgs {
            loc: None,
            value: None,
        }
    }
}
pub struct DurationLiteralBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DurationLiteralBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(DurationLiteral::VT_LOC, loc);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Duration<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DurationLiteral::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DurationLiteralBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DurationLiteralBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DurationLiteral<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DurationOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Duration<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Duration<'a> {
    type Inner = Duration<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Duration<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Duration {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DurationArgs) -> flatbuffers::WIPOffset<Duration<'bldr>> {
      let mut builder = DurationBuilder::new(_fbb);
      builder.add_magnitude(args.magnitude);
      builder.add_unit(args.unit);
      builder.finish()
    }

    pub const VT_MAGNITUDE: flatbuffers::VOffsetT = 4;
    pub const VT_UNIT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn magnitude(&self) -> i64 {
    self._tab.get::<i64>(Duration::VT_MAGNITUDE, Some(0)).unwrap()
  }
  #[inline]
  pub fn unit(&self) -> TimeUnit {
    self._tab.get::<TimeUnit>(Duration::VT_UNIT, Some(TimeUnit::y)).unwrap()
  }
}

pub struct DurationArgs {
    pub magnitude: i64,
    pub unit: TimeUnit,
}
impl<'a> Default for DurationArgs {
    #[inline]
    fn default() -> Self {
        DurationArgs {
            magnitude: 0,
            unit: TimeUnit::y,
        }
    }
}
pub struct DurationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DurationBuilder<'a, 'b> {
  #[inline]
  pub fn add_magnitude(&mut self, magnitude: i64) {
    self.fbb_.push_slot::<i64>(Duration::VT_MAGNITUDE, magnitude, 0);
  }
  #[inline]
  pub fn add_unit(&mut self, unit: TimeUnit) {
    self.fbb_.push_slot::<TimeUnit>(Duration::VT_UNIT, unit, TimeUnit::y);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DurationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DurationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Duration<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IntegerLiteralOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IntegerLiteral<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntegerLiteral<'a> {
    type Inner = IntegerLiteral<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IntegerLiteral<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IntegerLiteral {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IntegerLiteralArgs<'args>) -> flatbuffers::WIPOffset<IntegerLiteral<'bldr>> {
      let mut builder = IntegerLiteralBuilder::new(_fbb);
      builder.add_value(args.value);
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(IntegerLiteral::VT_LOC, None)
  }
  #[inline]
  pub fn value(&self) -> i64 {
    self._tab.get::<i64>(IntegerLiteral::VT_VALUE, Some(0)).unwrap()
  }
}

pub struct IntegerLiteralArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub value: i64,
}
impl<'a> Default for IntegerLiteralArgs<'a> {
    #[inline]
    fn default() -> Self {
        IntegerLiteralArgs {
            loc: None,
            value: 0,
        }
    }
}
pub struct IntegerLiteralBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IntegerLiteralBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(IntegerLiteral::VT_LOC, loc);
  }
  #[inline]
  pub fn add_value(&mut self, value: i64) {
    self.fbb_.push_slot::<i64>(IntegerLiteral::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IntegerLiteralBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IntegerLiteralBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IntegerLiteral<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FloatLiteralOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FloatLiteral<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FloatLiteral<'a> {
    type Inner = FloatLiteral<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FloatLiteral<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FloatLiteral {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FloatLiteralArgs<'args>) -> flatbuffers::WIPOffset<FloatLiteral<'bldr>> {
      let mut builder = FloatLiteralBuilder::new(_fbb);
      builder.add_value(args.value);
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(FloatLiteral::VT_LOC, None)
  }
  #[inline]
  pub fn value(&self) -> f64 {
    self._tab.get::<f64>(FloatLiteral::VT_VALUE, Some(0.0)).unwrap()
  }
}

pub struct FloatLiteralArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub value: f64,
}
impl<'a> Default for FloatLiteralArgs<'a> {
    #[inline]
    fn default() -> Self {
        FloatLiteralArgs {
            loc: None,
            value: 0.0,
        }
    }
}
pub struct FloatLiteralBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FloatLiteralBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(FloatLiteral::VT_LOC, loc);
  }
  #[inline]
  pub fn add_value(&mut self, value: f64) {
    self.fbb_.push_slot::<f64>(FloatLiteral::VT_VALUE, value, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FloatLiteralBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FloatLiteralBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FloatLiteral<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RegexpLiteralOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RegexpLiteral<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RegexpLiteral<'a> {
    type Inner = RegexpLiteral<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RegexpLiteral<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RegexpLiteral {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RegexpLiteralArgs<'args>) -> flatbuffers::WIPOffset<RegexpLiteral<'bldr>> {
      let mut builder = RegexpLiteralBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(RegexpLiteral::VT_LOC, None)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RegexpLiteral::VT_VALUE, None)
  }
}

pub struct RegexpLiteralArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub value: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for RegexpLiteralArgs<'a> {
    #[inline]
    fn default() -> Self {
        RegexpLiteralArgs {
            loc: None,
            value: None,
        }
    }
}
pub struct RegexpLiteralBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RegexpLiteralBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(RegexpLiteral::VT_LOC, loc);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RegexpLiteral::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RegexpLiteralBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RegexpLiteralBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RegexpLiteral<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum StringLiteralOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StringLiteral<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StringLiteral<'a> {
    type Inner = StringLiteral<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StringLiteral<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StringLiteral {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StringLiteralArgs<'args>) -> flatbuffers::WIPOffset<StringLiteral<'bldr>> {
      let mut builder = StringLiteralBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(StringLiteral::VT_LOC, None)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringLiteral::VT_VALUE, None)
  }
}

pub struct StringLiteralArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub value: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for StringLiteralArgs<'a> {
    #[inline]
    fn default() -> Self {
        StringLiteralArgs {
            loc: None,
            value: None,
        }
    }
}
pub struct StringLiteralBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StringLiteralBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(StringLiteral::VT_LOC, loc);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringLiteral::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StringLiteralBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StringLiteralBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StringLiteral<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum UnsignedIntegerLiteralOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct UnsignedIntegerLiteral<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnsignedIntegerLiteral<'a> {
    type Inner = UnsignedIntegerLiteral<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> UnsignedIntegerLiteral<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UnsignedIntegerLiteral {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UnsignedIntegerLiteralArgs<'args>) -> flatbuffers::WIPOffset<UnsignedIntegerLiteral<'bldr>> {
      let mut builder = UnsignedIntegerLiteralBuilder::new(_fbb);
      builder.add_value(args.value);
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<SourceLocation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SourceLocation<'a>>>(UnsignedIntegerLiteral::VT_LOC, None)
  }
  #[inline]
  pub fn value(&self) -> u64 {
    self._tab.get::<u64>(UnsignedIntegerLiteral::VT_VALUE, Some(0)).unwrap()
  }
}

pub struct UnsignedIntegerLiteralArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<SourceLocation<'a >>>,
    pub value: u64,
}
impl<'a> Default for UnsignedIntegerLiteralArgs<'a> {
    #[inline]
    fn default() -> Self {
        UnsignedIntegerLiteralArgs {
            loc: None,
            value: 0,
        }
    }
}
pub struct UnsignedIntegerLiteralBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnsignedIntegerLiteralBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<SourceLocation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceLocation>>(UnsignedIntegerLiteral::VT_LOC, loc);
  }
  #[inline]
  pub fn add_value(&mut self, value: u64) {
    self.fbb_.push_slot::<u64>(UnsignedIntegerLiteral::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnsignedIntegerLiteralBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnsignedIntegerLiteralBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnsignedIntegerLiteral<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_package<'a>(buf: &'a [u8]) -> Package<'a> {
  flatbuffers::get_root::<Package<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_package<'a>(buf: &'a [u8]) -> Package<'a> {
  flatbuffers::get_size_prefixed_root::<Package<'a>>(buf)
}

#[inline]
pub fn finish_package_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Package<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_package_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Package<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod fbsemantic


package main

import (
	"bufio"
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"go/format"
	"hash"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

var (
	// walkRootPaths contains the path roots we need
	// to walk through. This is relative to the current
	// directory.
	walkRootPaths = []string{
		"../../src",
		"../../include",
		"../../scanner.c",
		"../../Cargo.toml",
		"../../Cargo.lock",
	}

	// walkFluxPath	is the path for the flux stdlib.
	walkFluxPath = "../../../stdlib"
)

func lsFiles(path string) ([]string, error) {
	cmd := exec.Command("git", "ls-files", "--full-name", "--", path)
	out, err := cmd.Output()
	if err != nil {
		return nil, err
	}

	var files []string
	scanner := bufio.NewScanner(bytes.NewReader(out))
	for scanner.Scan() {
		files = append(files, scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}
	return files, nil
}

// getLibraryFiles will retrieve a list of all of the
// files that the libflux package depends on.
func getLibraryFiles() ([]string, error) {
	var allFiles []string
	for _, root := range walkRootPaths {
		files, err := lsFiles(root)
		if err != nil {
			return nil, err
		}
		allFiles = append(allFiles, files...)
	}

	files, err := lsFiles(walkFluxPath)
	if err != nil {
		return nil, err
	}

	for _, file := range files {
		if !strings.HasSuffix(file, ".flux") {
			continue
		}
		allFiles = append(allFiles, file)
	}
	return allFiles, nil
}

func getRootDir() string {
	cwd, err := os.Getwd()
	if err != nil {
		panic(err)
	}

	for cwd != "/" {
		gitdir := filepath.Join(cwd, ".git")
		if _, err := os.Stat(gitdir); err == nil {
			return cwd
		}
		cwd = filepath.Dir(cwd)
	}
	panic(".git directory not found")
}

func hexdigest(h hash.Hash) string {
	return hex.EncodeToString(h.Sum(nil))
}

func writeTemplate(root string, files []string) error {
	t := template.New("").Funcs(template.FuncMap{
		"hexdigest": func(path string) (string, error) {
			f, err := os.Open(filepath.Join(root, path))
			if err != nil {
				return "", err
			}
			defer func() { _ = f.Close() }()

			shasum := sha256.New()
			if _, err := io.Copy(shasum, f); err != nil {
				return "", err
			}
			return hexdigest(shasum), nil
		},
	})
	t = template.Must(t.Parse(`
// Generated by buildinfo
//
// DO NOT EDIT!

package libflux

// sourceHashes is the hash of the build sources for
// the rust components used by cgo.
// This gets generated from the libflux sources
// and forces the cgo library to rebuild and relink
// the sources. This is because non-C/C++ sources
// are not tracked by Go's build system.'
//lint:ignore U1000 generated code
var sourceHashes = map[string]string{
{{range .}}"{{.}}": "{{hexdigest .}}",
{{end}}
}
`))

	var buf bytes.Buffer
	if err := t.Execute(&buf, files); err != nil {
		return err
	}

	buildinfo, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	return ioutil.WriteFile("buildinfo.gen.go", buildinfo, 0644)
}

func main() {
	root := getRootDir()

	files, err := getLibraryFiles()
	if err != nil {
		panic(err)
	}
	sort.Strings(files)

	if err := writeTemplate(root, files); err != nil {
		panic(err)
	}
}
